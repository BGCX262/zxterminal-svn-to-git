// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_msg_2eproto__INCLUDED
#define PROTOBUF_msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace zaoxun {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msg_2eproto();
void protobuf_AssignDesc_msg_2eproto();
void protobuf_ShutdownFile_msg_2eproto();

class LoginRequest;
class LoginResponse;
class CheckRequest;
class CheckResponse;
class OilQuantityRequest;
class OilQuantityResponse;
class ProductionRequest;
class ProductionResponse;
class DistanceRequest;
class DistanceResponse;
class TimesRequest;
class TimesResponse;
class OilingRequest;
class OilingResponse;
class LoadRequest;
class LoadResponse;
class UnloadRequest;
class UnloadResponse;
class SpeedLimitMessage;
class ShortMessage;
class GPSData;
class AudioFileData;
class CaptureFileData;
class Material;
class MaterialsNotification;
class CollisionCarInfo;
class AntiCollisionNotification;
class EDipperInfo;
class EDipperInfoNotification;
class GetEDippersRequest;
class GetEDippersResponse;
class LoadCompleteNotification;
class CancelLoadRequest;
class CancelLoadResponse;
class RejectLoadRequest;
class RejectLoadResponse;
class ExitNotification;
class DeviceStatusChangeNotification;
class CommonMessage;

enum MessageType {
  LOGIN_REQUEST = 1,
  LOGIN_RESPONSE = 2,
  CHECK_REQUEST = 3,
  CHECK_RESPONSE = 4,
  OIL_QUANTITY_REQUEST = 5,
  OIL_QUANTITY_RESPONSE = 6,
  PRODUCTION_REQUEST = 7,
  PRODUCTION_RESPONSE = 8,
  DISTANCE_REQUEST = 9,
  DISTANCE_RESPONSE = 10,
  TIMES_REQUEST = 11,
  TIMES_RESPONSE = 12,
  OILING_REQUEST = 13,
  OILING_RESPONSE = 14,
  LOAD_REQUEST = 15,
  LOAD_RESPONSE = 16,
  UNLOAD_REQUEST = 17,
  UNLOAD_RESPONSE = 18,
  SPEED_LIMIT = 19,
  SHORT_MESSAGE = 20,
  GPS_DATA = 21,
  AUDIO_FILE_DATA = 22,
  CAPTURE_FILE_DATA = 23,
  MATERIALS_NOTIFICATION = 24,
  ANTI_COLLISION_NOTIFICATION = 25,
  EDIPPERINFO_NOTIFICATION = 26,
  GET_EDIPPERS_REQUEST = 27,
  GET_EDIPPERS_RESPONSE = 28,
  LOAD_COMPLETE_NOTIFICATION = 29,
  CANCEL_LOAD_REQUEST = 30,
  CANCEL_LOAD_RESPONSE = 31,
  REJECT_LOAD_REQUEST = 32,
  REJECT_LOAD_RESPONSE = 33,
  EXIT_NOTIFICATION = 34,
  DEVICE_STATUS_CHANGE_NOTIFICATION = 35
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = LOGIN_REQUEST;
const MessageType MessageType_MAX = DEVICE_STATUS_CHANGE_NOTIFICATION;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum CarType {
  MINE_CAR = 1,
  E_DIPPER = 2,
  OIL_CAR = 3,
  WATER_CAR = 4,
  OTHER_CAR = 5
};
bool CarType_IsValid(int value);
const CarType CarType_MIN = MINE_CAR;
const CarType CarType_MAX = OTHER_CAR;
const int CarType_ARRAYSIZE = CarType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CarType_descriptor();
inline const ::std::string& CarType_Name(CarType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CarType_descriptor(), value);
}
inline bool CarType_Parse(
    const ::std::string& name, CarType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CarType>(
    CarType_descriptor(), name, value);
}
enum RunningStatus {
  RUNNING = 1,
  CLOSED = 2,
  UNKNOWN = 3
};
bool RunningStatus_IsValid(int value);
const RunningStatus RunningStatus_MIN = RUNNING;
const RunningStatus RunningStatus_MAX = UNKNOWN;
const int RunningStatus_ARRAYSIZE = RunningStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RunningStatus_descriptor();
inline const ::std::string& RunningStatus_Name(RunningStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RunningStatus_descriptor(), value);
}
inline bool RunningStatus_Parse(
    const ::std::string& name, RunningStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RunningStatus>(
    RunningStatus_descriptor(), name, value);
}
// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.LoginRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .zaoxun.CarType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::zaoxun::CarType type() const;
  inline void set_type(::zaoxun::CarType value);

  // optional string car_no = 4;
  inline bool has_car_no() const;
  inline void clear_car_no();
  static const int kCarNoFieldNumber = 4;
  inline const ::std::string& car_no() const;
  inline void set_car_no(const ::std::string& value);
  inline void set_car_no(const char* value);
  inline void set_car_no(const char* value, size_t size);
  inline ::std::string* mutable_car_no();
  inline ::std::string* release_car_no();
  inline void set_allocated_car_no(::std::string* car_no);

  // optional .zaoxun.RunningStatus run_status = 5;
  inline bool has_run_status() const;
  inline void clear_run_status();
  static const int kRunStatusFieldNumber = 5;
  inline ::zaoxun::RunningStatus run_status() const;
  inline void set_run_status(::zaoxun::RunningStatus value);

  // @@protoc_insertion_point(class_scope:zaoxun.LoginResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_car_no();
  inline void clear_has_car_no();
  inline void set_has_run_status();
  inline void clear_has_run_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 result_;
  int type_;
  ::std::string* car_no_;
  int run_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class CheckRequest : public ::google::protobuf::Message {
 public:
  CheckRequest();
  virtual ~CheckRequest();

  CheckRequest(const CheckRequest& from);

  inline CheckRequest& operator=(const CheckRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckRequest& default_instance();

  void Swap(CheckRequest* other);

  // implements Message ----------------------------------------------

  CheckRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckRequest& from);
  void MergeFrom(const CheckRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.CheckRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CheckRequest* default_instance_;
};
// -------------------------------------------------------------------

class CheckResponse : public ::google::protobuf::Message {
 public:
  CheckResponse();
  virtual ~CheckResponse();

  CheckResponse(const CheckResponse& from);

  inline CheckResponse& operator=(const CheckResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckResponse& default_instance();

  void Swap(CheckResponse* other);

  // implements Message ----------------------------------------------

  CheckResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckResponse& from);
  void MergeFrom(const CheckResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.CheckResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CheckResponse* default_instance_;
};
// -------------------------------------------------------------------

class OilQuantityRequest : public ::google::protobuf::Message {
 public:
  OilQuantityRequest();
  virtual ~OilQuantityRequest();

  OilQuantityRequest(const OilQuantityRequest& from);

  inline OilQuantityRequest& operator=(const OilQuantityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OilQuantityRequest& default_instance();

  void Swap(OilQuantityRequest* other);

  // implements Message ----------------------------------------------

  OilQuantityRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OilQuantityRequest& from);
  void MergeFrom(const OilQuantityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.OilQuantityRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static OilQuantityRequest* default_instance_;
};
// -------------------------------------------------------------------

class OilQuantityResponse : public ::google::protobuf::Message {
 public:
  OilQuantityResponse();
  virtual ~OilQuantityResponse();

  OilQuantityResponse(const OilQuantityResponse& from);

  inline OilQuantityResponse& operator=(const OilQuantityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OilQuantityResponse& default_instance();

  void Swap(OilQuantityResponse* other);

  // implements Message ----------------------------------------------

  OilQuantityResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OilQuantityResponse& from);
  void MergeFrom(const OilQuantityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional double quantity = 3;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 3;
  inline double quantity() const;
  inline void set_quantity(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.OilQuantityResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_quantity();
  inline void clear_has_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  double quantity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static OilQuantityResponse* default_instance_;
};
// -------------------------------------------------------------------

class ProductionRequest : public ::google::protobuf::Message {
 public:
  ProductionRequest();
  virtual ~ProductionRequest();

  ProductionRequest(const ProductionRequest& from);

  inline ProductionRequest& operator=(const ProductionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductionRequest& default_instance();

  void Swap(ProductionRequest* other);

  // implements Message ----------------------------------------------

  ProductionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductionRequest& from);
  void MergeFrom(const ProductionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.ProductionRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ProductionRequest* default_instance_;
};
// -------------------------------------------------------------------

class ProductionResponse : public ::google::protobuf::Message {
 public:
  ProductionResponse();
  virtual ~ProductionResponse();

  ProductionResponse(const ProductionResponse& from);

  inline ProductionResponse& operator=(const ProductionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductionResponse& default_instance();

  void Swap(ProductionResponse* other);

  // implements Message ----------------------------------------------

  ProductionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductionResponse& from);
  void MergeFrom(const ProductionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // optional double quantity = 3;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 3;
  inline double quantity() const;
  inline void set_quantity(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.ProductionResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();
  inline void set_has_quantity();
  inline void clear_has_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  double quantity_;
  ::google::protobuf::int32 period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ProductionResponse* default_instance_;
};
// -------------------------------------------------------------------

class DistanceRequest : public ::google::protobuf::Message {
 public:
  DistanceRequest();
  virtual ~DistanceRequest();

  DistanceRequest(const DistanceRequest& from);

  inline DistanceRequest& operator=(const DistanceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DistanceRequest& default_instance();

  void Swap(DistanceRequest* other);

  // implements Message ----------------------------------------------

  DistanceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DistanceRequest& from);
  void MergeFrom(const DistanceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.DistanceRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static DistanceRequest* default_instance_;
};
// -------------------------------------------------------------------

class DistanceResponse : public ::google::protobuf::Message {
 public:
  DistanceResponse();
  virtual ~DistanceResponse();

  DistanceResponse(const DistanceResponse& from);

  inline DistanceResponse& operator=(const DistanceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DistanceResponse& default_instance();

  void Swap(DistanceResponse* other);

  // implements Message ----------------------------------------------

  DistanceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DistanceResponse& from);
  void MergeFrom(const DistanceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // optional double distance = 3;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 3;
  inline double distance() const;
  inline void set_distance(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.DistanceResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();
  inline void set_has_distance();
  inline void clear_has_distance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  double distance_;
  ::google::protobuf::int32 period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static DistanceResponse* default_instance_;
};
// -------------------------------------------------------------------

class TimesRequest : public ::google::protobuf::Message {
 public:
  TimesRequest();
  virtual ~TimesRequest();

  TimesRequest(const TimesRequest& from);

  inline TimesRequest& operator=(const TimesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimesRequest& default_instance();

  void Swap(TimesRequest* other);

  // implements Message ----------------------------------------------

  TimesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimesRequest& from);
  void MergeFrom(const TimesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.TimesRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static TimesRequest* default_instance_;
};
// -------------------------------------------------------------------

class TimesResponse : public ::google::protobuf::Message {
 public:
  TimesResponse();
  virtual ~TimesResponse();

  TimesResponse(const TimesResponse& from);

  inline TimesResponse& operator=(const TimesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimesResponse& default_instance();

  void Swap(TimesResponse* other);

  // implements Message ----------------------------------------------

  TimesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimesResponse& from);
  void MergeFrom(const TimesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // optional int32 times = 3;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 3;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.TimesResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();
  inline void set_has_times();
  inline void clear_has_times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 period_;
  ::google::protobuf::int32 times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static TimesResponse* default_instance_;
};
// -------------------------------------------------------------------

class OilingRequest : public ::google::protobuf::Message {
 public:
  OilingRequest();
  virtual ~OilingRequest();

  OilingRequest(const OilingRequest& from);

  inline OilingRequest& operator=(const OilingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OilingRequest& default_instance();

  void Swap(OilingRequest* other);

  // implements Message ----------------------------------------------

  OilingRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OilingRequest& from);
  void MergeFrom(const OilingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // optional double volume = 3;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 3;
  inline double volume() const;
  inline void set_volume(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.OilingRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_volume();
  inline void clear_has_volume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* target_;
  double volume_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static OilingRequest* default_instance_;
};
// -------------------------------------------------------------------

class OilingResponse : public ::google::protobuf::Message {
 public:
  OilingResponse();
  virtual ~OilingResponse();

  OilingResponse(const OilingResponse& from);

  inline OilingResponse& operator=(const OilingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OilingResponse& default_instance();

  void Swap(OilingResponse* other);

  // implements Message ----------------------------------------------

  OilingResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OilingResponse& from);
  void MergeFrom(const OilingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // optional double volume = 3;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 3;
  inline double volume() const;
  inline void set_volume(double value);

  // optional int32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.OilingResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* target_;
  double volume_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static OilingResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoadRequest : public ::google::protobuf::Message {
 public:
  LoadRequest();
  virtual ~LoadRequest();

  LoadRequest(const LoadRequest& from);

  inline LoadRequest& operator=(const LoadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadRequest& default_instance();

  void Swap(LoadRequest* other);

  // implements Message ----------------------------------------------

  LoadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadRequest& from);
  void MergeFrom(const LoadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional string car_no = 3;
  inline bool has_car_no() const;
  inline void clear_car_no();
  static const int kCarNoFieldNumber = 3;
  inline const ::std::string& car_no() const;
  inline void set_car_no(const ::std::string& value);
  inline void set_car_no(const char* value);
  inline void set_car_no(const char* value, size_t size);
  inline ::std::string* mutable_car_no();
  inline ::std::string* release_car_no();
  inline void set_allocated_car_no(::std::string* car_no);

  // @@protoc_insertion_point(class_scope:zaoxun.LoadRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_car_no();
  inline void clear_has_car_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* edipper_device_id_;
  ::std::string* car_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static LoadRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoadResponse : public ::google::protobuf::Message {
 public:
  LoadResponse();
  virtual ~LoadResponse();

  LoadResponse(const LoadResponse& from);

  inline LoadResponse& operator=(const LoadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadResponse& default_instance();

  void Swap(LoadResponse* other);

  // implements Message ----------------------------------------------

  LoadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadResponse& from);
  void MergeFrom(const LoadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional int32 material_id = 3;
  inline bool has_material_id() const;
  inline void clear_material_id();
  static const int kMaterialIdFieldNumber = 3;
  inline ::google::protobuf::int32 material_id() const;
  inline void set_material_id(::google::protobuf::int32 value);

  // optional int32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.LoadResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_material_id();
  inline void clear_has_material_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* edipper_device_id_;
  ::google::protobuf::int32 material_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static LoadResponse* default_instance_;
};
// -------------------------------------------------------------------

class UnloadRequest : public ::google::protobuf::Message {
 public:
  UnloadRequest();
  virtual ~UnloadRequest();

  UnloadRequest(const UnloadRequest& from);

  inline UnloadRequest& operator=(const UnloadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnloadRequest& default_instance();

  void Swap(UnloadRequest* other);

  // implements Message ----------------------------------------------

  UnloadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnloadRequest& from);
  void MergeFrom(const UnloadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.UnloadRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* edipper_device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static UnloadRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnloadResponse : public ::google::protobuf::Message {
 public:
  UnloadResponse();
  virtual ~UnloadResponse();

  UnloadResponse(const UnloadResponse& from);

  inline UnloadResponse& operator=(const UnloadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnloadResponse& default_instance();

  void Swap(UnloadResponse* other);

  // implements Message ----------------------------------------------

  UnloadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnloadResponse& from);
  void MergeFrom(const UnloadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.UnloadResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static UnloadResponse* default_instance_;
};
// -------------------------------------------------------------------

class SpeedLimitMessage : public ::google::protobuf::Message {
 public:
  SpeedLimitMessage();
  virtual ~SpeedLimitMessage();

  SpeedLimitMessage(const SpeedLimitMessage& from);

  inline SpeedLimitMessage& operator=(const SpeedLimitMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedLimitMessage& default_instance();

  void Swap(SpeedLimitMessage* other);

  // implements Message ----------------------------------------------

  SpeedLimitMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeedLimitMessage& from);
  void MergeFrom(const SpeedLimitMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional double speed = 2;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 2;
  inline double speed() const;
  inline void set_speed(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.SpeedLimitMessage)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_speed();
  inline void clear_has_speed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  double speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static SpeedLimitMessage* default_instance_;
};
// -------------------------------------------------------------------

class ShortMessage : public ::google::protobuf::Message {
 public:
  ShortMessage();
  virtual ~ShortMessage();

  ShortMessage(const ShortMessage& from);

  inline ShortMessage& operator=(const ShortMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShortMessage& default_instance();

  void Swap(ShortMessage* other);

  // implements Message ----------------------------------------------

  ShortMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShortMessage& from);
  void MergeFrom(const ShortMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string dest_device = 2;
  inline bool has_dest_device() const;
  inline void clear_dest_device();
  static const int kDestDeviceFieldNumber = 2;
  inline const ::std::string& dest_device() const;
  inline void set_dest_device(const ::std::string& value);
  inline void set_dest_device(const char* value);
  inline void set_dest_device(const char* value, size_t size);
  inline ::std::string* mutable_dest_device();
  inline ::std::string* release_dest_device();
  inline void set_allocated_dest_device(::std::string* dest_device);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:zaoxun.ShortMessage)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_dest_device();
  inline void clear_has_dest_device();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* dest_device_;
  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ShortMessage* default_instance_;
};
// -------------------------------------------------------------------

class GPSData : public ::google::protobuf::Message {
 public:
  GPSData();
  virtual ~GPSData();

  GPSData(const GPSData& from);

  inline GPSData& operator=(const GPSData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSData& default_instance();

  void Swap(GPSData* other);

  // implements Message ----------------------------------------------

  GPSData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSData& from);
  void MergeFrom(const GPSData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string latitude = 3;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 3;
  inline const ::std::string& latitude() const;
  inline void set_latitude(const ::std::string& value);
  inline void set_latitude(const char* value);
  inline void set_latitude(const char* value, size_t size);
  inline ::std::string* mutable_latitude();
  inline ::std::string* release_latitude();
  inline void set_allocated_latitude(::std::string* latitude);

  // optional string longitude = 4;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 4;
  inline const ::std::string& longitude() const;
  inline void set_longitude(const ::std::string& value);
  inline void set_longitude(const char* value);
  inline void set_longitude(const char* value, size_t size);
  inline ::std::string* mutable_longitude();
  inline ::std::string* release_longitude();
  inline void set_allocated_longitude(::std::string* longitude);

  // optional string speed = 5;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 5;
  inline const ::std::string& speed() const;
  inline void set_speed(const ::std::string& value);
  inline void set_speed(const char* value);
  inline void set_speed(const char* value, size_t size);
  inline ::std::string* mutable_speed();
  inline ::std::string* release_speed();
  inline void set_allocated_speed(::std::string* speed);

  // optional string elevation = 6;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 6;
  inline const ::std::string& elevation() const;
  inline void set_elevation(const ::std::string& value);
  inline void set_elevation(const char* value);
  inline void set_elevation(const char* value, size_t size);
  inline ::std::string* mutable_elevation();
  inline ::std::string* release_elevation();
  inline void set_allocated_elevation(::std::string* elevation);

  // optional string direction = 7;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 7;
  inline const ::std::string& direction() const;
  inline void set_direction(const ::std::string& value);
  inline void set_direction(const char* value);
  inline void set_direction(const char* value, size_t size);
  inline ::std::string* mutable_direction();
  inline ::std::string* release_direction();
  inline void set_allocated_direction(::std::string* direction);

  // optional string radius = 8;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 8;
  inline const ::std::string& radius() const;
  inline void set_radius(const ::std::string& value);
  inline void set_radius(const char* value);
  inline void set_radius(const char* value, size_t size);
  inline ::std::string* mutable_radius();
  inline ::std::string* release_radius();
  inline void set_allocated_radius(::std::string* radius);

  // optional string loctype = 9;
  inline bool has_loctype() const;
  inline void clear_loctype();
  static const int kLoctypeFieldNumber = 9;
  inline const ::std::string& loctype() const;
  inline void set_loctype(const ::std::string& value);
  inline void set_loctype(const char* value);
  inline void set_loctype(const char* value, size_t size);
  inline ::std::string* mutable_loctype();
  inline ::std::string* release_loctype();
  inline void set_allocated_loctype(::std::string* loctype);

  // optional string addrstr = 10;
  inline bool has_addrstr() const;
  inline void clear_addrstr();
  static const int kAddrstrFieldNumber = 10;
  inline const ::std::string& addrstr() const;
  inline void set_addrstr(const ::std::string& value);
  inline void set_addrstr(const char* value);
  inline void set_addrstr(const char* value, size_t size);
  inline ::std::string* mutable_addrstr();
  inline ::std::string* release_addrstr();
  inline void set_allocated_addrstr(::std::string* addrstr);

  // optional string province = 11;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 11;
  inline const ::std::string& province() const;
  inline void set_province(const ::std::string& value);
  inline void set_province(const char* value);
  inline void set_province(const char* value, size_t size);
  inline ::std::string* mutable_province();
  inline ::std::string* release_province();
  inline void set_allocated_province(::std::string* province);

  // optional string city = 12;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 12;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string district = 13;
  inline bool has_district() const;
  inline void clear_district();
  static const int kDistrictFieldNumber = 13;
  inline const ::std::string& district() const;
  inline void set_district(const ::std::string& value);
  inline void set_district(const char* value);
  inline void set_district(const char* value, size_t size);
  inline ::std::string* mutable_district();
  inline ::std::string* release_district();
  inline void set_allocated_district(::std::string* district);

  // optional string poi = 14;
  inline bool has_poi() const;
  inline void clear_poi();
  static const int kPoiFieldNumber = 14;
  inline const ::std::string& poi() const;
  inline void set_poi(const ::std::string& value);
  inline void set_poi(const char* value);
  inline void set_poi(const char* value, size_t size);
  inline ::std::string* mutable_poi();
  inline ::std::string* release_poi();
  inline void set_allocated_poi(::std::string* poi);

  // @@protoc_insertion_point(class_scope:zaoxun.GPSData)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_loctype();
  inline void clear_has_loctype();
  inline void set_has_addrstr();
  inline void clear_has_addrstr();
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_district();
  inline void clear_has_district();
  inline void set_has_poi();
  inline void clear_has_poi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* time_;
  ::std::string* latitude_;
  ::std::string* longitude_;
  ::std::string* speed_;
  ::std::string* elevation_;
  ::std::string* direction_;
  ::std::string* radius_;
  ::std::string* loctype_;
  ::std::string* addrstr_;
  ::std::string* province_;
  ::std::string* city_;
  ::std::string* district_;
  ::std::string* poi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static GPSData* default_instance_;
};
// -------------------------------------------------------------------

class AudioFileData : public ::google::protobuf::Message {
 public:
  AudioFileData();
  virtual ~AudioFileData();

  AudioFileData(const AudioFileData& from);

  inline AudioFileData& operator=(const AudioFileData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioFileData& default_instance();

  void Swap(AudioFileData* other);

  // implements Message ----------------------------------------------

  AudioFileData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioFileData& from);
  void MergeFrom(const AudioFileData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional string dest_device = 4;
  inline bool has_dest_device() const;
  inline void clear_dest_device();
  static const int kDestDeviceFieldNumber = 4;
  inline const ::std::string& dest_device() const;
  inline void set_dest_device(const ::std::string& value);
  inline void set_dest_device(const char* value);
  inline void set_dest_device(const char* value, size_t size);
  inline ::std::string* mutable_dest_device();
  inline ::std::string* release_dest_device();
  inline void set_allocated_dest_device(::std::string* dest_device);

  // optional int32 total_packets = 5;
  inline bool has_total_packets() const;
  inline void clear_total_packets();
  static const int kTotalPacketsFieldNumber = 5;
  inline ::google::protobuf::int32 total_packets() const;
  inline void set_total_packets(::google::protobuf::int32 value);

  // optional int32 current_packet = 6;
  inline bool has_current_packet() const;
  inline void clear_current_packet();
  static const int kCurrentPacketFieldNumber = 6;
  inline ::google::protobuf::int32 current_packet() const;
  inline void set_current_packet(::google::protobuf::int32 value);

  // optional int32 data_len = 7;
  inline bool has_data_len() const;
  inline void clear_data_len();
  static const int kDataLenFieldNumber = 7;
  inline ::google::protobuf::int32 data_len() const;
  inline void set_data_len(::google::protobuf::int32 value);

  // optional bytes data = 8;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 8;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:zaoxun.AudioFileData)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_dest_device();
  inline void clear_has_dest_device();
  inline void set_has_total_packets();
  inline void clear_has_total_packets();
  inline void set_has_current_packet();
  inline void clear_has_current_packet();
  inline void set_has_data_len();
  inline void clear_has_data_len();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* time_;
  ::std::string* file_name_;
  ::std::string* dest_device_;
  ::google::protobuf::int32 total_packets_;
  ::google::protobuf::int32 current_packet_;
  ::std::string* data_;
  ::google::protobuf::int32 data_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static AudioFileData* default_instance_;
};
// -------------------------------------------------------------------

class CaptureFileData : public ::google::protobuf::Message {
 public:
  CaptureFileData();
  virtual ~CaptureFileData();

  CaptureFileData(const CaptureFileData& from);

  inline CaptureFileData& operator=(const CaptureFileData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaptureFileData& default_instance();

  void Swap(CaptureFileData* other);

  // implements Message ----------------------------------------------

  CaptureFileData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaptureFileData& from);
  void MergeFrom(const CaptureFileData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional int32 total_packets = 4;
  inline bool has_total_packets() const;
  inline void clear_total_packets();
  static const int kTotalPacketsFieldNumber = 4;
  inline ::google::protobuf::int32 total_packets() const;
  inline void set_total_packets(::google::protobuf::int32 value);

  // optional int32 current_packet = 5;
  inline bool has_current_packet() const;
  inline void clear_current_packet();
  static const int kCurrentPacketFieldNumber = 5;
  inline ::google::protobuf::int32 current_packet() const;
  inline void set_current_packet(::google::protobuf::int32 value);

  // optional int32 data_len = 6;
  inline bool has_data_len() const;
  inline void clear_data_len();
  static const int kDataLenFieldNumber = 6;
  inline ::google::protobuf::int32 data_len() const;
  inline void set_data_len(::google::protobuf::int32 value);

  // optional bytes data = 7;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 7;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:zaoxun.CaptureFileData)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_total_packets();
  inline void clear_has_total_packets();
  inline void set_has_current_packet();
  inline void clear_has_current_packet();
  inline void set_has_data_len();
  inline void clear_has_data_len();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* time_;
  ::std::string* file_name_;
  ::google::protobuf::int32 total_packets_;
  ::google::protobuf::int32 current_packet_;
  ::std::string* data_;
  ::google::protobuf::int32 data_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CaptureFileData* default_instance_;
};
// -------------------------------------------------------------------

class Material : public ::google::protobuf::Message {
 public:
  Material();
  virtual ~Material();

  Material(const Material& from);

  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Material& default_instance();

  void Swap(Material* other);

  // implements Message ----------------------------------------------

  Material* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 material_id = 1;
  inline bool has_material_id() const;
  inline void clear_material_id();
  static const int kMaterialIdFieldNumber = 1;
  inline ::google::protobuf::int32 material_id() const;
  inline void set_material_id(::google::protobuf::int32 value);

  // optional string english_name = 2;
  inline bool has_english_name() const;
  inline void clear_english_name();
  static const int kEnglishNameFieldNumber = 2;
  inline const ::std::string& english_name() const;
  inline void set_english_name(const ::std::string& value);
  inline void set_english_name(const char* value);
  inline void set_english_name(const char* value, size_t size);
  inline ::std::string* mutable_english_name();
  inline ::std::string* release_english_name();
  inline void set_allocated_english_name(::std::string* english_name);

  // optional string chinese_name = 3;
  inline bool has_chinese_name() const;
  inline void clear_chinese_name();
  static const int kChineseNameFieldNumber = 3;
  inline const ::std::string& chinese_name() const;
  inline void set_chinese_name(const ::std::string& value);
  inline void set_chinese_name(const char* value);
  inline void set_chinese_name(const char* value, size_t size);
  inline ::std::string* mutable_chinese_name();
  inline ::std::string* release_chinese_name();
  inline void set_allocated_chinese_name(::std::string* chinese_name);

  // @@protoc_insertion_point(class_scope:zaoxun.Material)
 private:
  inline void set_has_material_id();
  inline void clear_has_material_id();
  inline void set_has_english_name();
  inline void clear_has_english_name();
  inline void set_has_chinese_name();
  inline void clear_has_chinese_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* english_name_;
  ::std::string* chinese_name_;
  ::google::protobuf::int32 material_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Material* default_instance_;
};
// -------------------------------------------------------------------

class MaterialsNotification : public ::google::protobuf::Message {
 public:
  MaterialsNotification();
  virtual ~MaterialsNotification();

  MaterialsNotification(const MaterialsNotification& from);

  inline MaterialsNotification& operator=(const MaterialsNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaterialsNotification& default_instance();

  void Swap(MaterialsNotification* other);

  // implements Message ----------------------------------------------

  MaterialsNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaterialsNotification& from);
  void MergeFrom(const MaterialsNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zaoxun.Material material = 1;
  inline int material_size() const;
  inline void clear_material();
  static const int kMaterialFieldNumber = 1;
  inline const ::zaoxun::Material& material(int index) const;
  inline ::zaoxun::Material* mutable_material(int index);
  inline ::zaoxun::Material* add_material();
  inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >&
      material() const;
  inline ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >*
      mutable_material();

  // @@protoc_insertion_point(class_scope:zaoxun.MaterialsNotification)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::zaoxun::Material > material_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static MaterialsNotification* default_instance_;
};
// -------------------------------------------------------------------

class CollisionCarInfo : public ::google::protobuf::Message {
 public:
  CollisionCarInfo();
  virtual ~CollisionCarInfo();

  CollisionCarInfo(const CollisionCarInfo& from);

  inline CollisionCarInfo& operator=(const CollisionCarInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionCarInfo& default_instance();

  void Swap(CollisionCarInfo* other);

  // implements Message ----------------------------------------------

  CollisionCarInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionCarInfo& from);
  void MergeFrom(const CollisionCarInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional .zaoxun.CarType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::zaoxun::CarType type() const;
  inline void set_type(::zaoxun::CarType value);

  // optional string car_no = 3;
  inline bool has_car_no() const;
  inline void clear_car_no();
  static const int kCarNoFieldNumber = 3;
  inline const ::std::string& car_no() const;
  inline void set_car_no(const ::std::string& value);
  inline void set_car_no(const char* value);
  inline void set_car_no(const char* value, size_t size);
  inline ::std::string* mutable_car_no();
  inline ::std::string* release_car_no();
  inline void set_allocated_car_no(::std::string* car_no);

  // optional int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional double distance = 5;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 5;
  inline double distance() const;
  inline void set_distance(double value);

  // optional double longitude = 6;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 6;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional double latitude = 7;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 7;
  inline double latitude() const;
  inline void set_latitude(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.CollisionCarInfo)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_car_no();
  inline void clear_has_car_no();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* car_no_;
  int type_;
  ::google::protobuf::int32 level_;
  double distance_;
  double longitude_;
  double latitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CollisionCarInfo* default_instance_;
};
// -------------------------------------------------------------------

class AntiCollisionNotification : public ::google::protobuf::Message {
 public:
  AntiCollisionNotification();
  virtual ~AntiCollisionNotification();

  AntiCollisionNotification(const AntiCollisionNotification& from);

  inline AntiCollisionNotification& operator=(const AntiCollisionNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntiCollisionNotification& default_instance();

  void Swap(AntiCollisionNotification* other);

  // implements Message ----------------------------------------------

  AntiCollisionNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AntiCollisionNotification& from);
  void MergeFrom(const AntiCollisionNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double angle = 1;
  inline int angle_size() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 1;
  inline double angle(int index) const;
  inline void set_angle(int index, double value);
  inline void add_angle(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      angle() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_angle();

  // @@protoc_insertion_point(class_scope:zaoxun.AntiCollisionNotification)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< double > angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static AntiCollisionNotification* default_instance_;
};
// -------------------------------------------------------------------

class EDipperInfo : public ::google::protobuf::Message {
 public:
  EDipperInfo();
  virtual ~EDipperInfo();

  EDipperInfo(const EDipperInfo& from);

  inline EDipperInfo& operator=(const EDipperInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EDipperInfo& default_instance();

  void Swap(EDipperInfo* other);

  // implements Message ----------------------------------------------

  EDipperInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EDipperInfo& from);
  void MergeFrom(const EDipperInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string device_no = 2;
  inline bool has_device_no() const;
  inline void clear_device_no();
  static const int kDeviceNoFieldNumber = 2;
  inline const ::std::string& device_no() const;
  inline void set_device_no(const ::std::string& value);
  inline void set_device_no(const char* value);
  inline void set_device_no(const char* value, size_t size);
  inline ::std::string* mutable_device_no();
  inline ::std::string* release_device_no();
  inline void set_allocated_device_no(::std::string* device_no);

  // optional double longitude = 3;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 3;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional double latitude = 4;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  inline double latitude() const;
  inline void set_latitude(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.EDipperInfo)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_device_no();
  inline void clear_has_device_no();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* device_no_;
  double longitude_;
  double latitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static EDipperInfo* default_instance_;
};
// -------------------------------------------------------------------

class EDipperInfoNotification : public ::google::protobuf::Message {
 public:
  EDipperInfoNotification();
  virtual ~EDipperInfoNotification();

  EDipperInfoNotification(const EDipperInfoNotification& from);

  inline EDipperInfoNotification& operator=(const EDipperInfoNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EDipperInfoNotification& default_instance();

  void Swap(EDipperInfoNotification* other);

  // implements Message ----------------------------------------------

  EDipperInfoNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EDipperInfoNotification& from);
  void MergeFrom(const EDipperInfoNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zaoxun.EDipperInfo infos = 1;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 1;
  inline const ::zaoxun::EDipperInfo& infos(int index) const;
  inline ::zaoxun::EDipperInfo* mutable_infos(int index);
  inline ::zaoxun::EDipperInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:zaoxun.EDipperInfoNotification)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo > infos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static EDipperInfoNotification* default_instance_;
};
// -------------------------------------------------------------------

class GetEDippersRequest : public ::google::protobuf::Message {
 public:
  GetEDippersRequest();
  virtual ~GetEDippersRequest();

  GetEDippersRequest(const GetEDippersRequest& from);

  inline GetEDippersRequest& operator=(const GetEDippersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEDippersRequest& default_instance();

  void Swap(GetEDippersRequest* other);

  // implements Message ----------------------------------------------

  GetEDippersRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEDippersRequest& from);
  void MergeFrom(const GetEDippersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.GetEDippersRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static GetEDippersRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetEDippersResponse : public ::google::protobuf::Message {
 public:
  GetEDippersResponse();
  virtual ~GetEDippersResponse();

  GetEDippersResponse(const GetEDippersResponse& from);

  inline GetEDippersResponse& operator=(const GetEDippersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEDippersResponse& default_instance();

  void Swap(GetEDippersResponse* other);

  // implements Message ----------------------------------------------

  GetEDippersResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEDippersResponse& from);
  void MergeFrom(const GetEDippersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // repeated .zaoxun.EDipperInfo edippers = 2;
  inline int edippers_size() const;
  inline void clear_edippers();
  static const int kEdippersFieldNumber = 2;
  inline const ::zaoxun::EDipperInfo& edippers(int index) const;
  inline ::zaoxun::EDipperInfo* mutable_edippers(int index);
  inline ::zaoxun::EDipperInfo* add_edippers();
  inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >&
      edippers() const;
  inline ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >*
      mutable_edippers();

  // @@protoc_insertion_point(class_scope:zaoxun.GetEDippersResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo > edippers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static GetEDippersResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoadCompleteNotification : public ::google::protobuf::Message {
 public:
  LoadCompleteNotification();
  virtual ~LoadCompleteNotification();

  LoadCompleteNotification(const LoadCompleteNotification& from);

  inline LoadCompleteNotification& operator=(const LoadCompleteNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadCompleteNotification& default_instance();

  void Swap(LoadCompleteNotification* other);

  // implements Message ----------------------------------------------

  LoadCompleteNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadCompleteNotification& from);
  void MergeFrom(const LoadCompleteNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string edipper_device_id = 1;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 1;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional string car_device_id = 2;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 2;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // optional int32 load_result = 3;
  inline bool has_load_result() const;
  inline void clear_load_result();
  static const int kLoadResultFieldNumber = 3;
  inline ::google::protobuf::int32 load_result() const;
  inline void set_load_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.LoadCompleteNotification)
 private:
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();
  inline void set_has_load_result();
  inline void clear_has_load_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* edipper_device_id_;
  ::std::string* car_device_id_;
  ::google::protobuf::int32 load_result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static LoadCompleteNotification* default_instance_;
};
// -------------------------------------------------------------------

class CancelLoadRequest : public ::google::protobuf::Message {
 public:
  CancelLoadRequest();
  virtual ~CancelLoadRequest();

  CancelLoadRequest(const CancelLoadRequest& from);

  inline CancelLoadRequest& operator=(const CancelLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelLoadRequest& default_instance();

  void Swap(CancelLoadRequest* other);

  // implements Message ----------------------------------------------

  CancelLoadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelLoadRequest& from);
  void MergeFrom(const CancelLoadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string car_device_id = 1;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 1;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.CancelLoadRequest)
 private:
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* car_device_id_;
  ::std::string* edipper_device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CancelLoadRequest* default_instance_;
};
// -------------------------------------------------------------------

class CancelLoadResponse : public ::google::protobuf::Message {
 public:
  CancelLoadResponse();
  virtual ~CancelLoadResponse();

  CancelLoadResponse(const CancelLoadResponse& from);

  inline CancelLoadResponse& operator=(const CancelLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelLoadResponse& default_instance();

  void Swap(CancelLoadResponse* other);

  // implements Message ----------------------------------------------

  CancelLoadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelLoadResponse& from);
  void MergeFrom(const CancelLoadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string car_device_id = 1;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 1;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.CancelLoadResponse)
 private:
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* car_device_id_;
  ::std::string* edipper_device_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CancelLoadResponse* default_instance_;
};
// -------------------------------------------------------------------

class RejectLoadRequest : public ::google::protobuf::Message {
 public:
  RejectLoadRequest();
  virtual ~RejectLoadRequest();

  RejectLoadRequest(const RejectLoadRequest& from);

  inline RejectLoadRequest& operator=(const RejectLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RejectLoadRequest& default_instance();

  void Swap(RejectLoadRequest* other);

  // implements Message ----------------------------------------------

  RejectLoadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RejectLoadRequest& from);
  void MergeFrom(const RejectLoadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string edipper_device_id = 1;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 1;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional string car_device_id = 2;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 2;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.RejectLoadRequest)
 private:
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* edipper_device_id_;
  ::std::string* car_device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static RejectLoadRequest* default_instance_;
};
// -------------------------------------------------------------------

class RejectLoadResponse : public ::google::protobuf::Message {
 public:
  RejectLoadResponse();
  virtual ~RejectLoadResponse();

  RejectLoadResponse(const RejectLoadResponse& from);

  inline RejectLoadResponse& operator=(const RejectLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RejectLoadResponse& default_instance();

  void Swap(RejectLoadResponse* other);

  // implements Message ----------------------------------------------

  RejectLoadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RejectLoadResponse& from);
  void MergeFrom(const RejectLoadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string edipper_device_id = 1;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 1;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional string car_device_id = 2;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 2;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // optional int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.RejectLoadResponse)
 private:
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* edipper_device_id_;
  ::std::string* car_device_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static RejectLoadResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExitNotification : public ::google::protobuf::Message {
 public:
  ExitNotification();
  virtual ~ExitNotification();

  ExitNotification(const ExitNotification& from);

  inline ExitNotification& operator=(const ExitNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExitNotification& default_instance();

  void Swap(ExitNotification* other);

  // implements Message ----------------------------------------------

  ExitNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExitNotification& from);
  void MergeFrom(const ExitNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 exit_type = 2;
  inline bool has_exit_type() const;
  inline void clear_exit_type();
  static const int kExitTypeFieldNumber = 2;
  inline ::google::protobuf::int32 exit_type() const;
  inline void set_exit_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.ExitNotification)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_exit_type();
  inline void clear_has_exit_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 exit_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ExitNotification* default_instance_;
};
// -------------------------------------------------------------------

class DeviceStatusChangeNotification : public ::google::protobuf::Message {
 public:
  DeviceStatusChangeNotification();
  virtual ~DeviceStatusChangeNotification();

  DeviceStatusChangeNotification(const DeviceStatusChangeNotification& from);

  inline DeviceStatusChangeNotification& operator=(const DeviceStatusChangeNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceStatusChangeNotification& default_instance();

  void Swap(DeviceStatusChangeNotification* other);

  // implements Message ----------------------------------------------

  DeviceStatusChangeNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceStatusChangeNotification& from);
  void MergeFrom(const DeviceStatusChangeNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional .zaoxun.RunningStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::zaoxun::RunningStatus status() const;
  inline void set_status(::zaoxun::RunningStatus value);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.DeviceStatusChangeNotification)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  int status_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static DeviceStatusChangeNotification* default_instance_;
};
// -------------------------------------------------------------------

class CommonMessage : public ::google::protobuf::Message {
 public:
  CommonMessage();
  virtual ~CommonMessage();

  CommonMessage(const CommonMessage& from);

  inline CommonMessage& operator=(const CommonMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonMessage& default_instance();

  void Swap(CommonMessage* other);

  // implements Message ----------------------------------------------

  CommonMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonMessage& from);
  void MergeFrom(const CommonMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zaoxun.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::zaoxun::MessageType type() const;
  inline void set_type(::zaoxun::MessageType value);

  // optional .zaoxun.LoginRequest login_request = 2;
  inline bool has_login_request() const;
  inline void clear_login_request();
  static const int kLoginRequestFieldNumber = 2;
  inline const ::zaoxun::LoginRequest& login_request() const;
  inline ::zaoxun::LoginRequest* mutable_login_request();
  inline ::zaoxun::LoginRequest* release_login_request();
  inline void set_allocated_login_request(::zaoxun::LoginRequest* login_request);

  // optional .zaoxun.LoginResponse login_response = 3;
  inline bool has_login_response() const;
  inline void clear_login_response();
  static const int kLoginResponseFieldNumber = 3;
  inline const ::zaoxun::LoginResponse& login_response() const;
  inline ::zaoxun::LoginResponse* mutable_login_response();
  inline ::zaoxun::LoginResponse* release_login_response();
  inline void set_allocated_login_response(::zaoxun::LoginResponse* login_response);

  // optional .zaoxun.CheckRequest check_request = 4;
  inline bool has_check_request() const;
  inline void clear_check_request();
  static const int kCheckRequestFieldNumber = 4;
  inline const ::zaoxun::CheckRequest& check_request() const;
  inline ::zaoxun::CheckRequest* mutable_check_request();
  inline ::zaoxun::CheckRequest* release_check_request();
  inline void set_allocated_check_request(::zaoxun::CheckRequest* check_request);

  // optional .zaoxun.CheckResponse check_response = 5;
  inline bool has_check_response() const;
  inline void clear_check_response();
  static const int kCheckResponseFieldNumber = 5;
  inline const ::zaoxun::CheckResponse& check_response() const;
  inline ::zaoxun::CheckResponse* mutable_check_response();
  inline ::zaoxun::CheckResponse* release_check_response();
  inline void set_allocated_check_response(::zaoxun::CheckResponse* check_response);

  // optional .zaoxun.OilQuantityRequest oil_quantity_request = 6;
  inline bool has_oil_quantity_request() const;
  inline void clear_oil_quantity_request();
  static const int kOilQuantityRequestFieldNumber = 6;
  inline const ::zaoxun::OilQuantityRequest& oil_quantity_request() const;
  inline ::zaoxun::OilQuantityRequest* mutable_oil_quantity_request();
  inline ::zaoxun::OilQuantityRequest* release_oil_quantity_request();
  inline void set_allocated_oil_quantity_request(::zaoxun::OilQuantityRequest* oil_quantity_request);

  // optional .zaoxun.OilQuantityResponse oil_quantity_response = 7;
  inline bool has_oil_quantity_response() const;
  inline void clear_oil_quantity_response();
  static const int kOilQuantityResponseFieldNumber = 7;
  inline const ::zaoxun::OilQuantityResponse& oil_quantity_response() const;
  inline ::zaoxun::OilQuantityResponse* mutable_oil_quantity_response();
  inline ::zaoxun::OilQuantityResponse* release_oil_quantity_response();
  inline void set_allocated_oil_quantity_response(::zaoxun::OilQuantityResponse* oil_quantity_response);

  // optional .zaoxun.ProductionRequest production_request = 8;
  inline bool has_production_request() const;
  inline void clear_production_request();
  static const int kProductionRequestFieldNumber = 8;
  inline const ::zaoxun::ProductionRequest& production_request() const;
  inline ::zaoxun::ProductionRequest* mutable_production_request();
  inline ::zaoxun::ProductionRequest* release_production_request();
  inline void set_allocated_production_request(::zaoxun::ProductionRequest* production_request);

  // optional .zaoxun.ProductionResponse production_response = 9;
  inline bool has_production_response() const;
  inline void clear_production_response();
  static const int kProductionResponseFieldNumber = 9;
  inline const ::zaoxun::ProductionResponse& production_response() const;
  inline ::zaoxun::ProductionResponse* mutable_production_response();
  inline ::zaoxun::ProductionResponse* release_production_response();
  inline void set_allocated_production_response(::zaoxun::ProductionResponse* production_response);

  // optional .zaoxun.DistanceRequest distance_request = 10;
  inline bool has_distance_request() const;
  inline void clear_distance_request();
  static const int kDistanceRequestFieldNumber = 10;
  inline const ::zaoxun::DistanceRequest& distance_request() const;
  inline ::zaoxun::DistanceRequest* mutable_distance_request();
  inline ::zaoxun::DistanceRequest* release_distance_request();
  inline void set_allocated_distance_request(::zaoxun::DistanceRequest* distance_request);

  // optional .zaoxun.DistanceResponse distance_response = 11;
  inline bool has_distance_response() const;
  inline void clear_distance_response();
  static const int kDistanceResponseFieldNumber = 11;
  inline const ::zaoxun::DistanceResponse& distance_response() const;
  inline ::zaoxun::DistanceResponse* mutable_distance_response();
  inline ::zaoxun::DistanceResponse* release_distance_response();
  inline void set_allocated_distance_response(::zaoxun::DistanceResponse* distance_response);

  // optional .zaoxun.TimesRequest times_request = 12;
  inline bool has_times_request() const;
  inline void clear_times_request();
  static const int kTimesRequestFieldNumber = 12;
  inline const ::zaoxun::TimesRequest& times_request() const;
  inline ::zaoxun::TimesRequest* mutable_times_request();
  inline ::zaoxun::TimesRequest* release_times_request();
  inline void set_allocated_times_request(::zaoxun::TimesRequest* times_request);

  // optional .zaoxun.TimesResponse times_response = 13;
  inline bool has_times_response() const;
  inline void clear_times_response();
  static const int kTimesResponseFieldNumber = 13;
  inline const ::zaoxun::TimesResponse& times_response() const;
  inline ::zaoxun::TimesResponse* mutable_times_response();
  inline ::zaoxun::TimesResponse* release_times_response();
  inline void set_allocated_times_response(::zaoxun::TimesResponse* times_response);

  // optional .zaoxun.OilingRequest oiling_request = 14;
  inline bool has_oiling_request() const;
  inline void clear_oiling_request();
  static const int kOilingRequestFieldNumber = 14;
  inline const ::zaoxun::OilingRequest& oiling_request() const;
  inline ::zaoxun::OilingRequest* mutable_oiling_request();
  inline ::zaoxun::OilingRequest* release_oiling_request();
  inline void set_allocated_oiling_request(::zaoxun::OilingRequest* oiling_request);

  // optional .zaoxun.OilingResponse oiling_response = 15;
  inline bool has_oiling_response() const;
  inline void clear_oiling_response();
  static const int kOilingResponseFieldNumber = 15;
  inline const ::zaoxun::OilingResponse& oiling_response() const;
  inline ::zaoxun::OilingResponse* mutable_oiling_response();
  inline ::zaoxun::OilingResponse* release_oiling_response();
  inline void set_allocated_oiling_response(::zaoxun::OilingResponse* oiling_response);

  // optional .zaoxun.LoadRequest load_request = 16;
  inline bool has_load_request() const;
  inline void clear_load_request();
  static const int kLoadRequestFieldNumber = 16;
  inline const ::zaoxun::LoadRequest& load_request() const;
  inline ::zaoxun::LoadRequest* mutable_load_request();
  inline ::zaoxun::LoadRequest* release_load_request();
  inline void set_allocated_load_request(::zaoxun::LoadRequest* load_request);

  // optional .zaoxun.LoadResponse load_response = 17;
  inline bool has_load_response() const;
  inline void clear_load_response();
  static const int kLoadResponseFieldNumber = 17;
  inline const ::zaoxun::LoadResponse& load_response() const;
  inline ::zaoxun::LoadResponse* mutable_load_response();
  inline ::zaoxun::LoadResponse* release_load_response();
  inline void set_allocated_load_response(::zaoxun::LoadResponse* load_response);

  // optional .zaoxun.UnloadRequest unload_request = 18;
  inline bool has_unload_request() const;
  inline void clear_unload_request();
  static const int kUnloadRequestFieldNumber = 18;
  inline const ::zaoxun::UnloadRequest& unload_request() const;
  inline ::zaoxun::UnloadRequest* mutable_unload_request();
  inline ::zaoxun::UnloadRequest* release_unload_request();
  inline void set_allocated_unload_request(::zaoxun::UnloadRequest* unload_request);

  // optional .zaoxun.UnloadResponse unload_response = 19;
  inline bool has_unload_response() const;
  inline void clear_unload_response();
  static const int kUnloadResponseFieldNumber = 19;
  inline const ::zaoxun::UnloadResponse& unload_response() const;
  inline ::zaoxun::UnloadResponse* mutable_unload_response();
  inline ::zaoxun::UnloadResponse* release_unload_response();
  inline void set_allocated_unload_response(::zaoxun::UnloadResponse* unload_response);

  // optional .zaoxun.SpeedLimitMessage speed_limit = 20;
  inline bool has_speed_limit() const;
  inline void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 20;
  inline const ::zaoxun::SpeedLimitMessage& speed_limit() const;
  inline ::zaoxun::SpeedLimitMessage* mutable_speed_limit();
  inline ::zaoxun::SpeedLimitMessage* release_speed_limit();
  inline void set_allocated_speed_limit(::zaoxun::SpeedLimitMessage* speed_limit);

  // optional .zaoxun.ShortMessage short_message = 21;
  inline bool has_short_message() const;
  inline void clear_short_message();
  static const int kShortMessageFieldNumber = 21;
  inline const ::zaoxun::ShortMessage& short_message() const;
  inline ::zaoxun::ShortMessage* mutable_short_message();
  inline ::zaoxun::ShortMessage* release_short_message();
  inline void set_allocated_short_message(::zaoxun::ShortMessage* short_message);

  // optional .zaoxun.GPSData gps_data = 22;
  inline bool has_gps_data() const;
  inline void clear_gps_data();
  static const int kGpsDataFieldNumber = 22;
  inline const ::zaoxun::GPSData& gps_data() const;
  inline ::zaoxun::GPSData* mutable_gps_data();
  inline ::zaoxun::GPSData* release_gps_data();
  inline void set_allocated_gps_data(::zaoxun::GPSData* gps_data);

  // optional .zaoxun.AudioFileData audio_file_data = 23;
  inline bool has_audio_file_data() const;
  inline void clear_audio_file_data();
  static const int kAudioFileDataFieldNumber = 23;
  inline const ::zaoxun::AudioFileData& audio_file_data() const;
  inline ::zaoxun::AudioFileData* mutable_audio_file_data();
  inline ::zaoxun::AudioFileData* release_audio_file_data();
  inline void set_allocated_audio_file_data(::zaoxun::AudioFileData* audio_file_data);

  // optional .zaoxun.CaptureFileData capture_file_data = 24;
  inline bool has_capture_file_data() const;
  inline void clear_capture_file_data();
  static const int kCaptureFileDataFieldNumber = 24;
  inline const ::zaoxun::CaptureFileData& capture_file_data() const;
  inline ::zaoxun::CaptureFileData* mutable_capture_file_data();
  inline ::zaoxun::CaptureFileData* release_capture_file_data();
  inline void set_allocated_capture_file_data(::zaoxun::CaptureFileData* capture_file_data);

  // optional .zaoxun.MaterialsNotification materials_notification = 25;
  inline bool has_materials_notification() const;
  inline void clear_materials_notification();
  static const int kMaterialsNotificationFieldNumber = 25;
  inline const ::zaoxun::MaterialsNotification& materials_notification() const;
  inline ::zaoxun::MaterialsNotification* mutable_materials_notification();
  inline ::zaoxun::MaterialsNotification* release_materials_notification();
  inline void set_allocated_materials_notification(::zaoxun::MaterialsNotification* materials_notification);

  // optional .zaoxun.AntiCollisionNotification anticollision_notification = 26;
  inline bool has_anticollision_notification() const;
  inline void clear_anticollision_notification();
  static const int kAnticollisionNotificationFieldNumber = 26;
  inline const ::zaoxun::AntiCollisionNotification& anticollision_notification() const;
  inline ::zaoxun::AntiCollisionNotification* mutable_anticollision_notification();
  inline ::zaoxun::AntiCollisionNotification* release_anticollision_notification();
  inline void set_allocated_anticollision_notification(::zaoxun::AntiCollisionNotification* anticollision_notification);

  // optional .zaoxun.EDipperInfoNotification edipperinfo_notification = 27;
  inline bool has_edipperinfo_notification() const;
  inline void clear_edipperinfo_notification();
  static const int kEdipperinfoNotificationFieldNumber = 27;
  inline const ::zaoxun::EDipperInfoNotification& edipperinfo_notification() const;
  inline ::zaoxun::EDipperInfoNotification* mutable_edipperinfo_notification();
  inline ::zaoxun::EDipperInfoNotification* release_edipperinfo_notification();
  inline void set_allocated_edipperinfo_notification(::zaoxun::EDipperInfoNotification* edipperinfo_notification);

  // optional .zaoxun.GetEDippersRequest get_edippers_request = 28;
  inline bool has_get_edippers_request() const;
  inline void clear_get_edippers_request();
  static const int kGetEdippersRequestFieldNumber = 28;
  inline const ::zaoxun::GetEDippersRequest& get_edippers_request() const;
  inline ::zaoxun::GetEDippersRequest* mutable_get_edippers_request();
  inline ::zaoxun::GetEDippersRequest* release_get_edippers_request();
  inline void set_allocated_get_edippers_request(::zaoxun::GetEDippersRequest* get_edippers_request);

  // optional .zaoxun.GetEDippersResponse get_edippers_response = 29;
  inline bool has_get_edippers_response() const;
  inline void clear_get_edippers_response();
  static const int kGetEdippersResponseFieldNumber = 29;
  inline const ::zaoxun::GetEDippersResponse& get_edippers_response() const;
  inline ::zaoxun::GetEDippersResponse* mutable_get_edippers_response();
  inline ::zaoxun::GetEDippersResponse* release_get_edippers_response();
  inline void set_allocated_get_edippers_response(::zaoxun::GetEDippersResponse* get_edippers_response);

  // optional .zaoxun.LoadCompleteNotification load_complete_notification = 30;
  inline bool has_load_complete_notification() const;
  inline void clear_load_complete_notification();
  static const int kLoadCompleteNotificationFieldNumber = 30;
  inline const ::zaoxun::LoadCompleteNotification& load_complete_notification() const;
  inline ::zaoxun::LoadCompleteNotification* mutable_load_complete_notification();
  inline ::zaoxun::LoadCompleteNotification* release_load_complete_notification();
  inline void set_allocated_load_complete_notification(::zaoxun::LoadCompleteNotification* load_complete_notification);

  // optional .zaoxun.CancelLoadRequest cancel_load_request = 31;
  inline bool has_cancel_load_request() const;
  inline void clear_cancel_load_request();
  static const int kCancelLoadRequestFieldNumber = 31;
  inline const ::zaoxun::CancelLoadRequest& cancel_load_request() const;
  inline ::zaoxun::CancelLoadRequest* mutable_cancel_load_request();
  inline ::zaoxun::CancelLoadRequest* release_cancel_load_request();
  inline void set_allocated_cancel_load_request(::zaoxun::CancelLoadRequest* cancel_load_request);

  // optional .zaoxun.CancelLoadResponse cancel_load_response = 32;
  inline bool has_cancel_load_response() const;
  inline void clear_cancel_load_response();
  static const int kCancelLoadResponseFieldNumber = 32;
  inline const ::zaoxun::CancelLoadResponse& cancel_load_response() const;
  inline ::zaoxun::CancelLoadResponse* mutable_cancel_load_response();
  inline ::zaoxun::CancelLoadResponse* release_cancel_load_response();
  inline void set_allocated_cancel_load_response(::zaoxun::CancelLoadResponse* cancel_load_response);

  // optional .zaoxun.RejectLoadRequest reject_load_request = 33;
  inline bool has_reject_load_request() const;
  inline void clear_reject_load_request();
  static const int kRejectLoadRequestFieldNumber = 33;
  inline const ::zaoxun::RejectLoadRequest& reject_load_request() const;
  inline ::zaoxun::RejectLoadRequest* mutable_reject_load_request();
  inline ::zaoxun::RejectLoadRequest* release_reject_load_request();
  inline void set_allocated_reject_load_request(::zaoxun::RejectLoadRequest* reject_load_request);

  // optional .zaoxun.RejectLoadResponse reject_load_response = 34;
  inline bool has_reject_load_response() const;
  inline void clear_reject_load_response();
  static const int kRejectLoadResponseFieldNumber = 34;
  inline const ::zaoxun::RejectLoadResponse& reject_load_response() const;
  inline ::zaoxun::RejectLoadResponse* mutable_reject_load_response();
  inline ::zaoxun::RejectLoadResponse* release_reject_load_response();
  inline void set_allocated_reject_load_response(::zaoxun::RejectLoadResponse* reject_load_response);

  // optional .zaoxun.ExitNotification exit_notification = 35;
  inline bool has_exit_notification() const;
  inline void clear_exit_notification();
  static const int kExitNotificationFieldNumber = 35;
  inline const ::zaoxun::ExitNotification& exit_notification() const;
  inline ::zaoxun::ExitNotification* mutable_exit_notification();
  inline ::zaoxun::ExitNotification* release_exit_notification();
  inline void set_allocated_exit_notification(::zaoxun::ExitNotification* exit_notification);

  // optional .zaoxun.DeviceStatusChangeNotification device_status_change_notification = 36;
  inline bool has_device_status_change_notification() const;
  inline void clear_device_status_change_notification();
  static const int kDeviceStatusChangeNotificationFieldNumber = 36;
  inline const ::zaoxun::DeviceStatusChangeNotification& device_status_change_notification() const;
  inline ::zaoxun::DeviceStatusChangeNotification* mutable_device_status_change_notification();
  inline ::zaoxun::DeviceStatusChangeNotification* release_device_status_change_notification();
  inline void set_allocated_device_status_change_notification(::zaoxun::DeviceStatusChangeNotification* device_status_change_notification);

  // @@protoc_insertion_point(class_scope:zaoxun.CommonMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_login_request();
  inline void clear_has_login_request();
  inline void set_has_login_response();
  inline void clear_has_login_response();
  inline void set_has_check_request();
  inline void clear_has_check_request();
  inline void set_has_check_response();
  inline void clear_has_check_response();
  inline void set_has_oil_quantity_request();
  inline void clear_has_oil_quantity_request();
  inline void set_has_oil_quantity_response();
  inline void clear_has_oil_quantity_response();
  inline void set_has_production_request();
  inline void clear_has_production_request();
  inline void set_has_production_response();
  inline void clear_has_production_response();
  inline void set_has_distance_request();
  inline void clear_has_distance_request();
  inline void set_has_distance_response();
  inline void clear_has_distance_response();
  inline void set_has_times_request();
  inline void clear_has_times_request();
  inline void set_has_times_response();
  inline void clear_has_times_response();
  inline void set_has_oiling_request();
  inline void clear_has_oiling_request();
  inline void set_has_oiling_response();
  inline void clear_has_oiling_response();
  inline void set_has_load_request();
  inline void clear_has_load_request();
  inline void set_has_load_response();
  inline void clear_has_load_response();
  inline void set_has_unload_request();
  inline void clear_has_unload_request();
  inline void set_has_unload_response();
  inline void clear_has_unload_response();
  inline void set_has_speed_limit();
  inline void clear_has_speed_limit();
  inline void set_has_short_message();
  inline void clear_has_short_message();
  inline void set_has_gps_data();
  inline void clear_has_gps_data();
  inline void set_has_audio_file_data();
  inline void clear_has_audio_file_data();
  inline void set_has_capture_file_data();
  inline void clear_has_capture_file_data();
  inline void set_has_materials_notification();
  inline void clear_has_materials_notification();
  inline void set_has_anticollision_notification();
  inline void clear_has_anticollision_notification();
  inline void set_has_edipperinfo_notification();
  inline void clear_has_edipperinfo_notification();
  inline void set_has_get_edippers_request();
  inline void clear_has_get_edippers_request();
  inline void set_has_get_edippers_response();
  inline void clear_has_get_edippers_response();
  inline void set_has_load_complete_notification();
  inline void clear_has_load_complete_notification();
  inline void set_has_cancel_load_request();
  inline void clear_has_cancel_load_request();
  inline void set_has_cancel_load_response();
  inline void clear_has_cancel_load_response();
  inline void set_has_reject_load_request();
  inline void clear_has_reject_load_request();
  inline void set_has_reject_load_response();
  inline void clear_has_reject_load_response();
  inline void set_has_exit_notification();
  inline void clear_has_exit_notification();
  inline void set_has_device_status_change_notification();
  inline void clear_has_device_status_change_notification();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::zaoxun::LoginRequest* login_request_;
  ::zaoxun::LoginResponse* login_response_;
  ::zaoxun::CheckRequest* check_request_;
  ::zaoxun::CheckResponse* check_response_;
  ::zaoxun::OilQuantityRequest* oil_quantity_request_;
  ::zaoxun::OilQuantityResponse* oil_quantity_response_;
  ::zaoxun::ProductionRequest* production_request_;
  ::zaoxun::ProductionResponse* production_response_;
  ::zaoxun::DistanceRequest* distance_request_;
  ::zaoxun::DistanceResponse* distance_response_;
  ::zaoxun::TimesRequest* times_request_;
  ::zaoxun::TimesResponse* times_response_;
  ::zaoxun::OilingRequest* oiling_request_;
  ::zaoxun::OilingResponse* oiling_response_;
  ::zaoxun::LoadRequest* load_request_;
  ::zaoxun::LoadResponse* load_response_;
  ::zaoxun::UnloadRequest* unload_request_;
  ::zaoxun::UnloadResponse* unload_response_;
  ::zaoxun::SpeedLimitMessage* speed_limit_;
  ::zaoxun::ShortMessage* short_message_;
  ::zaoxun::GPSData* gps_data_;
  ::zaoxun::AudioFileData* audio_file_data_;
  ::zaoxun::CaptureFileData* capture_file_data_;
  ::zaoxun::MaterialsNotification* materials_notification_;
  ::zaoxun::AntiCollisionNotification* anticollision_notification_;
  ::zaoxun::EDipperInfoNotification* edipperinfo_notification_;
  ::zaoxun::GetEDippersRequest* get_edippers_request_;
  ::zaoxun::GetEDippersResponse* get_edippers_response_;
  ::zaoxun::LoadCompleteNotification* load_complete_notification_;
  ::zaoxun::CancelLoadRequest* cancel_load_request_;
  ::zaoxun::CancelLoadResponse* cancel_load_response_;
  ::zaoxun::RejectLoadRequest* reject_load_request_;
  ::zaoxun::RejectLoadResponse* reject_load_response_;
  ::zaoxun::ExitNotification* exit_notification_;
  ::zaoxun::DeviceStatusChangeNotification* device_status_change_notification_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(36 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CommonMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// optional string device_id = 1;
inline bool LoginRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& LoginRequest::device_id() const {
  return *device_id_;
}
inline void LoginRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoginRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoginRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* LoginRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginResponse

// optional string device_id = 1;
inline bool LoginResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& LoginResponse::device_id() const {
  return *device_id_;
}
inline void LoginResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoginResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoginResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* LoginResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 2;
inline bool LoginResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoginResponse::result() const {
  return result_;
}
inline void LoginResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .zaoxun.CarType type = 3;
inline bool LoginResponse::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::zaoxun::CarType LoginResponse::type() const {
  return static_cast< ::zaoxun::CarType >(type_);
}
inline void LoginResponse::set_type(::zaoxun::CarType value) {
  assert(::zaoxun::CarType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string car_no = 4;
inline bool LoginResponse::has_car_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponse::set_has_car_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResponse::clear_has_car_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResponse::clear_car_no() {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    car_no_->clear();
  }
  clear_has_car_no();
}
inline const ::std::string& LoginResponse::car_no() const {
  return *car_no_;
}
inline void LoginResponse::set_car_no(const ::std::string& value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void LoginResponse::set_car_no(const char* value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void LoginResponse::set_car_no(const char* value, size_t size) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_car_no() {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  return car_no_;
}
inline ::std::string* LoginResponse::release_car_no() {
  clear_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_no_;
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_car_no(::std::string* car_no) {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    delete car_no_;
  }
  if (car_no) {
    set_has_car_no();
    car_no_ = car_no;
  } else {
    clear_has_car_no();
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .zaoxun.RunningStatus run_status = 5;
inline bool LoginResponse::has_run_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResponse::set_has_run_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResponse::clear_has_run_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResponse::clear_run_status() {
  run_status_ = 1;
  clear_has_run_status();
}
inline ::zaoxun::RunningStatus LoginResponse::run_status() const {
  return static_cast< ::zaoxun::RunningStatus >(run_status_);
}
inline void LoginResponse::set_run_status(::zaoxun::RunningStatus value) {
  assert(::zaoxun::RunningStatus_IsValid(value));
  set_has_run_status();
  run_status_ = value;
}

// -------------------------------------------------------------------

// CheckRequest

// optional string device_id = 1;
inline bool CheckRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CheckRequest::device_id() const {
  return *device_id_;
}
inline void CheckRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CheckRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CheckRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CheckRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CheckResponse

// optional string device_id = 1;
inline bool CheckResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CheckResponse::device_id() const {
  return *device_id_;
}
inline void CheckResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CheckResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CheckResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CheckResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 status = 2;
inline bool CheckResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 CheckResponse::status() const {
  return status_;
}
inline void CheckResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// OilQuantityRequest

// optional string device_id = 1;
inline bool OilQuantityRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OilQuantityRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OilQuantityRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OilQuantityRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& OilQuantityRequest::device_id() const {
  return *device_id_;
}
inline void OilQuantityRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilQuantityRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilQuantityRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilQuantityRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* OilQuantityRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilQuantityRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OilQuantityResponse

// optional string device_id = 1;
inline bool OilQuantityResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OilQuantityResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OilQuantityResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OilQuantityResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& OilQuantityResponse::device_id() const {
  return *device_id_;
}
inline void OilQuantityResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilQuantityResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilQuantityResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilQuantityResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* OilQuantityResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilQuantityResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double quantity = 3;
inline bool OilQuantityResponse::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OilQuantityResponse::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OilQuantityResponse::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OilQuantityResponse::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double OilQuantityResponse::quantity() const {
  return quantity_;
}
inline void OilQuantityResponse::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
}

// -------------------------------------------------------------------

// ProductionRequest

// optional string device_id = 1;
inline bool ProductionRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductionRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductionRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductionRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ProductionRequest::device_id() const {
  return *device_id_;
}
inline void ProductionRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductionRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ProductionRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProductionRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool ProductionRequest::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductionRequest::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductionRequest::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductionRequest::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 ProductionRequest::period() const {
  return period_;
}
inline void ProductionRequest::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// -------------------------------------------------------------------

// ProductionResponse

// optional string device_id = 1;
inline bool ProductionResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductionResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductionResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductionResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ProductionResponse::device_id() const {
  return *device_id_;
}
inline void ProductionResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductionResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ProductionResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProductionResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool ProductionResponse::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductionResponse::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductionResponse::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductionResponse::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 ProductionResponse::period() const {
  return period_;
}
inline void ProductionResponse::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// optional double quantity = 3;
inline bool ProductionResponse::has_quantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProductionResponse::set_has_quantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProductionResponse::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProductionResponse::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double ProductionResponse::quantity() const {
  return quantity_;
}
inline void ProductionResponse::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
}

// -------------------------------------------------------------------

// DistanceRequest

// optional string device_id = 1;
inline bool DistanceRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DistanceRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DistanceRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DistanceRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& DistanceRequest::device_id() const {
  return *device_id_;
}
inline void DistanceRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DistanceRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DistanceRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DistanceRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* DistanceRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DistanceRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool DistanceRequest::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DistanceRequest::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DistanceRequest::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DistanceRequest::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 DistanceRequest::period() const {
  return period_;
}
inline void DistanceRequest::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// -------------------------------------------------------------------

// DistanceResponse

// optional string device_id = 1;
inline bool DistanceResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DistanceResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DistanceResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DistanceResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& DistanceResponse::device_id() const {
  return *device_id_;
}
inline void DistanceResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DistanceResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DistanceResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DistanceResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* DistanceResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DistanceResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool DistanceResponse::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DistanceResponse::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DistanceResponse::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DistanceResponse::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 DistanceResponse::period() const {
  return period_;
}
inline void DistanceResponse::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// optional double distance = 3;
inline bool DistanceResponse::has_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DistanceResponse::set_has_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DistanceResponse::clear_has_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DistanceResponse::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline double DistanceResponse::distance() const {
  return distance_;
}
inline void DistanceResponse::set_distance(double value) {
  set_has_distance();
  distance_ = value;
}

// -------------------------------------------------------------------

// TimesRequest

// optional string device_id = 1;
inline bool TimesRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimesRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimesRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimesRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& TimesRequest::device_id() const {
  return *device_id_;
}
inline void TimesRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void TimesRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void TimesRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimesRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* TimesRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimesRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool TimesRequest::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimesRequest::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimesRequest::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimesRequest::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 TimesRequest::period() const {
  return period_;
}
inline void TimesRequest::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// -------------------------------------------------------------------

// TimesResponse

// optional string device_id = 1;
inline bool TimesResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimesResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimesResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimesResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& TimesResponse::device_id() const {
  return *device_id_;
}
inline void TimesResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void TimesResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void TimesResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimesResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* TimesResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimesResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool TimesResponse::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimesResponse::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimesResponse::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimesResponse::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 TimesResponse::period() const {
  return period_;
}
inline void TimesResponse::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// optional int32 times = 3;
inline bool TimesResponse::has_times() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimesResponse::set_has_times() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimesResponse::clear_has_times() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimesResponse::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 TimesResponse::times() const {
  return times_;
}
inline void TimesResponse::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// -------------------------------------------------------------------

// OilingRequest

// optional string device_id = 1;
inline bool OilingRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OilingRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OilingRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OilingRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& OilingRequest::device_id() const {
  return *device_id_;
}
inline void OilingRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilingRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilingRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilingRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* OilingRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilingRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target = 2;
inline bool OilingRequest::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OilingRequest::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OilingRequest::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OilingRequest::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& OilingRequest::target() const {
  return *target_;
}
inline void OilingRequest::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void OilingRequest::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void OilingRequest::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilingRequest::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* OilingRequest::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilingRequest::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double volume = 3;
inline bool OilingRequest::has_volume() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OilingRequest::set_has_volume() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OilingRequest::clear_has_volume() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OilingRequest::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double OilingRequest::volume() const {
  return volume_;
}
inline void OilingRequest::set_volume(double value) {
  set_has_volume();
  volume_ = value;
}

// -------------------------------------------------------------------

// OilingResponse

// optional string device_id = 1;
inline bool OilingResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OilingResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OilingResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OilingResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& OilingResponse::device_id() const {
  return *device_id_;
}
inline void OilingResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilingResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilingResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilingResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* OilingResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilingResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target = 2;
inline bool OilingResponse::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OilingResponse::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OilingResponse::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OilingResponse::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& OilingResponse::target() const {
  return *target_;
}
inline void OilingResponse::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void OilingResponse::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void OilingResponse::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilingResponse::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* OilingResponse::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilingResponse::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double volume = 3;
inline bool OilingResponse::has_volume() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OilingResponse::set_has_volume() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OilingResponse::clear_has_volume() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OilingResponse::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double OilingResponse::volume() const {
  return volume_;
}
inline void OilingResponse::set_volume(double value) {
  set_has_volume();
  volume_ = value;
}

// optional int32 result = 4;
inline bool OilingResponse::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OilingResponse::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OilingResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OilingResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 OilingResponse::result() const {
  return result_;
}
inline void OilingResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// LoadRequest

// optional string device_id = 1;
inline bool LoadRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& LoadRequest::device_id() const {
  return *device_id_;
}
inline void LoadRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoadRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoadRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* LoadRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool LoadRequest::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadRequest::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadRequest::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadRequest::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& LoadRequest::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void LoadRequest::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadRequest::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadRequest::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadRequest::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* LoadRequest::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadRequest::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_no = 3;
inline bool LoadRequest::has_car_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadRequest::set_has_car_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadRequest::clear_has_car_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadRequest::clear_car_no() {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    car_no_->clear();
  }
  clear_has_car_no();
}
inline const ::std::string& LoadRequest::car_no() const {
  return *car_no_;
}
inline void LoadRequest::set_car_no(const ::std::string& value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void LoadRequest::set_car_no(const char* value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void LoadRequest::set_car_no(const char* value, size_t size) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadRequest::mutable_car_no() {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  return car_no_;
}
inline ::std::string* LoadRequest::release_car_no() {
  clear_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_no_;
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadRequest::set_allocated_car_no(::std::string* car_no) {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    delete car_no_;
  }
  if (car_no) {
    set_has_car_no();
    car_no_ = car_no;
  } else {
    clear_has_car_no();
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoadResponse

// optional string device_id = 1;
inline bool LoadResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& LoadResponse::device_id() const {
  return *device_id_;
}
inline void LoadResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoadResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoadResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* LoadResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool LoadResponse::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadResponse::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadResponse::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadResponse::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& LoadResponse::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void LoadResponse::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadResponse::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadResponse::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadResponse::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* LoadResponse::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadResponse::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 material_id = 3;
inline bool LoadResponse::has_material_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadResponse::set_has_material_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadResponse::clear_has_material_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadResponse::clear_material_id() {
  material_id_ = 0;
  clear_has_material_id();
}
inline ::google::protobuf::int32 LoadResponse::material_id() const {
  return material_id_;
}
inline void LoadResponse::set_material_id(::google::protobuf::int32 value) {
  set_has_material_id();
  material_id_ = value;
}

// optional int32 result = 4;
inline bool LoadResponse::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoadResponse::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoadResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoadResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoadResponse::result() const {
  return result_;
}
inline void LoadResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// UnloadRequest

// optional string device_id = 1;
inline bool UnloadRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnloadRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnloadRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnloadRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& UnloadRequest::device_id() const {
  return *device_id_;
}
inline void UnloadRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void UnloadRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void UnloadRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnloadRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* UnloadRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnloadRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool UnloadRequest::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnloadRequest::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnloadRequest::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnloadRequest::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& UnloadRequest::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void UnloadRequest::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void UnloadRequest::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void UnloadRequest::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnloadRequest::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* UnloadRequest::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnloadRequest::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UnloadResponse

// optional string device_id = 1;
inline bool UnloadResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnloadResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnloadResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnloadResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& UnloadResponse::device_id() const {
  return *device_id_;
}
inline void UnloadResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void UnloadResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void UnloadResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnloadResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* UnloadResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnloadResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 2;
inline bool UnloadResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnloadResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnloadResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnloadResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UnloadResponse::result() const {
  return result_;
}
inline void UnloadResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SpeedLimitMessage

// optional string device_id = 1;
inline bool SpeedLimitMessage::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeedLimitMessage::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeedLimitMessage::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeedLimitMessage::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& SpeedLimitMessage::device_id() const {
  return *device_id_;
}
inline void SpeedLimitMessage::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void SpeedLimitMessage::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void SpeedLimitMessage::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeedLimitMessage::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* SpeedLimitMessage::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeedLimitMessage::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double speed = 2;
inline bool SpeedLimitMessage::has_speed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeedLimitMessage::set_has_speed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeedLimitMessage::clear_has_speed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeedLimitMessage::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double SpeedLimitMessage::speed() const {
  return speed_;
}
inline void SpeedLimitMessage::set_speed(double value) {
  set_has_speed();
  speed_ = value;
}

// -------------------------------------------------------------------

// ShortMessage

// optional string device_id = 1;
inline bool ShortMessage::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShortMessage::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShortMessage::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShortMessage::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ShortMessage::device_id() const {
  return *device_id_;
}
inline void ShortMessage::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ShortMessage::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ShortMessage::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShortMessage::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ShortMessage::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ShortMessage::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dest_device = 2;
inline bool ShortMessage::has_dest_device() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShortMessage::set_has_dest_device() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShortMessage::clear_has_dest_device() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShortMessage::clear_dest_device() {
  if (dest_device_ != &::google::protobuf::internal::kEmptyString) {
    dest_device_->clear();
  }
  clear_has_dest_device();
}
inline const ::std::string& ShortMessage::dest_device() const {
  return *dest_device_;
}
inline void ShortMessage::set_dest_device(const ::std::string& value) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(value);
}
inline void ShortMessage::set_dest_device(const char* value) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(value);
}
inline void ShortMessage::set_dest_device(const char* value, size_t size) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShortMessage::mutable_dest_device() {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  return dest_device_;
}
inline ::std::string* ShortMessage::release_dest_device() {
  clear_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dest_device_;
    dest_device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ShortMessage::set_allocated_dest_device(::std::string* dest_device) {
  if (dest_device_ != &::google::protobuf::internal::kEmptyString) {
    delete dest_device_;
  }
  if (dest_device) {
    set_has_dest_device();
    dest_device_ = dest_device;
  } else {
    clear_has_dest_device();
    dest_device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 3;
inline bool ShortMessage::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShortMessage::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShortMessage::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShortMessage::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& ShortMessage::content() const {
  return *content_;
}
inline void ShortMessage::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ShortMessage::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ShortMessage::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShortMessage::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* ShortMessage::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ShortMessage::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GPSData

// optional string device_id = 1;
inline bool GPSData::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSData::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSData::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSData::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& GPSData::device_id() const {
  return *device_id_;
}
inline void GPSData::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GPSData::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GPSData::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* GPSData::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 2;
inline bool GPSData::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPSData::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPSData::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPSData::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& GPSData::time() const {
  return *time_;
}
inline void GPSData::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void GPSData::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void GPSData::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* GPSData::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string latitude = 3;
inline bool GPSData::has_latitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPSData::set_has_latitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPSData::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPSData::clear_latitude() {
  if (latitude_ != &::google::protobuf::internal::kEmptyString) {
    latitude_->clear();
  }
  clear_has_latitude();
}
inline const ::std::string& GPSData::latitude() const {
  return *latitude_;
}
inline void GPSData::set_latitude(const ::std::string& value) {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::kEmptyString) {
    latitude_ = new ::std::string;
  }
  latitude_->assign(value);
}
inline void GPSData::set_latitude(const char* value) {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::kEmptyString) {
    latitude_ = new ::std::string;
  }
  latitude_->assign(value);
}
inline void GPSData::set_latitude(const char* value, size_t size) {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::kEmptyString) {
    latitude_ = new ::std::string;
  }
  latitude_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_latitude() {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::kEmptyString) {
    latitude_ = new ::std::string;
  }
  return latitude_;
}
inline ::std::string* GPSData::release_latitude() {
  clear_has_latitude();
  if (latitude_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = latitude_;
    latitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_latitude(::std::string* latitude) {
  if (latitude_ != &::google::protobuf::internal::kEmptyString) {
    delete latitude_;
  }
  if (latitude) {
    set_has_latitude();
    latitude_ = latitude;
  } else {
    clear_has_latitude();
    latitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string longitude = 4;
inline bool GPSData::has_longitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPSData::set_has_longitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPSData::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPSData::clear_longitude() {
  if (longitude_ != &::google::protobuf::internal::kEmptyString) {
    longitude_->clear();
  }
  clear_has_longitude();
}
inline const ::std::string& GPSData::longitude() const {
  return *longitude_;
}
inline void GPSData::set_longitude(const ::std::string& value) {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::kEmptyString) {
    longitude_ = new ::std::string;
  }
  longitude_->assign(value);
}
inline void GPSData::set_longitude(const char* value) {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::kEmptyString) {
    longitude_ = new ::std::string;
  }
  longitude_->assign(value);
}
inline void GPSData::set_longitude(const char* value, size_t size) {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::kEmptyString) {
    longitude_ = new ::std::string;
  }
  longitude_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_longitude() {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::kEmptyString) {
    longitude_ = new ::std::string;
  }
  return longitude_;
}
inline ::std::string* GPSData::release_longitude() {
  clear_has_longitude();
  if (longitude_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = longitude_;
    longitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_longitude(::std::string* longitude) {
  if (longitude_ != &::google::protobuf::internal::kEmptyString) {
    delete longitude_;
  }
  if (longitude) {
    set_has_longitude();
    longitude_ = longitude;
  } else {
    clear_has_longitude();
    longitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string speed = 5;
inline bool GPSData::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPSData::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPSData::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPSData::clear_speed() {
  if (speed_ != &::google::protobuf::internal::kEmptyString) {
    speed_->clear();
  }
  clear_has_speed();
}
inline const ::std::string& GPSData::speed() const {
  return *speed_;
}
inline void GPSData::set_speed(const ::std::string& value) {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::kEmptyString) {
    speed_ = new ::std::string;
  }
  speed_->assign(value);
}
inline void GPSData::set_speed(const char* value) {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::kEmptyString) {
    speed_ = new ::std::string;
  }
  speed_->assign(value);
}
inline void GPSData::set_speed(const char* value, size_t size) {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::kEmptyString) {
    speed_ = new ::std::string;
  }
  speed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_speed() {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::kEmptyString) {
    speed_ = new ::std::string;
  }
  return speed_;
}
inline ::std::string* GPSData::release_speed() {
  clear_has_speed();
  if (speed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = speed_;
    speed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_speed(::std::string* speed) {
  if (speed_ != &::google::protobuf::internal::kEmptyString) {
    delete speed_;
  }
  if (speed) {
    set_has_speed();
    speed_ = speed;
  } else {
    clear_has_speed();
    speed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string elevation = 6;
inline bool GPSData::has_elevation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GPSData::set_has_elevation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GPSData::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GPSData::clear_elevation() {
  if (elevation_ != &::google::protobuf::internal::kEmptyString) {
    elevation_->clear();
  }
  clear_has_elevation();
}
inline const ::std::string& GPSData::elevation() const {
  return *elevation_;
}
inline void GPSData::set_elevation(const ::std::string& value) {
  set_has_elevation();
  if (elevation_ == &::google::protobuf::internal::kEmptyString) {
    elevation_ = new ::std::string;
  }
  elevation_->assign(value);
}
inline void GPSData::set_elevation(const char* value) {
  set_has_elevation();
  if (elevation_ == &::google::protobuf::internal::kEmptyString) {
    elevation_ = new ::std::string;
  }
  elevation_->assign(value);
}
inline void GPSData::set_elevation(const char* value, size_t size) {
  set_has_elevation();
  if (elevation_ == &::google::protobuf::internal::kEmptyString) {
    elevation_ = new ::std::string;
  }
  elevation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_elevation() {
  set_has_elevation();
  if (elevation_ == &::google::protobuf::internal::kEmptyString) {
    elevation_ = new ::std::string;
  }
  return elevation_;
}
inline ::std::string* GPSData::release_elevation() {
  clear_has_elevation();
  if (elevation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = elevation_;
    elevation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_elevation(::std::string* elevation) {
  if (elevation_ != &::google::protobuf::internal::kEmptyString) {
    delete elevation_;
  }
  if (elevation) {
    set_has_elevation();
    elevation_ = elevation;
  } else {
    clear_has_elevation();
    elevation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string direction = 7;
inline bool GPSData::has_direction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GPSData::set_has_direction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GPSData::clear_has_direction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GPSData::clear_direction() {
  if (direction_ != &::google::protobuf::internal::kEmptyString) {
    direction_->clear();
  }
  clear_has_direction();
}
inline const ::std::string& GPSData::direction() const {
  return *direction_;
}
inline void GPSData::set_direction(const ::std::string& value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void GPSData::set_direction(const char* value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void GPSData::set_direction(const char* value, size_t size) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_direction() {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  return direction_;
}
inline ::std::string* GPSData::release_direction() {
  clear_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = direction_;
    direction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_direction(::std::string* direction) {
  if (direction_ != &::google::protobuf::internal::kEmptyString) {
    delete direction_;
  }
  if (direction) {
    set_has_direction();
    direction_ = direction;
  } else {
    clear_has_direction();
    direction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string radius = 8;
inline bool GPSData::has_radius() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GPSData::set_has_radius() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GPSData::clear_has_radius() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GPSData::clear_radius() {
  if (radius_ != &::google::protobuf::internal::kEmptyString) {
    radius_->clear();
  }
  clear_has_radius();
}
inline const ::std::string& GPSData::radius() const {
  return *radius_;
}
inline void GPSData::set_radius(const ::std::string& value) {
  set_has_radius();
  if (radius_ == &::google::protobuf::internal::kEmptyString) {
    radius_ = new ::std::string;
  }
  radius_->assign(value);
}
inline void GPSData::set_radius(const char* value) {
  set_has_radius();
  if (radius_ == &::google::protobuf::internal::kEmptyString) {
    radius_ = new ::std::string;
  }
  radius_->assign(value);
}
inline void GPSData::set_radius(const char* value, size_t size) {
  set_has_radius();
  if (radius_ == &::google::protobuf::internal::kEmptyString) {
    radius_ = new ::std::string;
  }
  radius_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_radius() {
  set_has_radius();
  if (radius_ == &::google::protobuf::internal::kEmptyString) {
    radius_ = new ::std::string;
  }
  return radius_;
}
inline ::std::string* GPSData::release_radius() {
  clear_has_radius();
  if (radius_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = radius_;
    radius_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_radius(::std::string* radius) {
  if (radius_ != &::google::protobuf::internal::kEmptyString) {
    delete radius_;
  }
  if (radius) {
    set_has_radius();
    radius_ = radius;
  } else {
    clear_has_radius();
    radius_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string loctype = 9;
inline bool GPSData::has_loctype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GPSData::set_has_loctype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GPSData::clear_has_loctype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GPSData::clear_loctype() {
  if (loctype_ != &::google::protobuf::internal::kEmptyString) {
    loctype_->clear();
  }
  clear_has_loctype();
}
inline const ::std::string& GPSData::loctype() const {
  return *loctype_;
}
inline void GPSData::set_loctype(const ::std::string& value) {
  set_has_loctype();
  if (loctype_ == &::google::protobuf::internal::kEmptyString) {
    loctype_ = new ::std::string;
  }
  loctype_->assign(value);
}
inline void GPSData::set_loctype(const char* value) {
  set_has_loctype();
  if (loctype_ == &::google::protobuf::internal::kEmptyString) {
    loctype_ = new ::std::string;
  }
  loctype_->assign(value);
}
inline void GPSData::set_loctype(const char* value, size_t size) {
  set_has_loctype();
  if (loctype_ == &::google::protobuf::internal::kEmptyString) {
    loctype_ = new ::std::string;
  }
  loctype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_loctype() {
  set_has_loctype();
  if (loctype_ == &::google::protobuf::internal::kEmptyString) {
    loctype_ = new ::std::string;
  }
  return loctype_;
}
inline ::std::string* GPSData::release_loctype() {
  clear_has_loctype();
  if (loctype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loctype_;
    loctype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_loctype(::std::string* loctype) {
  if (loctype_ != &::google::protobuf::internal::kEmptyString) {
    delete loctype_;
  }
  if (loctype) {
    set_has_loctype();
    loctype_ = loctype;
  } else {
    clear_has_loctype();
    loctype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string addrstr = 10;
inline bool GPSData::has_addrstr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GPSData::set_has_addrstr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GPSData::clear_has_addrstr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GPSData::clear_addrstr() {
  if (addrstr_ != &::google::protobuf::internal::kEmptyString) {
    addrstr_->clear();
  }
  clear_has_addrstr();
}
inline const ::std::string& GPSData::addrstr() const {
  return *addrstr_;
}
inline void GPSData::set_addrstr(const ::std::string& value) {
  set_has_addrstr();
  if (addrstr_ == &::google::protobuf::internal::kEmptyString) {
    addrstr_ = new ::std::string;
  }
  addrstr_->assign(value);
}
inline void GPSData::set_addrstr(const char* value) {
  set_has_addrstr();
  if (addrstr_ == &::google::protobuf::internal::kEmptyString) {
    addrstr_ = new ::std::string;
  }
  addrstr_->assign(value);
}
inline void GPSData::set_addrstr(const char* value, size_t size) {
  set_has_addrstr();
  if (addrstr_ == &::google::protobuf::internal::kEmptyString) {
    addrstr_ = new ::std::string;
  }
  addrstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_addrstr() {
  set_has_addrstr();
  if (addrstr_ == &::google::protobuf::internal::kEmptyString) {
    addrstr_ = new ::std::string;
  }
  return addrstr_;
}
inline ::std::string* GPSData::release_addrstr() {
  clear_has_addrstr();
  if (addrstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addrstr_;
    addrstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_addrstr(::std::string* addrstr) {
  if (addrstr_ != &::google::protobuf::internal::kEmptyString) {
    delete addrstr_;
  }
  if (addrstr) {
    set_has_addrstr();
    addrstr_ = addrstr;
  } else {
    clear_has_addrstr();
    addrstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string province = 11;
inline bool GPSData::has_province() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GPSData::set_has_province() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GPSData::clear_has_province() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GPSData::clear_province() {
  if (province_ != &::google::protobuf::internal::kEmptyString) {
    province_->clear();
  }
  clear_has_province();
}
inline const ::std::string& GPSData::province() const {
  return *province_;
}
inline void GPSData::set_province(const ::std::string& value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(value);
}
inline void GPSData::set_province(const char* value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(value);
}
inline void GPSData::set_province(const char* value, size_t size) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_province() {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  return province_;
}
inline ::std::string* GPSData::release_province() {
  clear_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = province_;
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_province(::std::string* province) {
  if (province_ != &::google::protobuf::internal::kEmptyString) {
    delete province_;
  }
  if (province) {
    set_has_province();
    province_ = province;
  } else {
    clear_has_province();
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city = 12;
inline bool GPSData::has_city() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GPSData::set_has_city() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GPSData::clear_has_city() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GPSData::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& GPSData::city() const {
  return *city_;
}
inline void GPSData::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void GPSData::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void GPSData::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* GPSData::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string district = 13;
inline bool GPSData::has_district() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GPSData::set_has_district() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GPSData::clear_has_district() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GPSData::clear_district() {
  if (district_ != &::google::protobuf::internal::kEmptyString) {
    district_->clear();
  }
  clear_has_district();
}
inline const ::std::string& GPSData::district() const {
  return *district_;
}
inline void GPSData::set_district(const ::std::string& value) {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  district_->assign(value);
}
inline void GPSData::set_district(const char* value) {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  district_->assign(value);
}
inline void GPSData::set_district(const char* value, size_t size) {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  district_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_district() {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  return district_;
}
inline ::std::string* GPSData::release_district() {
  clear_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = district_;
    district_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_district(::std::string* district) {
  if (district_ != &::google::protobuf::internal::kEmptyString) {
    delete district_;
  }
  if (district) {
    set_has_district();
    district_ = district;
  } else {
    clear_has_district();
    district_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string poi = 14;
inline bool GPSData::has_poi() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GPSData::set_has_poi() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GPSData::clear_has_poi() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GPSData::clear_poi() {
  if (poi_ != &::google::protobuf::internal::kEmptyString) {
    poi_->clear();
  }
  clear_has_poi();
}
inline const ::std::string& GPSData::poi() const {
  return *poi_;
}
inline void GPSData::set_poi(const ::std::string& value) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(value);
}
inline void GPSData::set_poi(const char* value) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(value);
}
inline void GPSData::set_poi(const char* value, size_t size) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_poi() {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  return poi_;
}
inline ::std::string* GPSData::release_poi() {
  clear_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = poi_;
    poi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_poi(::std::string* poi) {
  if (poi_ != &::google::protobuf::internal::kEmptyString) {
    delete poi_;
  }
  if (poi) {
    set_has_poi();
    poi_ = poi;
  } else {
    clear_has_poi();
    poi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AudioFileData

// optional string device_id = 1;
inline bool AudioFileData::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioFileData::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioFileData::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioFileData::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& AudioFileData::device_id() const {
  return *device_id_;
}
inline void AudioFileData::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void AudioFileData::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void AudioFileData::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioFileData::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* AudioFileData::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioFileData::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 2;
inline bool AudioFileData::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioFileData::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioFileData::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioFileData::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& AudioFileData::time() const {
  return *time_;
}
inline void AudioFileData::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void AudioFileData::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void AudioFileData::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioFileData::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* AudioFileData::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioFileData::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string file_name = 3;
inline bool AudioFileData::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioFileData::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioFileData::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioFileData::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& AudioFileData::file_name() const {
  return *file_name_;
}
inline void AudioFileData::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void AudioFileData::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void AudioFileData::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioFileData::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* AudioFileData::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioFileData::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dest_device = 4;
inline bool AudioFileData::has_dest_device() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioFileData::set_has_dest_device() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioFileData::clear_has_dest_device() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioFileData::clear_dest_device() {
  if (dest_device_ != &::google::protobuf::internal::kEmptyString) {
    dest_device_->clear();
  }
  clear_has_dest_device();
}
inline const ::std::string& AudioFileData::dest_device() const {
  return *dest_device_;
}
inline void AudioFileData::set_dest_device(const ::std::string& value) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(value);
}
inline void AudioFileData::set_dest_device(const char* value) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(value);
}
inline void AudioFileData::set_dest_device(const char* value, size_t size) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioFileData::mutable_dest_device() {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  return dest_device_;
}
inline ::std::string* AudioFileData::release_dest_device() {
  clear_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dest_device_;
    dest_device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioFileData::set_allocated_dest_device(::std::string* dest_device) {
  if (dest_device_ != &::google::protobuf::internal::kEmptyString) {
    delete dest_device_;
  }
  if (dest_device) {
    set_has_dest_device();
    dest_device_ = dest_device;
  } else {
    clear_has_dest_device();
    dest_device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 total_packets = 5;
inline bool AudioFileData::has_total_packets() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AudioFileData::set_has_total_packets() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AudioFileData::clear_has_total_packets() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AudioFileData::clear_total_packets() {
  total_packets_ = 0;
  clear_has_total_packets();
}
inline ::google::protobuf::int32 AudioFileData::total_packets() const {
  return total_packets_;
}
inline void AudioFileData::set_total_packets(::google::protobuf::int32 value) {
  set_has_total_packets();
  total_packets_ = value;
}

// optional int32 current_packet = 6;
inline bool AudioFileData::has_current_packet() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AudioFileData::set_has_current_packet() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AudioFileData::clear_has_current_packet() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AudioFileData::clear_current_packet() {
  current_packet_ = 0;
  clear_has_current_packet();
}
inline ::google::protobuf::int32 AudioFileData::current_packet() const {
  return current_packet_;
}
inline void AudioFileData::set_current_packet(::google::protobuf::int32 value) {
  set_has_current_packet();
  current_packet_ = value;
}

// optional int32 data_len = 7;
inline bool AudioFileData::has_data_len() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AudioFileData::set_has_data_len() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AudioFileData::clear_has_data_len() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AudioFileData::clear_data_len() {
  data_len_ = 0;
  clear_has_data_len();
}
inline ::google::protobuf::int32 AudioFileData::data_len() const {
  return data_len_;
}
inline void AudioFileData::set_data_len(::google::protobuf::int32 value) {
  set_has_data_len();
  data_len_ = value;
}

// optional bytes data = 8;
inline bool AudioFileData::has_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AudioFileData::set_has_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AudioFileData::clear_has_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AudioFileData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& AudioFileData::data() const {
  return *data_;
}
inline void AudioFileData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AudioFileData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AudioFileData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioFileData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* AudioFileData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioFileData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CaptureFileData

// optional string device_id = 1;
inline bool CaptureFileData::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaptureFileData::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaptureFileData::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaptureFileData::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CaptureFileData::device_id() const {
  return *device_id_;
}
inline void CaptureFileData::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CaptureFileData::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CaptureFileData::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaptureFileData::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CaptureFileData::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaptureFileData::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 2;
inline bool CaptureFileData::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaptureFileData::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaptureFileData::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaptureFileData::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& CaptureFileData::time() const {
  return *time_;
}
inline void CaptureFileData::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void CaptureFileData::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void CaptureFileData::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaptureFileData::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* CaptureFileData::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaptureFileData::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string file_name = 3;
inline bool CaptureFileData::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaptureFileData::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaptureFileData::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaptureFileData::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CaptureFileData::file_name() const {
  return *file_name_;
}
inline void CaptureFileData::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CaptureFileData::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CaptureFileData::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaptureFileData::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CaptureFileData::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaptureFileData::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 total_packets = 4;
inline bool CaptureFileData::has_total_packets() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CaptureFileData::set_has_total_packets() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CaptureFileData::clear_has_total_packets() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CaptureFileData::clear_total_packets() {
  total_packets_ = 0;
  clear_has_total_packets();
}
inline ::google::protobuf::int32 CaptureFileData::total_packets() const {
  return total_packets_;
}
inline void CaptureFileData::set_total_packets(::google::protobuf::int32 value) {
  set_has_total_packets();
  total_packets_ = value;
}

// optional int32 current_packet = 5;
inline bool CaptureFileData::has_current_packet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CaptureFileData::set_has_current_packet() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CaptureFileData::clear_has_current_packet() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CaptureFileData::clear_current_packet() {
  current_packet_ = 0;
  clear_has_current_packet();
}
inline ::google::protobuf::int32 CaptureFileData::current_packet() const {
  return current_packet_;
}
inline void CaptureFileData::set_current_packet(::google::protobuf::int32 value) {
  set_has_current_packet();
  current_packet_ = value;
}

// optional int32 data_len = 6;
inline bool CaptureFileData::has_data_len() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CaptureFileData::set_has_data_len() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CaptureFileData::clear_has_data_len() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CaptureFileData::clear_data_len() {
  data_len_ = 0;
  clear_has_data_len();
}
inline ::google::protobuf::int32 CaptureFileData::data_len() const {
  return data_len_;
}
inline void CaptureFileData::set_data_len(::google::protobuf::int32 value) {
  set_has_data_len();
  data_len_ = value;
}

// optional bytes data = 7;
inline bool CaptureFileData::has_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CaptureFileData::set_has_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CaptureFileData::clear_has_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CaptureFileData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CaptureFileData::data() const {
  return *data_;
}
inline void CaptureFileData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CaptureFileData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CaptureFileData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaptureFileData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CaptureFileData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaptureFileData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Material

// optional int32 material_id = 1;
inline bool Material::has_material_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Material::set_has_material_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Material::clear_has_material_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Material::clear_material_id() {
  material_id_ = 0;
  clear_has_material_id();
}
inline ::google::protobuf::int32 Material::material_id() const {
  return material_id_;
}
inline void Material::set_material_id(::google::protobuf::int32 value) {
  set_has_material_id();
  material_id_ = value;
}

// optional string english_name = 2;
inline bool Material::has_english_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Material::set_has_english_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Material::clear_has_english_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Material::clear_english_name() {
  if (english_name_ != &::google::protobuf::internal::kEmptyString) {
    english_name_->clear();
  }
  clear_has_english_name();
}
inline const ::std::string& Material::english_name() const {
  return *english_name_;
}
inline void Material::set_english_name(const ::std::string& value) {
  set_has_english_name();
  if (english_name_ == &::google::protobuf::internal::kEmptyString) {
    english_name_ = new ::std::string;
  }
  english_name_->assign(value);
}
inline void Material::set_english_name(const char* value) {
  set_has_english_name();
  if (english_name_ == &::google::protobuf::internal::kEmptyString) {
    english_name_ = new ::std::string;
  }
  english_name_->assign(value);
}
inline void Material::set_english_name(const char* value, size_t size) {
  set_has_english_name();
  if (english_name_ == &::google::protobuf::internal::kEmptyString) {
    english_name_ = new ::std::string;
  }
  english_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Material::mutable_english_name() {
  set_has_english_name();
  if (english_name_ == &::google::protobuf::internal::kEmptyString) {
    english_name_ = new ::std::string;
  }
  return english_name_;
}
inline ::std::string* Material::release_english_name() {
  clear_has_english_name();
  if (english_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = english_name_;
    english_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Material::set_allocated_english_name(::std::string* english_name) {
  if (english_name_ != &::google::protobuf::internal::kEmptyString) {
    delete english_name_;
  }
  if (english_name) {
    set_has_english_name();
    english_name_ = english_name;
  } else {
    clear_has_english_name();
    english_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string chinese_name = 3;
inline bool Material::has_chinese_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Material::set_has_chinese_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Material::clear_has_chinese_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Material::clear_chinese_name() {
  if (chinese_name_ != &::google::protobuf::internal::kEmptyString) {
    chinese_name_->clear();
  }
  clear_has_chinese_name();
}
inline const ::std::string& Material::chinese_name() const {
  return *chinese_name_;
}
inline void Material::set_chinese_name(const ::std::string& value) {
  set_has_chinese_name();
  if (chinese_name_ == &::google::protobuf::internal::kEmptyString) {
    chinese_name_ = new ::std::string;
  }
  chinese_name_->assign(value);
}
inline void Material::set_chinese_name(const char* value) {
  set_has_chinese_name();
  if (chinese_name_ == &::google::protobuf::internal::kEmptyString) {
    chinese_name_ = new ::std::string;
  }
  chinese_name_->assign(value);
}
inline void Material::set_chinese_name(const char* value, size_t size) {
  set_has_chinese_name();
  if (chinese_name_ == &::google::protobuf::internal::kEmptyString) {
    chinese_name_ = new ::std::string;
  }
  chinese_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Material::mutable_chinese_name() {
  set_has_chinese_name();
  if (chinese_name_ == &::google::protobuf::internal::kEmptyString) {
    chinese_name_ = new ::std::string;
  }
  return chinese_name_;
}
inline ::std::string* Material::release_chinese_name() {
  clear_has_chinese_name();
  if (chinese_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chinese_name_;
    chinese_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Material::set_allocated_chinese_name(::std::string* chinese_name) {
  if (chinese_name_ != &::google::protobuf::internal::kEmptyString) {
    delete chinese_name_;
  }
  if (chinese_name) {
    set_has_chinese_name();
    chinese_name_ = chinese_name;
  } else {
    clear_has_chinese_name();
    chinese_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MaterialsNotification

// repeated .zaoxun.Material material = 1;
inline int MaterialsNotification::material_size() const {
  return material_.size();
}
inline void MaterialsNotification::clear_material() {
  material_.Clear();
}
inline const ::zaoxun::Material& MaterialsNotification::material(int index) const {
  return material_.Get(index);
}
inline ::zaoxun::Material* MaterialsNotification::mutable_material(int index) {
  return material_.Mutable(index);
}
inline ::zaoxun::Material* MaterialsNotification::add_material() {
  return material_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >&
MaterialsNotification::material() const {
  return material_;
}
inline ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >*
MaterialsNotification::mutable_material() {
  return &material_;
}

// -------------------------------------------------------------------

// CollisionCarInfo

// optional string device_id = 1;
inline bool CollisionCarInfo::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionCarInfo::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionCarInfo::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionCarInfo::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CollisionCarInfo::device_id() const {
  return *device_id_;
}
inline void CollisionCarInfo::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CollisionCarInfo::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CollisionCarInfo::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollisionCarInfo::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CollisionCarInfo::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CollisionCarInfo::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .zaoxun.CarType type = 2;
inline bool CollisionCarInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollisionCarInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollisionCarInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollisionCarInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::zaoxun::CarType CollisionCarInfo::type() const {
  return static_cast< ::zaoxun::CarType >(type_);
}
inline void CollisionCarInfo::set_type(::zaoxun::CarType value) {
  assert(::zaoxun::CarType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string car_no = 3;
inline bool CollisionCarInfo::has_car_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollisionCarInfo::set_has_car_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollisionCarInfo::clear_has_car_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollisionCarInfo::clear_car_no() {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    car_no_->clear();
  }
  clear_has_car_no();
}
inline const ::std::string& CollisionCarInfo::car_no() const {
  return *car_no_;
}
inline void CollisionCarInfo::set_car_no(const ::std::string& value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void CollisionCarInfo::set_car_no(const char* value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void CollisionCarInfo::set_car_no(const char* value, size_t size) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollisionCarInfo::mutable_car_no() {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  return car_no_;
}
inline ::std::string* CollisionCarInfo::release_car_no() {
  clear_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_no_;
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CollisionCarInfo::set_allocated_car_no(::std::string* car_no) {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    delete car_no_;
  }
  if (car_no) {
    set_has_car_no();
    car_no_ = car_no;
  } else {
    clear_has_car_no();
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 4;
inline bool CollisionCarInfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CollisionCarInfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CollisionCarInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CollisionCarInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 CollisionCarInfo::level() const {
  return level_;
}
inline void CollisionCarInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional double distance = 5;
inline bool CollisionCarInfo::has_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CollisionCarInfo::set_has_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CollisionCarInfo::clear_has_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CollisionCarInfo::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline double CollisionCarInfo::distance() const {
  return distance_;
}
inline void CollisionCarInfo::set_distance(double value) {
  set_has_distance();
  distance_ = value;
}

// optional double longitude = 6;
inline bool CollisionCarInfo::has_longitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CollisionCarInfo::set_has_longitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CollisionCarInfo::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CollisionCarInfo::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double CollisionCarInfo::longitude() const {
  return longitude_;
}
inline void CollisionCarInfo::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double latitude = 7;
inline bool CollisionCarInfo::has_latitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CollisionCarInfo::set_has_latitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CollisionCarInfo::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CollisionCarInfo::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double CollisionCarInfo::latitude() const {
  return latitude_;
}
inline void CollisionCarInfo::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// -------------------------------------------------------------------

// AntiCollisionNotification

// repeated double angle = 1;
inline int AntiCollisionNotification::angle_size() const {
  return angle_.size();
}
inline void AntiCollisionNotification::clear_angle() {
  angle_.Clear();
}
inline double AntiCollisionNotification::angle(int index) const {
  return angle_.Get(index);
}
inline void AntiCollisionNotification::set_angle(int index, double value) {
  angle_.Set(index, value);
}
inline void AntiCollisionNotification::add_angle(double value) {
  angle_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
AntiCollisionNotification::angle() const {
  return angle_;
}
inline ::google::protobuf::RepeatedField< double >*
AntiCollisionNotification::mutable_angle() {
  return &angle_;
}

// -------------------------------------------------------------------

// EDipperInfo

// optional string device_id = 1;
inline bool EDipperInfo::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EDipperInfo::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EDipperInfo::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EDipperInfo::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& EDipperInfo::device_id() const {
  return *device_id_;
}
inline void EDipperInfo::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void EDipperInfo::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void EDipperInfo::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EDipperInfo::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* EDipperInfo::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EDipperInfo::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_no = 2;
inline bool EDipperInfo::has_device_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EDipperInfo::set_has_device_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EDipperInfo::clear_has_device_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EDipperInfo::clear_device_no() {
  if (device_no_ != &::google::protobuf::internal::kEmptyString) {
    device_no_->clear();
  }
  clear_has_device_no();
}
inline const ::std::string& EDipperInfo::device_no() const {
  return *device_no_;
}
inline void EDipperInfo::set_device_no(const ::std::string& value) {
  set_has_device_no();
  if (device_no_ == &::google::protobuf::internal::kEmptyString) {
    device_no_ = new ::std::string;
  }
  device_no_->assign(value);
}
inline void EDipperInfo::set_device_no(const char* value) {
  set_has_device_no();
  if (device_no_ == &::google::protobuf::internal::kEmptyString) {
    device_no_ = new ::std::string;
  }
  device_no_->assign(value);
}
inline void EDipperInfo::set_device_no(const char* value, size_t size) {
  set_has_device_no();
  if (device_no_ == &::google::protobuf::internal::kEmptyString) {
    device_no_ = new ::std::string;
  }
  device_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EDipperInfo::mutable_device_no() {
  set_has_device_no();
  if (device_no_ == &::google::protobuf::internal::kEmptyString) {
    device_no_ = new ::std::string;
  }
  return device_no_;
}
inline ::std::string* EDipperInfo::release_device_no() {
  clear_has_device_no();
  if (device_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_no_;
    device_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EDipperInfo::set_allocated_device_no(::std::string* device_no) {
  if (device_no_ != &::google::protobuf::internal::kEmptyString) {
    delete device_no_;
  }
  if (device_no) {
    set_has_device_no();
    device_no_ = device_no;
  } else {
    clear_has_device_no();
    device_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double longitude = 3;
inline bool EDipperInfo::has_longitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EDipperInfo::set_has_longitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EDipperInfo::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EDipperInfo::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double EDipperInfo::longitude() const {
  return longitude_;
}
inline void EDipperInfo::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double latitude = 4;
inline bool EDipperInfo::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EDipperInfo::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EDipperInfo::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EDipperInfo::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double EDipperInfo::latitude() const {
  return latitude_;
}
inline void EDipperInfo::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// -------------------------------------------------------------------

// EDipperInfoNotification

// repeated .zaoxun.EDipperInfo infos = 1;
inline int EDipperInfoNotification::infos_size() const {
  return infos_.size();
}
inline void EDipperInfoNotification::clear_infos() {
  infos_.Clear();
}
inline const ::zaoxun::EDipperInfo& EDipperInfoNotification::infos(int index) const {
  return infos_.Get(index);
}
inline ::zaoxun::EDipperInfo* EDipperInfoNotification::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::zaoxun::EDipperInfo* EDipperInfoNotification::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >&
EDipperInfoNotification::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >*
EDipperInfoNotification::mutable_infos() {
  return &infos_;
}

// -------------------------------------------------------------------

// GetEDippersRequest

// optional string device_id = 1;
inline bool GetEDippersRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEDippersRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEDippersRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEDippersRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& GetEDippersRequest::device_id() const {
  return *device_id_;
}
inline void GetEDippersRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GetEDippersRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GetEDippersRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetEDippersRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* GetEDippersRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetEDippersRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetEDippersResponse

// optional string device_id = 1;
inline bool GetEDippersResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEDippersResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEDippersResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEDippersResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& GetEDippersResponse::device_id() const {
  return *device_id_;
}
inline void GetEDippersResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GetEDippersResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GetEDippersResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetEDippersResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* GetEDippersResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetEDippersResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .zaoxun.EDipperInfo edippers = 2;
inline int GetEDippersResponse::edippers_size() const {
  return edippers_.size();
}
inline void GetEDippersResponse::clear_edippers() {
  edippers_.Clear();
}
inline const ::zaoxun::EDipperInfo& GetEDippersResponse::edippers(int index) const {
  return edippers_.Get(index);
}
inline ::zaoxun::EDipperInfo* GetEDippersResponse::mutable_edippers(int index) {
  return edippers_.Mutable(index);
}
inline ::zaoxun::EDipperInfo* GetEDippersResponse::add_edippers() {
  return edippers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >&
GetEDippersResponse::edippers() const {
  return edippers_;
}
inline ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >*
GetEDippersResponse::mutable_edippers() {
  return &edippers_;
}

// -------------------------------------------------------------------

// LoadCompleteNotification

// optional string edipper_device_id = 1;
inline bool LoadCompleteNotification::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadCompleteNotification::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadCompleteNotification::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadCompleteNotification::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& LoadCompleteNotification::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void LoadCompleteNotification::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadCompleteNotification::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadCompleteNotification::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadCompleteNotification::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* LoadCompleteNotification::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadCompleteNotification::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_device_id = 2;
inline bool LoadCompleteNotification::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadCompleteNotification::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadCompleteNotification::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadCompleteNotification::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& LoadCompleteNotification::car_device_id() const {
  return *car_device_id_;
}
inline void LoadCompleteNotification::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void LoadCompleteNotification::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void LoadCompleteNotification::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadCompleteNotification::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* LoadCompleteNotification::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadCompleteNotification::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 load_result = 3;
inline bool LoadCompleteNotification::has_load_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadCompleteNotification::set_has_load_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadCompleteNotification::clear_has_load_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadCompleteNotification::clear_load_result() {
  load_result_ = 0;
  clear_has_load_result();
}
inline ::google::protobuf::int32 LoadCompleteNotification::load_result() const {
  return load_result_;
}
inline void LoadCompleteNotification::set_load_result(::google::protobuf::int32 value) {
  set_has_load_result();
  load_result_ = value;
}

// -------------------------------------------------------------------

// CancelLoadRequest

// optional string car_device_id = 1;
inline bool CancelLoadRequest::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelLoadRequest::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelLoadRequest::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelLoadRequest::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& CancelLoadRequest::car_device_id() const {
  return *car_device_id_;
}
inline void CancelLoadRequest::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void CancelLoadRequest::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void CancelLoadRequest::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelLoadRequest::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* CancelLoadRequest::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CancelLoadRequest::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool CancelLoadRequest::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelLoadRequest::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelLoadRequest::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelLoadRequest::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& CancelLoadRequest::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void CancelLoadRequest::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void CancelLoadRequest::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void CancelLoadRequest::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelLoadRequest::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* CancelLoadRequest::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CancelLoadRequest::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CancelLoadResponse

// optional string car_device_id = 1;
inline bool CancelLoadResponse::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelLoadResponse::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelLoadResponse::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelLoadResponse::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& CancelLoadResponse::car_device_id() const {
  return *car_device_id_;
}
inline void CancelLoadResponse::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void CancelLoadResponse::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void CancelLoadResponse::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelLoadResponse::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* CancelLoadResponse::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CancelLoadResponse::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool CancelLoadResponse::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelLoadResponse::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelLoadResponse::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelLoadResponse::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& CancelLoadResponse::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void CancelLoadResponse::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void CancelLoadResponse::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void CancelLoadResponse::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelLoadResponse::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* CancelLoadResponse::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CancelLoadResponse::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 3;
inline bool CancelLoadResponse::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CancelLoadResponse::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CancelLoadResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CancelLoadResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CancelLoadResponse::result() const {
  return result_;
}
inline void CancelLoadResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RejectLoadRequest

// optional string edipper_device_id = 1;
inline bool RejectLoadRequest::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectLoadRequest::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejectLoadRequest::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejectLoadRequest::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& RejectLoadRequest::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void RejectLoadRequest::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void RejectLoadRequest::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void RejectLoadRequest::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RejectLoadRequest::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* RejectLoadRequest::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RejectLoadRequest::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_device_id = 2;
inline bool RejectLoadRequest::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectLoadRequest::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejectLoadRequest::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejectLoadRequest::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& RejectLoadRequest::car_device_id() const {
  return *car_device_id_;
}
inline void RejectLoadRequest::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void RejectLoadRequest::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void RejectLoadRequest::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RejectLoadRequest::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* RejectLoadRequest::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RejectLoadRequest::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RejectLoadResponse

// optional string edipper_device_id = 1;
inline bool RejectLoadResponse::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectLoadResponse::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejectLoadResponse::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejectLoadResponse::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& RejectLoadResponse::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void RejectLoadResponse::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void RejectLoadResponse::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void RejectLoadResponse::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RejectLoadResponse::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* RejectLoadResponse::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RejectLoadResponse::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_device_id = 2;
inline bool RejectLoadResponse::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectLoadResponse::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejectLoadResponse::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejectLoadResponse::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& RejectLoadResponse::car_device_id() const {
  return *car_device_id_;
}
inline void RejectLoadResponse::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void RejectLoadResponse::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void RejectLoadResponse::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RejectLoadResponse::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* RejectLoadResponse::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RejectLoadResponse::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 3;
inline bool RejectLoadResponse::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RejectLoadResponse::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RejectLoadResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RejectLoadResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RejectLoadResponse::result() const {
  return result_;
}
inline void RejectLoadResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ExitNotification

// optional string device_id = 1;
inline bool ExitNotification::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitNotification::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitNotification::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitNotification::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ExitNotification::device_id() const {
  return *device_id_;
}
inline void ExitNotification::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ExitNotification::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ExitNotification::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExitNotification::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ExitNotification::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExitNotification::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exit_type = 2;
inline bool ExitNotification::has_exit_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExitNotification::set_has_exit_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExitNotification::clear_has_exit_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExitNotification::clear_exit_type() {
  exit_type_ = 0;
  clear_has_exit_type();
}
inline ::google::protobuf::int32 ExitNotification::exit_type() const {
  return exit_type_;
}
inline void ExitNotification::set_exit_type(::google::protobuf::int32 value) {
  set_has_exit_type();
  exit_type_ = value;
}

// -------------------------------------------------------------------

// DeviceStatusChangeNotification

// optional string device_id = 1;
inline bool DeviceStatusChangeNotification::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStatusChangeNotification::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceStatusChangeNotification::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceStatusChangeNotification::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& DeviceStatusChangeNotification::device_id() const {
  return *device_id_;
}
inline void DeviceStatusChangeNotification::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DeviceStatusChangeNotification::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DeviceStatusChangeNotification::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceStatusChangeNotification::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* DeviceStatusChangeNotification::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceStatusChangeNotification::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .zaoxun.RunningStatus status = 2;
inline bool DeviceStatusChangeNotification::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceStatusChangeNotification::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceStatusChangeNotification::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceStatusChangeNotification::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::zaoxun::RunningStatus DeviceStatusChangeNotification::status() const {
  return static_cast< ::zaoxun::RunningStatus >(status_);
}
inline void DeviceStatusChangeNotification::set_status(::zaoxun::RunningStatus value) {
  assert(::zaoxun::RunningStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional int32 type = 3;
inline bool DeviceStatusChangeNotification::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceStatusChangeNotification::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceStatusChangeNotification::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceStatusChangeNotification::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DeviceStatusChangeNotification::type() const {
  return type_;
}
inline void DeviceStatusChangeNotification::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CommonMessage

// optional .zaoxun.MessageType type = 1;
inline bool CommonMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::zaoxun::MessageType CommonMessage::type() const {
  return static_cast< ::zaoxun::MessageType >(type_);
}
inline void CommonMessage::set_type(::zaoxun::MessageType value) {
  assert(::zaoxun::MessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .zaoxun.LoginRequest login_request = 2;
inline bool CommonMessage::has_login_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonMessage::set_has_login_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonMessage::clear_has_login_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonMessage::clear_login_request() {
  if (login_request_ != NULL) login_request_->::zaoxun::LoginRequest::Clear();
  clear_has_login_request();
}
inline const ::zaoxun::LoginRequest& CommonMessage::login_request() const {
  return login_request_ != NULL ? *login_request_ : *default_instance_->login_request_;
}
inline ::zaoxun::LoginRequest* CommonMessage::mutable_login_request() {
  set_has_login_request();
  if (login_request_ == NULL) login_request_ = new ::zaoxun::LoginRequest;
  return login_request_;
}
inline ::zaoxun::LoginRequest* CommonMessage::release_login_request() {
  clear_has_login_request();
  ::zaoxun::LoginRequest* temp = login_request_;
  login_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_login_request(::zaoxun::LoginRequest* login_request) {
  delete login_request_;
  login_request_ = login_request;
  if (login_request) {
    set_has_login_request();
  } else {
    clear_has_login_request();
  }
}

// optional .zaoxun.LoginResponse login_response = 3;
inline bool CommonMessage::has_login_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonMessage::set_has_login_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonMessage::clear_has_login_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonMessage::clear_login_response() {
  if (login_response_ != NULL) login_response_->::zaoxun::LoginResponse::Clear();
  clear_has_login_response();
}
inline const ::zaoxun::LoginResponse& CommonMessage::login_response() const {
  return login_response_ != NULL ? *login_response_ : *default_instance_->login_response_;
}
inline ::zaoxun::LoginResponse* CommonMessage::mutable_login_response() {
  set_has_login_response();
  if (login_response_ == NULL) login_response_ = new ::zaoxun::LoginResponse;
  return login_response_;
}
inline ::zaoxun::LoginResponse* CommonMessage::release_login_response() {
  clear_has_login_response();
  ::zaoxun::LoginResponse* temp = login_response_;
  login_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_login_response(::zaoxun::LoginResponse* login_response) {
  delete login_response_;
  login_response_ = login_response;
  if (login_response) {
    set_has_login_response();
  } else {
    clear_has_login_response();
  }
}

// optional .zaoxun.CheckRequest check_request = 4;
inline bool CommonMessage::has_check_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonMessage::set_has_check_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonMessage::clear_has_check_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonMessage::clear_check_request() {
  if (check_request_ != NULL) check_request_->::zaoxun::CheckRequest::Clear();
  clear_has_check_request();
}
inline const ::zaoxun::CheckRequest& CommonMessage::check_request() const {
  return check_request_ != NULL ? *check_request_ : *default_instance_->check_request_;
}
inline ::zaoxun::CheckRequest* CommonMessage::mutable_check_request() {
  set_has_check_request();
  if (check_request_ == NULL) check_request_ = new ::zaoxun::CheckRequest;
  return check_request_;
}
inline ::zaoxun::CheckRequest* CommonMessage::release_check_request() {
  clear_has_check_request();
  ::zaoxun::CheckRequest* temp = check_request_;
  check_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_check_request(::zaoxun::CheckRequest* check_request) {
  delete check_request_;
  check_request_ = check_request;
  if (check_request) {
    set_has_check_request();
  } else {
    clear_has_check_request();
  }
}

// optional .zaoxun.CheckResponse check_response = 5;
inline bool CommonMessage::has_check_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonMessage::set_has_check_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonMessage::clear_has_check_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonMessage::clear_check_response() {
  if (check_response_ != NULL) check_response_->::zaoxun::CheckResponse::Clear();
  clear_has_check_response();
}
inline const ::zaoxun::CheckResponse& CommonMessage::check_response() const {
  return check_response_ != NULL ? *check_response_ : *default_instance_->check_response_;
}
inline ::zaoxun::CheckResponse* CommonMessage::mutable_check_response() {
  set_has_check_response();
  if (check_response_ == NULL) check_response_ = new ::zaoxun::CheckResponse;
  return check_response_;
}
inline ::zaoxun::CheckResponse* CommonMessage::release_check_response() {
  clear_has_check_response();
  ::zaoxun::CheckResponse* temp = check_response_;
  check_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_check_response(::zaoxun::CheckResponse* check_response) {
  delete check_response_;
  check_response_ = check_response;
  if (check_response) {
    set_has_check_response();
  } else {
    clear_has_check_response();
  }
}

// optional .zaoxun.OilQuantityRequest oil_quantity_request = 6;
inline bool CommonMessage::has_oil_quantity_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonMessage::set_has_oil_quantity_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonMessage::clear_has_oil_quantity_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonMessage::clear_oil_quantity_request() {
  if (oil_quantity_request_ != NULL) oil_quantity_request_->::zaoxun::OilQuantityRequest::Clear();
  clear_has_oil_quantity_request();
}
inline const ::zaoxun::OilQuantityRequest& CommonMessage::oil_quantity_request() const {
  return oil_quantity_request_ != NULL ? *oil_quantity_request_ : *default_instance_->oil_quantity_request_;
}
inline ::zaoxun::OilQuantityRequest* CommonMessage::mutable_oil_quantity_request() {
  set_has_oil_quantity_request();
  if (oil_quantity_request_ == NULL) oil_quantity_request_ = new ::zaoxun::OilQuantityRequest;
  return oil_quantity_request_;
}
inline ::zaoxun::OilQuantityRequest* CommonMessage::release_oil_quantity_request() {
  clear_has_oil_quantity_request();
  ::zaoxun::OilQuantityRequest* temp = oil_quantity_request_;
  oil_quantity_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_oil_quantity_request(::zaoxun::OilQuantityRequest* oil_quantity_request) {
  delete oil_quantity_request_;
  oil_quantity_request_ = oil_quantity_request;
  if (oil_quantity_request) {
    set_has_oil_quantity_request();
  } else {
    clear_has_oil_quantity_request();
  }
}

// optional .zaoxun.OilQuantityResponse oil_quantity_response = 7;
inline bool CommonMessage::has_oil_quantity_response() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommonMessage::set_has_oil_quantity_response() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommonMessage::clear_has_oil_quantity_response() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommonMessage::clear_oil_quantity_response() {
  if (oil_quantity_response_ != NULL) oil_quantity_response_->::zaoxun::OilQuantityResponse::Clear();
  clear_has_oil_quantity_response();
}
inline const ::zaoxun::OilQuantityResponse& CommonMessage::oil_quantity_response() const {
  return oil_quantity_response_ != NULL ? *oil_quantity_response_ : *default_instance_->oil_quantity_response_;
}
inline ::zaoxun::OilQuantityResponse* CommonMessage::mutable_oil_quantity_response() {
  set_has_oil_quantity_response();
  if (oil_quantity_response_ == NULL) oil_quantity_response_ = new ::zaoxun::OilQuantityResponse;
  return oil_quantity_response_;
}
inline ::zaoxun::OilQuantityResponse* CommonMessage::release_oil_quantity_response() {
  clear_has_oil_quantity_response();
  ::zaoxun::OilQuantityResponse* temp = oil_quantity_response_;
  oil_quantity_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_oil_quantity_response(::zaoxun::OilQuantityResponse* oil_quantity_response) {
  delete oil_quantity_response_;
  oil_quantity_response_ = oil_quantity_response;
  if (oil_quantity_response) {
    set_has_oil_quantity_response();
  } else {
    clear_has_oil_quantity_response();
  }
}

// optional .zaoxun.ProductionRequest production_request = 8;
inline bool CommonMessage::has_production_request() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommonMessage::set_has_production_request() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommonMessage::clear_has_production_request() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommonMessage::clear_production_request() {
  if (production_request_ != NULL) production_request_->::zaoxun::ProductionRequest::Clear();
  clear_has_production_request();
}
inline const ::zaoxun::ProductionRequest& CommonMessage::production_request() const {
  return production_request_ != NULL ? *production_request_ : *default_instance_->production_request_;
}
inline ::zaoxun::ProductionRequest* CommonMessage::mutable_production_request() {
  set_has_production_request();
  if (production_request_ == NULL) production_request_ = new ::zaoxun::ProductionRequest;
  return production_request_;
}
inline ::zaoxun::ProductionRequest* CommonMessage::release_production_request() {
  clear_has_production_request();
  ::zaoxun::ProductionRequest* temp = production_request_;
  production_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_production_request(::zaoxun::ProductionRequest* production_request) {
  delete production_request_;
  production_request_ = production_request;
  if (production_request) {
    set_has_production_request();
  } else {
    clear_has_production_request();
  }
}

// optional .zaoxun.ProductionResponse production_response = 9;
inline bool CommonMessage::has_production_response() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommonMessage::set_has_production_response() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommonMessage::clear_has_production_response() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommonMessage::clear_production_response() {
  if (production_response_ != NULL) production_response_->::zaoxun::ProductionResponse::Clear();
  clear_has_production_response();
}
inline const ::zaoxun::ProductionResponse& CommonMessage::production_response() const {
  return production_response_ != NULL ? *production_response_ : *default_instance_->production_response_;
}
inline ::zaoxun::ProductionResponse* CommonMessage::mutable_production_response() {
  set_has_production_response();
  if (production_response_ == NULL) production_response_ = new ::zaoxun::ProductionResponse;
  return production_response_;
}
inline ::zaoxun::ProductionResponse* CommonMessage::release_production_response() {
  clear_has_production_response();
  ::zaoxun::ProductionResponse* temp = production_response_;
  production_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_production_response(::zaoxun::ProductionResponse* production_response) {
  delete production_response_;
  production_response_ = production_response;
  if (production_response) {
    set_has_production_response();
  } else {
    clear_has_production_response();
  }
}

// optional .zaoxun.DistanceRequest distance_request = 10;
inline bool CommonMessage::has_distance_request() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommonMessage::set_has_distance_request() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommonMessage::clear_has_distance_request() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommonMessage::clear_distance_request() {
  if (distance_request_ != NULL) distance_request_->::zaoxun::DistanceRequest::Clear();
  clear_has_distance_request();
}
inline const ::zaoxun::DistanceRequest& CommonMessage::distance_request() const {
  return distance_request_ != NULL ? *distance_request_ : *default_instance_->distance_request_;
}
inline ::zaoxun::DistanceRequest* CommonMessage::mutable_distance_request() {
  set_has_distance_request();
  if (distance_request_ == NULL) distance_request_ = new ::zaoxun::DistanceRequest;
  return distance_request_;
}
inline ::zaoxun::DistanceRequest* CommonMessage::release_distance_request() {
  clear_has_distance_request();
  ::zaoxun::DistanceRequest* temp = distance_request_;
  distance_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_distance_request(::zaoxun::DistanceRequest* distance_request) {
  delete distance_request_;
  distance_request_ = distance_request;
  if (distance_request) {
    set_has_distance_request();
  } else {
    clear_has_distance_request();
  }
}

// optional .zaoxun.DistanceResponse distance_response = 11;
inline bool CommonMessage::has_distance_response() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommonMessage::set_has_distance_response() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommonMessage::clear_has_distance_response() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommonMessage::clear_distance_response() {
  if (distance_response_ != NULL) distance_response_->::zaoxun::DistanceResponse::Clear();
  clear_has_distance_response();
}
inline const ::zaoxun::DistanceResponse& CommonMessage::distance_response() const {
  return distance_response_ != NULL ? *distance_response_ : *default_instance_->distance_response_;
}
inline ::zaoxun::DistanceResponse* CommonMessage::mutable_distance_response() {
  set_has_distance_response();
  if (distance_response_ == NULL) distance_response_ = new ::zaoxun::DistanceResponse;
  return distance_response_;
}
inline ::zaoxun::DistanceResponse* CommonMessage::release_distance_response() {
  clear_has_distance_response();
  ::zaoxun::DistanceResponse* temp = distance_response_;
  distance_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_distance_response(::zaoxun::DistanceResponse* distance_response) {
  delete distance_response_;
  distance_response_ = distance_response;
  if (distance_response) {
    set_has_distance_response();
  } else {
    clear_has_distance_response();
  }
}

// optional .zaoxun.TimesRequest times_request = 12;
inline bool CommonMessage::has_times_request() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CommonMessage::set_has_times_request() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CommonMessage::clear_has_times_request() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CommonMessage::clear_times_request() {
  if (times_request_ != NULL) times_request_->::zaoxun::TimesRequest::Clear();
  clear_has_times_request();
}
inline const ::zaoxun::TimesRequest& CommonMessage::times_request() const {
  return times_request_ != NULL ? *times_request_ : *default_instance_->times_request_;
}
inline ::zaoxun::TimesRequest* CommonMessage::mutable_times_request() {
  set_has_times_request();
  if (times_request_ == NULL) times_request_ = new ::zaoxun::TimesRequest;
  return times_request_;
}
inline ::zaoxun::TimesRequest* CommonMessage::release_times_request() {
  clear_has_times_request();
  ::zaoxun::TimesRequest* temp = times_request_;
  times_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_times_request(::zaoxun::TimesRequest* times_request) {
  delete times_request_;
  times_request_ = times_request;
  if (times_request) {
    set_has_times_request();
  } else {
    clear_has_times_request();
  }
}

// optional .zaoxun.TimesResponse times_response = 13;
inline bool CommonMessage::has_times_response() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CommonMessage::set_has_times_response() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CommonMessage::clear_has_times_response() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CommonMessage::clear_times_response() {
  if (times_response_ != NULL) times_response_->::zaoxun::TimesResponse::Clear();
  clear_has_times_response();
}
inline const ::zaoxun::TimesResponse& CommonMessage::times_response() const {
  return times_response_ != NULL ? *times_response_ : *default_instance_->times_response_;
}
inline ::zaoxun::TimesResponse* CommonMessage::mutable_times_response() {
  set_has_times_response();
  if (times_response_ == NULL) times_response_ = new ::zaoxun::TimesResponse;
  return times_response_;
}
inline ::zaoxun::TimesResponse* CommonMessage::release_times_response() {
  clear_has_times_response();
  ::zaoxun::TimesResponse* temp = times_response_;
  times_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_times_response(::zaoxun::TimesResponse* times_response) {
  delete times_response_;
  times_response_ = times_response;
  if (times_response) {
    set_has_times_response();
  } else {
    clear_has_times_response();
  }
}

// optional .zaoxun.OilingRequest oiling_request = 14;
inline bool CommonMessage::has_oiling_request() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CommonMessage::set_has_oiling_request() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CommonMessage::clear_has_oiling_request() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CommonMessage::clear_oiling_request() {
  if (oiling_request_ != NULL) oiling_request_->::zaoxun::OilingRequest::Clear();
  clear_has_oiling_request();
}
inline const ::zaoxun::OilingRequest& CommonMessage::oiling_request() const {
  return oiling_request_ != NULL ? *oiling_request_ : *default_instance_->oiling_request_;
}
inline ::zaoxun::OilingRequest* CommonMessage::mutable_oiling_request() {
  set_has_oiling_request();
  if (oiling_request_ == NULL) oiling_request_ = new ::zaoxun::OilingRequest;
  return oiling_request_;
}
inline ::zaoxun::OilingRequest* CommonMessage::release_oiling_request() {
  clear_has_oiling_request();
  ::zaoxun::OilingRequest* temp = oiling_request_;
  oiling_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_oiling_request(::zaoxun::OilingRequest* oiling_request) {
  delete oiling_request_;
  oiling_request_ = oiling_request;
  if (oiling_request) {
    set_has_oiling_request();
  } else {
    clear_has_oiling_request();
  }
}

// optional .zaoxun.OilingResponse oiling_response = 15;
inline bool CommonMessage::has_oiling_response() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CommonMessage::set_has_oiling_response() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CommonMessage::clear_has_oiling_response() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CommonMessage::clear_oiling_response() {
  if (oiling_response_ != NULL) oiling_response_->::zaoxun::OilingResponse::Clear();
  clear_has_oiling_response();
}
inline const ::zaoxun::OilingResponse& CommonMessage::oiling_response() const {
  return oiling_response_ != NULL ? *oiling_response_ : *default_instance_->oiling_response_;
}
inline ::zaoxun::OilingResponse* CommonMessage::mutable_oiling_response() {
  set_has_oiling_response();
  if (oiling_response_ == NULL) oiling_response_ = new ::zaoxun::OilingResponse;
  return oiling_response_;
}
inline ::zaoxun::OilingResponse* CommonMessage::release_oiling_response() {
  clear_has_oiling_response();
  ::zaoxun::OilingResponse* temp = oiling_response_;
  oiling_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_oiling_response(::zaoxun::OilingResponse* oiling_response) {
  delete oiling_response_;
  oiling_response_ = oiling_response;
  if (oiling_response) {
    set_has_oiling_response();
  } else {
    clear_has_oiling_response();
  }
}

// optional .zaoxun.LoadRequest load_request = 16;
inline bool CommonMessage::has_load_request() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CommonMessage::set_has_load_request() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CommonMessage::clear_has_load_request() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CommonMessage::clear_load_request() {
  if (load_request_ != NULL) load_request_->::zaoxun::LoadRequest::Clear();
  clear_has_load_request();
}
inline const ::zaoxun::LoadRequest& CommonMessage::load_request() const {
  return load_request_ != NULL ? *load_request_ : *default_instance_->load_request_;
}
inline ::zaoxun::LoadRequest* CommonMessage::mutable_load_request() {
  set_has_load_request();
  if (load_request_ == NULL) load_request_ = new ::zaoxun::LoadRequest;
  return load_request_;
}
inline ::zaoxun::LoadRequest* CommonMessage::release_load_request() {
  clear_has_load_request();
  ::zaoxun::LoadRequest* temp = load_request_;
  load_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_load_request(::zaoxun::LoadRequest* load_request) {
  delete load_request_;
  load_request_ = load_request;
  if (load_request) {
    set_has_load_request();
  } else {
    clear_has_load_request();
  }
}

// optional .zaoxun.LoadResponse load_response = 17;
inline bool CommonMessage::has_load_response() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CommonMessage::set_has_load_response() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CommonMessage::clear_has_load_response() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CommonMessage::clear_load_response() {
  if (load_response_ != NULL) load_response_->::zaoxun::LoadResponse::Clear();
  clear_has_load_response();
}
inline const ::zaoxun::LoadResponse& CommonMessage::load_response() const {
  return load_response_ != NULL ? *load_response_ : *default_instance_->load_response_;
}
inline ::zaoxun::LoadResponse* CommonMessage::mutable_load_response() {
  set_has_load_response();
  if (load_response_ == NULL) load_response_ = new ::zaoxun::LoadResponse;
  return load_response_;
}
inline ::zaoxun::LoadResponse* CommonMessage::release_load_response() {
  clear_has_load_response();
  ::zaoxun::LoadResponse* temp = load_response_;
  load_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_load_response(::zaoxun::LoadResponse* load_response) {
  delete load_response_;
  load_response_ = load_response;
  if (load_response) {
    set_has_load_response();
  } else {
    clear_has_load_response();
  }
}

// optional .zaoxun.UnloadRequest unload_request = 18;
inline bool CommonMessage::has_unload_request() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CommonMessage::set_has_unload_request() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CommonMessage::clear_has_unload_request() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CommonMessage::clear_unload_request() {
  if (unload_request_ != NULL) unload_request_->::zaoxun::UnloadRequest::Clear();
  clear_has_unload_request();
}
inline const ::zaoxun::UnloadRequest& CommonMessage::unload_request() const {
  return unload_request_ != NULL ? *unload_request_ : *default_instance_->unload_request_;
}
inline ::zaoxun::UnloadRequest* CommonMessage::mutable_unload_request() {
  set_has_unload_request();
  if (unload_request_ == NULL) unload_request_ = new ::zaoxun::UnloadRequest;
  return unload_request_;
}
inline ::zaoxun::UnloadRequest* CommonMessage::release_unload_request() {
  clear_has_unload_request();
  ::zaoxun::UnloadRequest* temp = unload_request_;
  unload_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_unload_request(::zaoxun::UnloadRequest* unload_request) {
  delete unload_request_;
  unload_request_ = unload_request;
  if (unload_request) {
    set_has_unload_request();
  } else {
    clear_has_unload_request();
  }
}

// optional .zaoxun.UnloadResponse unload_response = 19;
inline bool CommonMessage::has_unload_response() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CommonMessage::set_has_unload_response() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CommonMessage::clear_has_unload_response() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CommonMessage::clear_unload_response() {
  if (unload_response_ != NULL) unload_response_->::zaoxun::UnloadResponse::Clear();
  clear_has_unload_response();
}
inline const ::zaoxun::UnloadResponse& CommonMessage::unload_response() const {
  return unload_response_ != NULL ? *unload_response_ : *default_instance_->unload_response_;
}
inline ::zaoxun::UnloadResponse* CommonMessage::mutable_unload_response() {
  set_has_unload_response();
  if (unload_response_ == NULL) unload_response_ = new ::zaoxun::UnloadResponse;
  return unload_response_;
}
inline ::zaoxun::UnloadResponse* CommonMessage::release_unload_response() {
  clear_has_unload_response();
  ::zaoxun::UnloadResponse* temp = unload_response_;
  unload_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_unload_response(::zaoxun::UnloadResponse* unload_response) {
  delete unload_response_;
  unload_response_ = unload_response;
  if (unload_response) {
    set_has_unload_response();
  } else {
    clear_has_unload_response();
  }
}

// optional .zaoxun.SpeedLimitMessage speed_limit = 20;
inline bool CommonMessage::has_speed_limit() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CommonMessage::set_has_speed_limit() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CommonMessage::clear_has_speed_limit() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CommonMessage::clear_speed_limit() {
  if (speed_limit_ != NULL) speed_limit_->::zaoxun::SpeedLimitMessage::Clear();
  clear_has_speed_limit();
}
inline const ::zaoxun::SpeedLimitMessage& CommonMessage::speed_limit() const {
  return speed_limit_ != NULL ? *speed_limit_ : *default_instance_->speed_limit_;
}
inline ::zaoxun::SpeedLimitMessage* CommonMessage::mutable_speed_limit() {
  set_has_speed_limit();
  if (speed_limit_ == NULL) speed_limit_ = new ::zaoxun::SpeedLimitMessage;
  return speed_limit_;
}
inline ::zaoxun::SpeedLimitMessage* CommonMessage::release_speed_limit() {
  clear_has_speed_limit();
  ::zaoxun::SpeedLimitMessage* temp = speed_limit_;
  speed_limit_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_speed_limit(::zaoxun::SpeedLimitMessage* speed_limit) {
  delete speed_limit_;
  speed_limit_ = speed_limit;
  if (speed_limit) {
    set_has_speed_limit();
  } else {
    clear_has_speed_limit();
  }
}

// optional .zaoxun.ShortMessage short_message = 21;
inline bool CommonMessage::has_short_message() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CommonMessage::set_has_short_message() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CommonMessage::clear_has_short_message() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CommonMessage::clear_short_message() {
  if (short_message_ != NULL) short_message_->::zaoxun::ShortMessage::Clear();
  clear_has_short_message();
}
inline const ::zaoxun::ShortMessage& CommonMessage::short_message() const {
  return short_message_ != NULL ? *short_message_ : *default_instance_->short_message_;
}
inline ::zaoxun::ShortMessage* CommonMessage::mutable_short_message() {
  set_has_short_message();
  if (short_message_ == NULL) short_message_ = new ::zaoxun::ShortMessage;
  return short_message_;
}
inline ::zaoxun::ShortMessage* CommonMessage::release_short_message() {
  clear_has_short_message();
  ::zaoxun::ShortMessage* temp = short_message_;
  short_message_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_short_message(::zaoxun::ShortMessage* short_message) {
  delete short_message_;
  short_message_ = short_message;
  if (short_message) {
    set_has_short_message();
  } else {
    clear_has_short_message();
  }
}

// optional .zaoxun.GPSData gps_data = 22;
inline bool CommonMessage::has_gps_data() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CommonMessage::set_has_gps_data() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CommonMessage::clear_has_gps_data() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CommonMessage::clear_gps_data() {
  if (gps_data_ != NULL) gps_data_->::zaoxun::GPSData::Clear();
  clear_has_gps_data();
}
inline const ::zaoxun::GPSData& CommonMessage::gps_data() const {
  return gps_data_ != NULL ? *gps_data_ : *default_instance_->gps_data_;
}
inline ::zaoxun::GPSData* CommonMessage::mutable_gps_data() {
  set_has_gps_data();
  if (gps_data_ == NULL) gps_data_ = new ::zaoxun::GPSData;
  return gps_data_;
}
inline ::zaoxun::GPSData* CommonMessage::release_gps_data() {
  clear_has_gps_data();
  ::zaoxun::GPSData* temp = gps_data_;
  gps_data_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_gps_data(::zaoxun::GPSData* gps_data) {
  delete gps_data_;
  gps_data_ = gps_data;
  if (gps_data) {
    set_has_gps_data();
  } else {
    clear_has_gps_data();
  }
}

// optional .zaoxun.AudioFileData audio_file_data = 23;
inline bool CommonMessage::has_audio_file_data() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CommonMessage::set_has_audio_file_data() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CommonMessage::clear_has_audio_file_data() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CommonMessage::clear_audio_file_data() {
  if (audio_file_data_ != NULL) audio_file_data_->::zaoxun::AudioFileData::Clear();
  clear_has_audio_file_data();
}
inline const ::zaoxun::AudioFileData& CommonMessage::audio_file_data() const {
  return audio_file_data_ != NULL ? *audio_file_data_ : *default_instance_->audio_file_data_;
}
inline ::zaoxun::AudioFileData* CommonMessage::mutable_audio_file_data() {
  set_has_audio_file_data();
  if (audio_file_data_ == NULL) audio_file_data_ = new ::zaoxun::AudioFileData;
  return audio_file_data_;
}
inline ::zaoxun::AudioFileData* CommonMessage::release_audio_file_data() {
  clear_has_audio_file_data();
  ::zaoxun::AudioFileData* temp = audio_file_data_;
  audio_file_data_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_audio_file_data(::zaoxun::AudioFileData* audio_file_data) {
  delete audio_file_data_;
  audio_file_data_ = audio_file_data;
  if (audio_file_data) {
    set_has_audio_file_data();
  } else {
    clear_has_audio_file_data();
  }
}

// optional .zaoxun.CaptureFileData capture_file_data = 24;
inline bool CommonMessage::has_capture_file_data() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CommonMessage::set_has_capture_file_data() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CommonMessage::clear_has_capture_file_data() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CommonMessage::clear_capture_file_data() {
  if (capture_file_data_ != NULL) capture_file_data_->::zaoxun::CaptureFileData::Clear();
  clear_has_capture_file_data();
}
inline const ::zaoxun::CaptureFileData& CommonMessage::capture_file_data() const {
  return capture_file_data_ != NULL ? *capture_file_data_ : *default_instance_->capture_file_data_;
}
inline ::zaoxun::CaptureFileData* CommonMessage::mutable_capture_file_data() {
  set_has_capture_file_data();
  if (capture_file_data_ == NULL) capture_file_data_ = new ::zaoxun::CaptureFileData;
  return capture_file_data_;
}
inline ::zaoxun::CaptureFileData* CommonMessage::release_capture_file_data() {
  clear_has_capture_file_data();
  ::zaoxun::CaptureFileData* temp = capture_file_data_;
  capture_file_data_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_capture_file_data(::zaoxun::CaptureFileData* capture_file_data) {
  delete capture_file_data_;
  capture_file_data_ = capture_file_data;
  if (capture_file_data) {
    set_has_capture_file_data();
  } else {
    clear_has_capture_file_data();
  }
}

// optional .zaoxun.MaterialsNotification materials_notification = 25;
inline bool CommonMessage::has_materials_notification() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CommonMessage::set_has_materials_notification() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CommonMessage::clear_has_materials_notification() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CommonMessage::clear_materials_notification() {
  if (materials_notification_ != NULL) materials_notification_->::zaoxun::MaterialsNotification::Clear();
  clear_has_materials_notification();
}
inline const ::zaoxun::MaterialsNotification& CommonMessage::materials_notification() const {
  return materials_notification_ != NULL ? *materials_notification_ : *default_instance_->materials_notification_;
}
inline ::zaoxun::MaterialsNotification* CommonMessage::mutable_materials_notification() {
  set_has_materials_notification();
  if (materials_notification_ == NULL) materials_notification_ = new ::zaoxun::MaterialsNotification;
  return materials_notification_;
}
inline ::zaoxun::MaterialsNotification* CommonMessage::release_materials_notification() {
  clear_has_materials_notification();
  ::zaoxun::MaterialsNotification* temp = materials_notification_;
  materials_notification_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_materials_notification(::zaoxun::MaterialsNotification* materials_notification) {
  delete materials_notification_;
  materials_notification_ = materials_notification;
  if (materials_notification) {
    set_has_materials_notification();
  } else {
    clear_has_materials_notification();
  }
}

// optional .zaoxun.AntiCollisionNotification anticollision_notification = 26;
inline bool CommonMessage::has_anticollision_notification() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CommonMessage::set_has_anticollision_notification() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CommonMessage::clear_has_anticollision_notification() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CommonMessage::clear_anticollision_notification() {
  if (anticollision_notification_ != NULL) anticollision_notification_->::zaoxun::AntiCollisionNotification::Clear();
  clear_has_anticollision_notification();
}
inline const ::zaoxun::AntiCollisionNotification& CommonMessage::anticollision_notification() const {
  return anticollision_notification_ != NULL ? *anticollision_notification_ : *default_instance_->anticollision_notification_;
}
inline ::zaoxun::AntiCollisionNotification* CommonMessage::mutable_anticollision_notification() {
  set_has_anticollision_notification();
  if (anticollision_notification_ == NULL) anticollision_notification_ = new ::zaoxun::AntiCollisionNotification;
  return anticollision_notification_;
}
inline ::zaoxun::AntiCollisionNotification* CommonMessage::release_anticollision_notification() {
  clear_has_anticollision_notification();
  ::zaoxun::AntiCollisionNotification* temp = anticollision_notification_;
  anticollision_notification_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_anticollision_notification(::zaoxun::AntiCollisionNotification* anticollision_notification) {
  delete anticollision_notification_;
  anticollision_notification_ = anticollision_notification;
  if (anticollision_notification) {
    set_has_anticollision_notification();
  } else {
    clear_has_anticollision_notification();
  }
}

// optional .zaoxun.EDipperInfoNotification edipperinfo_notification = 27;
inline bool CommonMessage::has_edipperinfo_notification() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CommonMessage::set_has_edipperinfo_notification() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CommonMessage::clear_has_edipperinfo_notification() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CommonMessage::clear_edipperinfo_notification() {
  if (edipperinfo_notification_ != NULL) edipperinfo_notification_->::zaoxun::EDipperInfoNotification::Clear();
  clear_has_edipperinfo_notification();
}
inline const ::zaoxun::EDipperInfoNotification& CommonMessage::edipperinfo_notification() const {
  return edipperinfo_notification_ != NULL ? *edipperinfo_notification_ : *default_instance_->edipperinfo_notification_;
}
inline ::zaoxun::EDipperInfoNotification* CommonMessage::mutable_edipperinfo_notification() {
  set_has_edipperinfo_notification();
  if (edipperinfo_notification_ == NULL) edipperinfo_notification_ = new ::zaoxun::EDipperInfoNotification;
  return edipperinfo_notification_;
}
inline ::zaoxun::EDipperInfoNotification* CommonMessage::release_edipperinfo_notification() {
  clear_has_edipperinfo_notification();
  ::zaoxun::EDipperInfoNotification* temp = edipperinfo_notification_;
  edipperinfo_notification_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_edipperinfo_notification(::zaoxun::EDipperInfoNotification* edipperinfo_notification) {
  delete edipperinfo_notification_;
  edipperinfo_notification_ = edipperinfo_notification;
  if (edipperinfo_notification) {
    set_has_edipperinfo_notification();
  } else {
    clear_has_edipperinfo_notification();
  }
}

// optional .zaoxun.GetEDippersRequest get_edippers_request = 28;
inline bool CommonMessage::has_get_edippers_request() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CommonMessage::set_has_get_edippers_request() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CommonMessage::clear_has_get_edippers_request() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CommonMessage::clear_get_edippers_request() {
  if (get_edippers_request_ != NULL) get_edippers_request_->::zaoxun::GetEDippersRequest::Clear();
  clear_has_get_edippers_request();
}
inline const ::zaoxun::GetEDippersRequest& CommonMessage::get_edippers_request() const {
  return get_edippers_request_ != NULL ? *get_edippers_request_ : *default_instance_->get_edippers_request_;
}
inline ::zaoxun::GetEDippersRequest* CommonMessage::mutable_get_edippers_request() {
  set_has_get_edippers_request();
  if (get_edippers_request_ == NULL) get_edippers_request_ = new ::zaoxun::GetEDippersRequest;
  return get_edippers_request_;
}
inline ::zaoxun::GetEDippersRequest* CommonMessage::release_get_edippers_request() {
  clear_has_get_edippers_request();
  ::zaoxun::GetEDippersRequest* temp = get_edippers_request_;
  get_edippers_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_get_edippers_request(::zaoxun::GetEDippersRequest* get_edippers_request) {
  delete get_edippers_request_;
  get_edippers_request_ = get_edippers_request;
  if (get_edippers_request) {
    set_has_get_edippers_request();
  } else {
    clear_has_get_edippers_request();
  }
}

// optional .zaoxun.GetEDippersResponse get_edippers_response = 29;
inline bool CommonMessage::has_get_edippers_response() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CommonMessage::set_has_get_edippers_response() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CommonMessage::clear_has_get_edippers_response() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CommonMessage::clear_get_edippers_response() {
  if (get_edippers_response_ != NULL) get_edippers_response_->::zaoxun::GetEDippersResponse::Clear();
  clear_has_get_edippers_response();
}
inline const ::zaoxun::GetEDippersResponse& CommonMessage::get_edippers_response() const {
  return get_edippers_response_ != NULL ? *get_edippers_response_ : *default_instance_->get_edippers_response_;
}
inline ::zaoxun::GetEDippersResponse* CommonMessage::mutable_get_edippers_response() {
  set_has_get_edippers_response();
  if (get_edippers_response_ == NULL) get_edippers_response_ = new ::zaoxun::GetEDippersResponse;
  return get_edippers_response_;
}
inline ::zaoxun::GetEDippersResponse* CommonMessage::release_get_edippers_response() {
  clear_has_get_edippers_response();
  ::zaoxun::GetEDippersResponse* temp = get_edippers_response_;
  get_edippers_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_get_edippers_response(::zaoxun::GetEDippersResponse* get_edippers_response) {
  delete get_edippers_response_;
  get_edippers_response_ = get_edippers_response;
  if (get_edippers_response) {
    set_has_get_edippers_response();
  } else {
    clear_has_get_edippers_response();
  }
}

// optional .zaoxun.LoadCompleteNotification load_complete_notification = 30;
inline bool CommonMessage::has_load_complete_notification() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CommonMessage::set_has_load_complete_notification() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CommonMessage::clear_has_load_complete_notification() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CommonMessage::clear_load_complete_notification() {
  if (load_complete_notification_ != NULL) load_complete_notification_->::zaoxun::LoadCompleteNotification::Clear();
  clear_has_load_complete_notification();
}
inline const ::zaoxun::LoadCompleteNotification& CommonMessage::load_complete_notification() const {
  return load_complete_notification_ != NULL ? *load_complete_notification_ : *default_instance_->load_complete_notification_;
}
inline ::zaoxun::LoadCompleteNotification* CommonMessage::mutable_load_complete_notification() {
  set_has_load_complete_notification();
  if (load_complete_notification_ == NULL) load_complete_notification_ = new ::zaoxun::LoadCompleteNotification;
  return load_complete_notification_;
}
inline ::zaoxun::LoadCompleteNotification* CommonMessage::release_load_complete_notification() {
  clear_has_load_complete_notification();
  ::zaoxun::LoadCompleteNotification* temp = load_complete_notification_;
  load_complete_notification_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_load_complete_notification(::zaoxun::LoadCompleteNotification* load_complete_notification) {
  delete load_complete_notification_;
  load_complete_notification_ = load_complete_notification;
  if (load_complete_notification) {
    set_has_load_complete_notification();
  } else {
    clear_has_load_complete_notification();
  }
}

// optional .zaoxun.CancelLoadRequest cancel_load_request = 31;
inline bool CommonMessage::has_cancel_load_request() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CommonMessage::set_has_cancel_load_request() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CommonMessage::clear_has_cancel_load_request() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CommonMessage::clear_cancel_load_request() {
  if (cancel_load_request_ != NULL) cancel_load_request_->::zaoxun::CancelLoadRequest::Clear();
  clear_has_cancel_load_request();
}
inline const ::zaoxun::CancelLoadRequest& CommonMessage::cancel_load_request() const {
  return cancel_load_request_ != NULL ? *cancel_load_request_ : *default_instance_->cancel_load_request_;
}
inline ::zaoxun::CancelLoadRequest* CommonMessage::mutable_cancel_load_request() {
  set_has_cancel_load_request();
  if (cancel_load_request_ == NULL) cancel_load_request_ = new ::zaoxun::CancelLoadRequest;
  return cancel_load_request_;
}
inline ::zaoxun::CancelLoadRequest* CommonMessage::release_cancel_load_request() {
  clear_has_cancel_load_request();
  ::zaoxun::CancelLoadRequest* temp = cancel_load_request_;
  cancel_load_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_cancel_load_request(::zaoxun::CancelLoadRequest* cancel_load_request) {
  delete cancel_load_request_;
  cancel_load_request_ = cancel_load_request;
  if (cancel_load_request) {
    set_has_cancel_load_request();
  } else {
    clear_has_cancel_load_request();
  }
}

// optional .zaoxun.CancelLoadResponse cancel_load_response = 32;
inline bool CommonMessage::has_cancel_load_response() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CommonMessage::set_has_cancel_load_response() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CommonMessage::clear_has_cancel_load_response() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CommonMessage::clear_cancel_load_response() {
  if (cancel_load_response_ != NULL) cancel_load_response_->::zaoxun::CancelLoadResponse::Clear();
  clear_has_cancel_load_response();
}
inline const ::zaoxun::CancelLoadResponse& CommonMessage::cancel_load_response() const {
  return cancel_load_response_ != NULL ? *cancel_load_response_ : *default_instance_->cancel_load_response_;
}
inline ::zaoxun::CancelLoadResponse* CommonMessage::mutable_cancel_load_response() {
  set_has_cancel_load_response();
  if (cancel_load_response_ == NULL) cancel_load_response_ = new ::zaoxun::CancelLoadResponse;
  return cancel_load_response_;
}
inline ::zaoxun::CancelLoadResponse* CommonMessage::release_cancel_load_response() {
  clear_has_cancel_load_response();
  ::zaoxun::CancelLoadResponse* temp = cancel_load_response_;
  cancel_load_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_cancel_load_response(::zaoxun::CancelLoadResponse* cancel_load_response) {
  delete cancel_load_response_;
  cancel_load_response_ = cancel_load_response;
  if (cancel_load_response) {
    set_has_cancel_load_response();
  } else {
    clear_has_cancel_load_response();
  }
}

// optional .zaoxun.RejectLoadRequest reject_load_request = 33;
inline bool CommonMessage::has_reject_load_request() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CommonMessage::set_has_reject_load_request() {
  _has_bits_[1] |= 0x00000001u;
}
inline void CommonMessage::clear_has_reject_load_request() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void CommonMessage::clear_reject_load_request() {
  if (reject_load_request_ != NULL) reject_load_request_->::zaoxun::RejectLoadRequest::Clear();
  clear_has_reject_load_request();
}
inline const ::zaoxun::RejectLoadRequest& CommonMessage::reject_load_request() const {
  return reject_load_request_ != NULL ? *reject_load_request_ : *default_instance_->reject_load_request_;
}
inline ::zaoxun::RejectLoadRequest* CommonMessage::mutable_reject_load_request() {
  set_has_reject_load_request();
  if (reject_load_request_ == NULL) reject_load_request_ = new ::zaoxun::RejectLoadRequest;
  return reject_load_request_;
}
inline ::zaoxun::RejectLoadRequest* CommonMessage::release_reject_load_request() {
  clear_has_reject_load_request();
  ::zaoxun::RejectLoadRequest* temp = reject_load_request_;
  reject_load_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_reject_load_request(::zaoxun::RejectLoadRequest* reject_load_request) {
  delete reject_load_request_;
  reject_load_request_ = reject_load_request;
  if (reject_load_request) {
    set_has_reject_load_request();
  } else {
    clear_has_reject_load_request();
  }
}

// optional .zaoxun.RejectLoadResponse reject_load_response = 34;
inline bool CommonMessage::has_reject_load_response() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void CommonMessage::set_has_reject_load_response() {
  _has_bits_[1] |= 0x00000002u;
}
inline void CommonMessage::clear_has_reject_load_response() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void CommonMessage::clear_reject_load_response() {
  if (reject_load_response_ != NULL) reject_load_response_->::zaoxun::RejectLoadResponse::Clear();
  clear_has_reject_load_response();
}
inline const ::zaoxun::RejectLoadResponse& CommonMessage::reject_load_response() const {
  return reject_load_response_ != NULL ? *reject_load_response_ : *default_instance_->reject_load_response_;
}
inline ::zaoxun::RejectLoadResponse* CommonMessage::mutable_reject_load_response() {
  set_has_reject_load_response();
  if (reject_load_response_ == NULL) reject_load_response_ = new ::zaoxun::RejectLoadResponse;
  return reject_load_response_;
}
inline ::zaoxun::RejectLoadResponse* CommonMessage::release_reject_load_response() {
  clear_has_reject_load_response();
  ::zaoxun::RejectLoadResponse* temp = reject_load_response_;
  reject_load_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_reject_load_response(::zaoxun::RejectLoadResponse* reject_load_response) {
  delete reject_load_response_;
  reject_load_response_ = reject_load_response;
  if (reject_load_response) {
    set_has_reject_load_response();
  } else {
    clear_has_reject_load_response();
  }
}

// optional .zaoxun.ExitNotification exit_notification = 35;
inline bool CommonMessage::has_exit_notification() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void CommonMessage::set_has_exit_notification() {
  _has_bits_[1] |= 0x00000004u;
}
inline void CommonMessage::clear_has_exit_notification() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void CommonMessage::clear_exit_notification() {
  if (exit_notification_ != NULL) exit_notification_->::zaoxun::ExitNotification::Clear();
  clear_has_exit_notification();
}
inline const ::zaoxun::ExitNotification& CommonMessage::exit_notification() const {
  return exit_notification_ != NULL ? *exit_notification_ : *default_instance_->exit_notification_;
}
inline ::zaoxun::ExitNotification* CommonMessage::mutable_exit_notification() {
  set_has_exit_notification();
  if (exit_notification_ == NULL) exit_notification_ = new ::zaoxun::ExitNotification;
  return exit_notification_;
}
inline ::zaoxun::ExitNotification* CommonMessage::release_exit_notification() {
  clear_has_exit_notification();
  ::zaoxun::ExitNotification* temp = exit_notification_;
  exit_notification_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_exit_notification(::zaoxun::ExitNotification* exit_notification) {
  delete exit_notification_;
  exit_notification_ = exit_notification;
  if (exit_notification) {
    set_has_exit_notification();
  } else {
    clear_has_exit_notification();
  }
}

// optional .zaoxun.DeviceStatusChangeNotification device_status_change_notification = 36;
inline bool CommonMessage::has_device_status_change_notification() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void CommonMessage::set_has_device_status_change_notification() {
  _has_bits_[1] |= 0x00000008u;
}
inline void CommonMessage::clear_has_device_status_change_notification() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void CommonMessage::clear_device_status_change_notification() {
  if (device_status_change_notification_ != NULL) device_status_change_notification_->::zaoxun::DeviceStatusChangeNotification::Clear();
  clear_has_device_status_change_notification();
}
inline const ::zaoxun::DeviceStatusChangeNotification& CommonMessage::device_status_change_notification() const {
  return device_status_change_notification_ != NULL ? *device_status_change_notification_ : *default_instance_->device_status_change_notification_;
}
inline ::zaoxun::DeviceStatusChangeNotification* CommonMessage::mutable_device_status_change_notification() {
  set_has_device_status_change_notification();
  if (device_status_change_notification_ == NULL) device_status_change_notification_ = new ::zaoxun::DeviceStatusChangeNotification;
  return device_status_change_notification_;
}
inline ::zaoxun::DeviceStatusChangeNotification* CommonMessage::release_device_status_change_notification() {
  clear_has_device_status_change_notification();
  ::zaoxun::DeviceStatusChangeNotification* temp = device_status_change_notification_;
  device_status_change_notification_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_device_status_change_notification(::zaoxun::DeviceStatusChangeNotification* device_status_change_notification) {
  delete device_status_change_notification_;
  device_status_change_notification_ = device_status_change_notification;
  if (device_status_change_notification) {
    set_has_device_status_change_notification();
  } else {
    clear_has_device_status_change_notification();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace zaoxun

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zaoxun::MessageType>() {
  return ::zaoxun::MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zaoxun::CarType>() {
  return ::zaoxun::CarType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zaoxun::RunningStatus>() {
  return ::zaoxun::RunningStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_2eproto__INCLUDED
