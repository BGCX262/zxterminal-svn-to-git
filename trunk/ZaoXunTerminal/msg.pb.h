// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_msg_2eproto__INCLUDED
#define PROTOBUF_msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace zaoxun {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msg_2eproto();
void protobuf_AssignDesc_msg_2eproto();
void protobuf_ShutdownFile_msg_2eproto();

class LoginRequest;
class LoginResponse;
class CheckRequest;
class CheckResponse;
class OilQuantityRequest;
class OilQuantityResponse;
class ProductionRequest;
class ProductionResponse;
class DistanceRequest;
class DistanceResponse;
class TimesRequest;
class TimesResponse;
class OilingRequest;
class OilingResponse;
class LoadRequest;
class LoadResponse;
class UnloadRequest;
class UnloadResponse;
class ManualUnloadRequest;
class ManualUnloadResponse;
class SpeedLimitMessage;
class ShortMessage;
class GPSData;
class AudioFileData;
class CaptureFileData;
class MaterialsRequest;
class Material;
class MaterialsResponse;
class MaterialsNotification;
class CollisionCarInfo;
class AntiCollisionNotification;
class EDipperInfo;
class EDipperInfoNotification;
class GetEDippersRequest;
class GetEDippersResponse;
class LoadCompleteRequest;
class LoadCompleteResponse;
class ManualLoadCompleteRequest;
class ManualLoadCompleteResponse;
class CancelLoadRequest;
class CancelLoadResponse;
class RejectLoadRequest;
class RejectLoadResponse;
class ExitNotification;
class DeviceStatusRequest;
class DeviceStatusResponse;
class CommandRequest;
class CommandResponse;
class ProductionInfoRequest;
class ProductionInfoResponse;
class FuelRequest;
class FuelResponse;
class HeartBeat;
class TargetNotification;
class CommonMessage;

enum MessageType {
  LOGIN_REQUEST = 1,
  LOGIN_RESPONSE = 2,
  CHECK_REQUEST = 3,
  CHECK_RESPONSE = 4,
  OIL_QUANTITY_REQUEST = 5,
  OIL_QUANTITY_RESPONSE = 6,
  PRODUCTION_REQUEST = 7,
  PRODUCTION_RESPONSE = 8,
  DISTANCE_REQUEST = 9,
  DISTANCE_RESPONSE = 10,
  TIMES_REQUEST = 11,
  TIMES_RESPONSE = 12,
  OILING_REQUEST = 13,
  OILING_RESPONSE = 14,
  LOAD_REQUEST = 15,
  LOAD_RESPONSE = 16,
  UNLOAD_REQUEST = 17,
  UNLOAD_RESPONSE = 18,
  SPEED_LIMIT = 19,
  SHORT_MESSAGE = 20,
  GPS_DATA = 21,
  AUDIO_FILE_DATA = 22,
  CAPTURE_FILE_DATA = 23,
  MATERIALS_NOTIFICATION = 24,
  ANTI_COLLISION_NOTIFICATION = 25,
  EDIPPERINFO_NOTIFICATION = 26,
  GET_EDIPPERS_REQUEST = 27,
  GET_EDIPPERS_RESPONSE = 28,
  LOAD_COMPLETE_REQUEST = 29,
  LOAD_COMPLETE_RESPONSE = 30,
  CANCEL_LOAD_REQUEST = 31,
  CANCEL_LOAD_RESPONSE = 32,
  REJECT_LOAD_REQUEST = 33,
  REJECT_LOAD_RESPONSE = 34,
  EXIT_NOTIFICATION = 35,
  DEVICE_STATUS_REQUEST = 36,
  MATERIALS_REQUEST = 37,
  MATERIALS_RESPONSE = 38,
  COMMAND_REQUEST = 39,
  PRODUCTION_INFO_REQUEST = 40,
  PRODUCTION_INFO_RESPONSE = 41,
  FUEL_REQUEST = 42,
  FUEL_RESPONSE = 43,
  HEART_BEAT = 44,
  TARGET_NOTIFICATION = 45,
  DEVICE_STATUS_RESPONSE = 46,
  COMMAND_RESPONSE = 47,
  MANUAL_LOAD_COMPLETE_REQUEST = 48,
  MANUAL_LOAD_COMPLETE_RESPONSE = 49,
  MANUAL_UNLOAD_REQUEST = 50,
  MANUAL_UNLOAD_RESPONSE = 51
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = LOGIN_REQUEST;
const MessageType MessageType_MAX = MANUAL_UNLOAD_RESPONSE;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum CarType {
  MINE_CAR = 1,
  E_DIPPER = 2,
  OIL_CAR = 3,
  WATER_CAR = 4,
  OTHER_CAR = 5
};
bool CarType_IsValid(int value);
const CarType CarType_MIN = MINE_CAR;
const CarType CarType_MAX = OTHER_CAR;
const int CarType_ARRAYSIZE = CarType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CarType_descriptor();
inline const ::std::string& CarType_Name(CarType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CarType_descriptor(), value);
}
inline bool CarType_Parse(
    const ::std::string& name, CarType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CarType>(
    CarType_descriptor(), name, value);
}
enum RunningStatus {
  RUNNING = 1,
  CLOSED = 2,
  UNKNOWN = 3
};
bool RunningStatus_IsValid(int value);
const RunningStatus RunningStatus_MIN = RUNNING;
const RunningStatus RunningStatus_MAX = UNKNOWN;
const int RunningStatus_ARRAYSIZE = RunningStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RunningStatus_descriptor();
inline const ::std::string& RunningStatus_Name(RunningStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RunningStatus_descriptor(), value);
}
inline bool RunningStatus_Parse(
    const ::std::string& name, RunningStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RunningStatus>(
    RunningStatus_descriptor(), name, value);
}
// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.LoginRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .zaoxun.CarType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::zaoxun::CarType type() const;
  inline void set_type(::zaoxun::CarType value);

  // optional string car_no = 4;
  inline bool has_car_no() const;
  inline void clear_car_no();
  static const int kCarNoFieldNumber = 4;
  inline const ::std::string& car_no() const;
  inline void set_car_no(const ::std::string& value);
  inline void set_car_no(const char* value);
  inline void set_car_no(const char* value, size_t size);
  inline ::std::string* mutable_car_no();
  inline ::std::string* release_car_no();
  inline void set_allocated_car_no(::std::string* car_no);

  // optional .zaoxun.RunningStatus run_status = 5;
  inline bool has_run_status() const;
  inline void clear_run_status();
  static const int kRunStatusFieldNumber = 5;
  inline ::zaoxun::RunningStatus run_status() const;
  inline void set_run_status(::zaoxun::RunningStatus value);

  // optional int32 material_id = 6;
  inline bool has_material_id() const;
  inline void clear_material_id();
  static const int kMaterialIdFieldNumber = 6;
  inline ::google::protobuf::int32 material_id() const;
  inline void set_material_id(::google::protobuf::int32 value);

  // optional string material_name = 7;
  inline bool has_material_name() const;
  inline void clear_material_name();
  static const int kMaterialNameFieldNumber = 7;
  inline const ::std::string& material_name() const;
  inline void set_material_name(const ::std::string& value);
  inline void set_material_name(const char* value);
  inline void set_material_name(const char* value, size_t size);
  inline ::std::string* mutable_material_name();
  inline ::std::string* release_material_name();
  inline void set_allocated_material_name(::std::string* material_name);

  // @@protoc_insertion_point(class_scope:zaoxun.LoginResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_car_no();
  inline void clear_has_car_no();
  inline void set_has_run_status();
  inline void clear_has_run_status();
  inline void set_has_material_id();
  inline void clear_has_material_id();
  inline void set_has_material_name();
  inline void clear_has_material_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 result_;
  int type_;
  ::std::string* car_no_;
  int run_status_;
  ::google::protobuf::int32 material_id_;
  ::std::string* material_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class CheckRequest : public ::google::protobuf::Message {
 public:
  CheckRequest();
  virtual ~CheckRequest();

  CheckRequest(const CheckRequest& from);

  inline CheckRequest& operator=(const CheckRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckRequest& default_instance();

  void Swap(CheckRequest* other);

  // implements Message ----------------------------------------------

  CheckRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckRequest& from);
  void MergeFrom(const CheckRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.CheckRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CheckRequest* default_instance_;
};
// -------------------------------------------------------------------

class CheckResponse : public ::google::protobuf::Message {
 public:
  CheckResponse();
  virtual ~CheckResponse();

  CheckResponse(const CheckResponse& from);

  inline CheckResponse& operator=(const CheckResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckResponse& default_instance();

  void Swap(CheckResponse* other);

  // implements Message ----------------------------------------------

  CheckResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckResponse& from);
  void MergeFrom(const CheckResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 driver_id = 2;
  inline bool has_driver_id() const;
  inline void clear_driver_id();
  static const int kDriverIdFieldNumber = 2;
  inline ::google::protobuf::int32 driver_id() const;
  inline void set_driver_id(::google::protobuf::int32 value);

  // optional string driver_name = 3;
  inline bool has_driver_name() const;
  inline void clear_driver_name();
  static const int kDriverNameFieldNumber = 3;
  inline const ::std::string& driver_name() const;
  inline void set_driver_name(const ::std::string& value);
  inline void set_driver_name(const char* value);
  inline void set_driver_name(const char* value, size_t size);
  inline ::std::string* mutable_driver_name();
  inline ::std::string* release_driver_name();
  inline void set_allocated_driver_name(::std::string* driver_name);

  // optional double speed_limit = 4;
  inline bool has_speed_limit() const;
  inline void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 4;
  inline double speed_limit() const;
  inline void set_speed_limit(double value);

  // optional int32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.CheckResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_driver_id();
  inline void clear_has_driver_id();
  inline void set_has_driver_name();
  inline void clear_has_driver_name();
  inline void set_has_speed_limit();
  inline void clear_has_speed_limit();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* driver_name_;
  ::google::protobuf::int32 driver_id_;
  ::google::protobuf::int32 status_;
  double speed_limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CheckResponse* default_instance_;
};
// -------------------------------------------------------------------

class OilQuantityRequest : public ::google::protobuf::Message {
 public:
  OilQuantityRequest();
  virtual ~OilQuantityRequest();

  OilQuantityRequest(const OilQuantityRequest& from);

  inline OilQuantityRequest& operator=(const OilQuantityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OilQuantityRequest& default_instance();

  void Swap(OilQuantityRequest* other);

  // implements Message ----------------------------------------------

  OilQuantityRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OilQuantityRequest& from);
  void MergeFrom(const OilQuantityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.OilQuantityRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static OilQuantityRequest* default_instance_;
};
// -------------------------------------------------------------------

class OilQuantityResponse : public ::google::protobuf::Message {
 public:
  OilQuantityResponse();
  virtual ~OilQuantityResponse();

  OilQuantityResponse(const OilQuantityResponse& from);

  inline OilQuantityResponse& operator=(const OilQuantityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OilQuantityResponse& default_instance();

  void Swap(OilQuantityResponse* other);

  // implements Message ----------------------------------------------

  OilQuantityResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OilQuantityResponse& from);
  void MergeFrom(const OilQuantityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional double quantity = 3;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 3;
  inline double quantity() const;
  inline void set_quantity(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.OilQuantityResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_quantity();
  inline void clear_has_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  double quantity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static OilQuantityResponse* default_instance_;
};
// -------------------------------------------------------------------

class ProductionRequest : public ::google::protobuf::Message {
 public:
  ProductionRequest();
  virtual ~ProductionRequest();

  ProductionRequest(const ProductionRequest& from);

  inline ProductionRequest& operator=(const ProductionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductionRequest& default_instance();

  void Swap(ProductionRequest* other);

  // implements Message ----------------------------------------------

  ProductionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductionRequest& from);
  void MergeFrom(const ProductionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.ProductionRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ProductionRequest* default_instance_;
};
// -------------------------------------------------------------------

class ProductionResponse : public ::google::protobuf::Message {
 public:
  ProductionResponse();
  virtual ~ProductionResponse();

  ProductionResponse(const ProductionResponse& from);

  inline ProductionResponse& operator=(const ProductionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductionResponse& default_instance();

  void Swap(ProductionResponse* other);

  // implements Message ----------------------------------------------

  ProductionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductionResponse& from);
  void MergeFrom(const ProductionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // optional double quantity = 3;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 3;
  inline double quantity() const;
  inline void set_quantity(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.ProductionResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();
  inline void set_has_quantity();
  inline void clear_has_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  double quantity_;
  ::google::protobuf::int32 period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ProductionResponse* default_instance_;
};
// -------------------------------------------------------------------

class DistanceRequest : public ::google::protobuf::Message {
 public:
  DistanceRequest();
  virtual ~DistanceRequest();

  DistanceRequest(const DistanceRequest& from);

  inline DistanceRequest& operator=(const DistanceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DistanceRequest& default_instance();

  void Swap(DistanceRequest* other);

  // implements Message ----------------------------------------------

  DistanceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DistanceRequest& from);
  void MergeFrom(const DistanceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.DistanceRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static DistanceRequest* default_instance_;
};
// -------------------------------------------------------------------

class DistanceResponse : public ::google::protobuf::Message {
 public:
  DistanceResponse();
  virtual ~DistanceResponse();

  DistanceResponse(const DistanceResponse& from);

  inline DistanceResponse& operator=(const DistanceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DistanceResponse& default_instance();

  void Swap(DistanceResponse* other);

  // implements Message ----------------------------------------------

  DistanceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DistanceResponse& from);
  void MergeFrom(const DistanceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // optional double distance = 3;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 3;
  inline double distance() const;
  inline void set_distance(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.DistanceResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();
  inline void set_has_distance();
  inline void clear_has_distance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  double distance_;
  ::google::protobuf::int32 period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static DistanceResponse* default_instance_;
};
// -------------------------------------------------------------------

class TimesRequest : public ::google::protobuf::Message {
 public:
  TimesRequest();
  virtual ~TimesRequest();

  TimesRequest(const TimesRequest& from);

  inline TimesRequest& operator=(const TimesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimesRequest& default_instance();

  void Swap(TimesRequest* other);

  // implements Message ----------------------------------------------

  TimesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimesRequest& from);
  void MergeFrom(const TimesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.TimesRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 period_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static TimesRequest* default_instance_;
};
// -------------------------------------------------------------------

class TimesResponse : public ::google::protobuf::Message {
 public:
  TimesResponse();
  virtual ~TimesResponse();

  TimesResponse(const TimesResponse& from);

  inline TimesResponse& operator=(const TimesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimesResponse& default_instance();

  void Swap(TimesResponse* other);

  // implements Message ----------------------------------------------

  TimesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimesResponse& from);
  void MergeFrom(const TimesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 period = 2;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 2;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // optional int32 times = 3;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 3;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.TimesResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_period();
  inline void clear_has_period();
  inline void set_has_times();
  inline void clear_has_times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 period_;
  ::google::protobuf::int32 times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static TimesResponse* default_instance_;
};
// -------------------------------------------------------------------

class OilingRequest : public ::google::protobuf::Message {
 public:
  OilingRequest();
  virtual ~OilingRequest();

  OilingRequest(const OilingRequest& from);

  inline OilingRequest& operator=(const OilingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OilingRequest& default_instance();

  void Swap(OilingRequest* other);

  // implements Message ----------------------------------------------

  OilingRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OilingRequest& from);
  void MergeFrom(const OilingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // optional double volume = 3;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 3;
  inline double volume() const;
  inline void set_volume(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.OilingRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_volume();
  inline void clear_has_volume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* target_;
  double volume_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static OilingRequest* default_instance_;
};
// -------------------------------------------------------------------

class OilingResponse : public ::google::protobuf::Message {
 public:
  OilingResponse();
  virtual ~OilingResponse();

  OilingResponse(const OilingResponse& from);

  inline OilingResponse& operator=(const OilingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OilingResponse& default_instance();

  void Swap(OilingResponse* other);

  // implements Message ----------------------------------------------

  OilingResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OilingResponse& from);
  void MergeFrom(const OilingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // optional double volume = 3;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 3;
  inline double volume() const;
  inline void set_volume(double value);

  // optional int32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.OilingResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* target_;
  double volume_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static OilingResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoadRequest : public ::google::protobuf::Message {
 public:
  LoadRequest();
  virtual ~LoadRequest();

  LoadRequest(const LoadRequest& from);

  inline LoadRequest& operator=(const LoadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadRequest& default_instance();

  void Swap(LoadRequest* other);

  // implements Message ----------------------------------------------

  LoadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadRequest& from);
  void MergeFrom(const LoadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional string car_no = 3;
  inline bool has_car_no() const;
  inline void clear_car_no();
  static const int kCarNoFieldNumber = 3;
  inline const ::std::string& car_no() const;
  inline void set_car_no(const ::std::string& value);
  inline void set_car_no(const char* value);
  inline void set_car_no(const char* value, size_t size);
  inline ::std::string* mutable_car_no();
  inline ::std::string* release_car_no();
  inline void set_allocated_car_no(::std::string* car_no);

  // @@protoc_insertion_point(class_scope:zaoxun.LoadRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_car_no();
  inline void clear_has_car_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* edipper_device_id_;
  ::std::string* car_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static LoadRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoadResponse : public ::google::protobuf::Message {
 public:
  LoadResponse();
  virtual ~LoadResponse();

  LoadResponse(const LoadResponse& from);

  inline LoadResponse& operator=(const LoadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadResponse& default_instance();

  void Swap(LoadResponse* other);

  // implements Message ----------------------------------------------

  LoadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadResponse& from);
  void MergeFrom(const LoadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional int32 material_id = 3;
  inline bool has_material_id() const;
  inline void clear_material_id();
  static const int kMaterialIdFieldNumber = 3;
  inline ::google::protobuf::int32 material_id() const;
  inline void set_material_id(::google::protobuf::int32 value);

  // optional string material_name = 4;
  inline bool has_material_name() const;
  inline void clear_material_name();
  static const int kMaterialNameFieldNumber = 4;
  inline const ::std::string& material_name() const;
  inline void set_material_name(const ::std::string& value);
  inline void set_material_name(const char* value);
  inline void set_material_name(const char* value, size_t size);
  inline ::std::string* mutable_material_name();
  inline ::std::string* release_material_name();
  inline void set_allocated_material_name(::std::string* material_name);

  // optional int32 result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.LoadResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_material_id();
  inline void clear_has_material_id();
  inline void set_has_material_name();
  inline void clear_has_material_name();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* edipper_device_id_;
  ::std::string* material_name_;
  ::google::protobuf::int32 material_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static LoadResponse* default_instance_;
};
// -------------------------------------------------------------------

class UnloadRequest : public ::google::protobuf::Message {
 public:
  UnloadRequest();
  virtual ~UnloadRequest();

  UnloadRequest(const UnloadRequest& from);

  inline UnloadRequest& operator=(const UnloadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnloadRequest& default_instance();

  void Swap(UnloadRequest* other);

  // implements Message ----------------------------------------------

  UnloadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnloadRequest& from);
  void MergeFrom(const UnloadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.UnloadRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* edipper_device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static UnloadRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnloadResponse : public ::google::protobuf::Message {
 public:
  UnloadResponse();
  virtual ~UnloadResponse();

  UnloadResponse(const UnloadResponse& from);

  inline UnloadResponse& operator=(const UnloadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnloadResponse& default_instance();

  void Swap(UnloadResponse* other);

  // implements Message ----------------------------------------------

  UnloadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnloadResponse& from);
  void MergeFrom(const UnloadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.UnloadResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static UnloadResponse* default_instance_;
};
// -------------------------------------------------------------------

class ManualUnloadRequest : public ::google::protobuf::Message {
 public:
  ManualUnloadRequest();
  virtual ~ManualUnloadRequest();

  ManualUnloadRequest(const ManualUnloadRequest& from);

  inline ManualUnloadRequest& operator=(const ManualUnloadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManualUnloadRequest& default_instance();

  void Swap(ManualUnloadRequest* other);

  // implements Message ----------------------------------------------

  ManualUnloadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManualUnloadRequest& from);
  void MergeFrom(const ManualUnloadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional int32 material_id = 3;
  inline bool has_material_id() const;
  inline void clear_material_id();
  static const int kMaterialIdFieldNumber = 3;
  inline ::google::protobuf::int32 material_id() const;
  inline void set_material_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.ManualUnloadRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_material_id();
  inline void clear_has_material_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* edipper_device_id_;
  ::google::protobuf::int32 material_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ManualUnloadRequest* default_instance_;
};
// -------------------------------------------------------------------

class ManualUnloadResponse : public ::google::protobuf::Message {
 public:
  ManualUnloadResponse();
  virtual ~ManualUnloadResponse();

  ManualUnloadResponse(const ManualUnloadResponse& from);

  inline ManualUnloadResponse& operator=(const ManualUnloadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManualUnloadResponse& default_instance();

  void Swap(ManualUnloadResponse* other);

  // implements Message ----------------------------------------------

  ManualUnloadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManualUnloadResponse& from);
  void MergeFrom(const ManualUnloadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional int32 material_id = 3;
  inline bool has_material_id() const;
  inline void clear_material_id();
  static const int kMaterialIdFieldNumber = 3;
  inline ::google::protobuf::int32 material_id() const;
  inline void set_material_id(::google::protobuf::int32 value);

  // optional int32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.ManualUnloadResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_material_id();
  inline void clear_has_material_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* edipper_device_id_;
  ::google::protobuf::int32 material_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ManualUnloadResponse* default_instance_;
};
// -------------------------------------------------------------------

class SpeedLimitMessage : public ::google::protobuf::Message {
 public:
  SpeedLimitMessage();
  virtual ~SpeedLimitMessage();

  SpeedLimitMessage(const SpeedLimitMessage& from);

  inline SpeedLimitMessage& operator=(const SpeedLimitMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedLimitMessage& default_instance();

  void Swap(SpeedLimitMessage* other);

  // implements Message ----------------------------------------------

  SpeedLimitMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeedLimitMessage& from);
  void MergeFrom(const SpeedLimitMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional double speed = 2;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 2;
  inline double speed() const;
  inline void set_speed(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.SpeedLimitMessage)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_speed();
  inline void clear_has_speed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  double speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static SpeedLimitMessage* default_instance_;
};
// -------------------------------------------------------------------

class ShortMessage : public ::google::protobuf::Message {
 public:
  ShortMessage();
  virtual ~ShortMessage();

  ShortMessage(const ShortMessage& from);

  inline ShortMessage& operator=(const ShortMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShortMessage& default_instance();

  void Swap(ShortMessage* other);

  // implements Message ----------------------------------------------

  ShortMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShortMessage& from);
  void MergeFrom(const ShortMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string dest_device = 2;
  inline bool has_dest_device() const;
  inline void clear_dest_device();
  static const int kDestDeviceFieldNumber = 2;
  inline const ::std::string& dest_device() const;
  inline void set_dest_device(const ::std::string& value);
  inline void set_dest_device(const char* value);
  inline void set_dest_device(const char* value, size_t size);
  inline ::std::string* mutable_dest_device();
  inline ::std::string* release_dest_device();
  inline void set_allocated_dest_device(::std::string* dest_device);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:zaoxun.ShortMessage)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_dest_device();
  inline void clear_has_dest_device();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* dest_device_;
  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ShortMessage* default_instance_;
};
// -------------------------------------------------------------------

class GPSData : public ::google::protobuf::Message {
 public:
  GPSData();
  virtual ~GPSData();

  GPSData(const GPSData& from);

  inline GPSData& operator=(const GPSData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSData& default_instance();

  void Swap(GPSData* other);

  // implements Message ----------------------------------------------

  GPSData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSData& from);
  void MergeFrom(const GPSData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string latitude = 3;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 3;
  inline const ::std::string& latitude() const;
  inline void set_latitude(const ::std::string& value);
  inline void set_latitude(const char* value);
  inline void set_latitude(const char* value, size_t size);
  inline ::std::string* mutable_latitude();
  inline ::std::string* release_latitude();
  inline void set_allocated_latitude(::std::string* latitude);

  // optional string longitude = 4;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 4;
  inline const ::std::string& longitude() const;
  inline void set_longitude(const ::std::string& value);
  inline void set_longitude(const char* value);
  inline void set_longitude(const char* value, size_t size);
  inline ::std::string* mutable_longitude();
  inline ::std::string* release_longitude();
  inline void set_allocated_longitude(::std::string* longitude);

  // optional string speed = 5;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 5;
  inline const ::std::string& speed() const;
  inline void set_speed(const ::std::string& value);
  inline void set_speed(const char* value);
  inline void set_speed(const char* value, size_t size);
  inline ::std::string* mutable_speed();
  inline ::std::string* release_speed();
  inline void set_allocated_speed(::std::string* speed);

  // optional string elevation = 6;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 6;
  inline const ::std::string& elevation() const;
  inline void set_elevation(const ::std::string& value);
  inline void set_elevation(const char* value);
  inline void set_elevation(const char* value, size_t size);
  inline ::std::string* mutable_elevation();
  inline ::std::string* release_elevation();
  inline void set_allocated_elevation(::std::string* elevation);

  // optional string direction = 7;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 7;
  inline const ::std::string& direction() const;
  inline void set_direction(const ::std::string& value);
  inline void set_direction(const char* value);
  inline void set_direction(const char* value, size_t size);
  inline ::std::string* mutable_direction();
  inline ::std::string* release_direction();
  inline void set_allocated_direction(::std::string* direction);

  // optional string radius = 8;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 8;
  inline const ::std::string& radius() const;
  inline void set_radius(const ::std::string& value);
  inline void set_radius(const char* value);
  inline void set_radius(const char* value, size_t size);
  inline ::std::string* mutable_radius();
  inline ::std::string* release_radius();
  inline void set_allocated_radius(::std::string* radius);

  // optional string loctype = 9;
  inline bool has_loctype() const;
  inline void clear_loctype();
  static const int kLoctypeFieldNumber = 9;
  inline const ::std::string& loctype() const;
  inline void set_loctype(const ::std::string& value);
  inline void set_loctype(const char* value);
  inline void set_loctype(const char* value, size_t size);
  inline ::std::string* mutable_loctype();
  inline ::std::string* release_loctype();
  inline void set_allocated_loctype(::std::string* loctype);

  // optional string addrstr = 10;
  inline bool has_addrstr() const;
  inline void clear_addrstr();
  static const int kAddrstrFieldNumber = 10;
  inline const ::std::string& addrstr() const;
  inline void set_addrstr(const ::std::string& value);
  inline void set_addrstr(const char* value);
  inline void set_addrstr(const char* value, size_t size);
  inline ::std::string* mutable_addrstr();
  inline ::std::string* release_addrstr();
  inline void set_allocated_addrstr(::std::string* addrstr);

  // optional string province = 11;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 11;
  inline const ::std::string& province() const;
  inline void set_province(const ::std::string& value);
  inline void set_province(const char* value);
  inline void set_province(const char* value, size_t size);
  inline ::std::string* mutable_province();
  inline ::std::string* release_province();
  inline void set_allocated_province(::std::string* province);

  // optional string city = 12;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 12;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string district = 13;
  inline bool has_district() const;
  inline void clear_district();
  static const int kDistrictFieldNumber = 13;
  inline const ::std::string& district() const;
  inline void set_district(const ::std::string& value);
  inline void set_district(const char* value);
  inline void set_district(const char* value, size_t size);
  inline ::std::string* mutable_district();
  inline ::std::string* release_district();
  inline void set_allocated_district(::std::string* district);

  // optional string poi = 14;
  inline bool has_poi() const;
  inline void clear_poi();
  static const int kPoiFieldNumber = 14;
  inline const ::std::string& poi() const;
  inline void set_poi(const ::std::string& value);
  inline void set_poi(const char* value);
  inline void set_poi(const char* value, size_t size);
  inline ::std::string* mutable_poi();
  inline ::std::string* release_poi();
  inline void set_allocated_poi(::std::string* poi);

  // @@protoc_insertion_point(class_scope:zaoxun.GPSData)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_loctype();
  inline void clear_has_loctype();
  inline void set_has_addrstr();
  inline void clear_has_addrstr();
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_district();
  inline void clear_has_district();
  inline void set_has_poi();
  inline void clear_has_poi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* time_;
  ::std::string* latitude_;
  ::std::string* longitude_;
  ::std::string* speed_;
  ::std::string* elevation_;
  ::std::string* direction_;
  ::std::string* radius_;
  ::std::string* loctype_;
  ::std::string* addrstr_;
  ::std::string* province_;
  ::std::string* city_;
  ::std::string* district_;
  ::std::string* poi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static GPSData* default_instance_;
};
// -------------------------------------------------------------------

class AudioFileData : public ::google::protobuf::Message {
 public:
  AudioFileData();
  virtual ~AudioFileData();

  AudioFileData(const AudioFileData& from);

  inline AudioFileData& operator=(const AudioFileData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioFileData& default_instance();

  void Swap(AudioFileData* other);

  // implements Message ----------------------------------------------

  AudioFileData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioFileData& from);
  void MergeFrom(const AudioFileData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional string dest_device = 4;
  inline bool has_dest_device() const;
  inline void clear_dest_device();
  static const int kDestDeviceFieldNumber = 4;
  inline const ::std::string& dest_device() const;
  inline void set_dest_device(const ::std::string& value);
  inline void set_dest_device(const char* value);
  inline void set_dest_device(const char* value, size_t size);
  inline ::std::string* mutable_dest_device();
  inline ::std::string* release_dest_device();
  inline void set_allocated_dest_device(::std::string* dest_device);

  // optional int32 total_packets = 5;
  inline bool has_total_packets() const;
  inline void clear_total_packets();
  static const int kTotalPacketsFieldNumber = 5;
  inline ::google::protobuf::int32 total_packets() const;
  inline void set_total_packets(::google::protobuf::int32 value);

  // optional int32 current_packet = 6;
  inline bool has_current_packet() const;
  inline void clear_current_packet();
  static const int kCurrentPacketFieldNumber = 6;
  inline ::google::protobuf::int32 current_packet() const;
  inline void set_current_packet(::google::protobuf::int32 value);

  // optional int32 data_len = 7;
  inline bool has_data_len() const;
  inline void clear_data_len();
  static const int kDataLenFieldNumber = 7;
  inline ::google::protobuf::int32 data_len() const;
  inline void set_data_len(::google::protobuf::int32 value);

  // optional bytes data = 8;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 8;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:zaoxun.AudioFileData)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_dest_device();
  inline void clear_has_dest_device();
  inline void set_has_total_packets();
  inline void clear_has_total_packets();
  inline void set_has_current_packet();
  inline void clear_has_current_packet();
  inline void set_has_data_len();
  inline void clear_has_data_len();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* time_;
  ::std::string* file_name_;
  ::std::string* dest_device_;
  ::google::protobuf::int32 total_packets_;
  ::google::protobuf::int32 current_packet_;
  ::std::string* data_;
  ::google::protobuf::int32 data_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static AudioFileData* default_instance_;
};
// -------------------------------------------------------------------

class CaptureFileData : public ::google::protobuf::Message {
 public:
  CaptureFileData();
  virtual ~CaptureFileData();

  CaptureFileData(const CaptureFileData& from);

  inline CaptureFileData& operator=(const CaptureFileData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaptureFileData& default_instance();

  void Swap(CaptureFileData* other);

  // implements Message ----------------------------------------------

  CaptureFileData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaptureFileData& from);
  void MergeFrom(const CaptureFileData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional int32 total_packets = 4;
  inline bool has_total_packets() const;
  inline void clear_total_packets();
  static const int kTotalPacketsFieldNumber = 4;
  inline ::google::protobuf::int32 total_packets() const;
  inline void set_total_packets(::google::protobuf::int32 value);

  // optional int32 current_packet = 5;
  inline bool has_current_packet() const;
  inline void clear_current_packet();
  static const int kCurrentPacketFieldNumber = 5;
  inline ::google::protobuf::int32 current_packet() const;
  inline void set_current_packet(::google::protobuf::int32 value);

  // optional int32 data_len = 6;
  inline bool has_data_len() const;
  inline void clear_data_len();
  static const int kDataLenFieldNumber = 6;
  inline ::google::protobuf::int32 data_len() const;
  inline void set_data_len(::google::protobuf::int32 value);

  // optional bytes data = 7;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 7;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:zaoxun.CaptureFileData)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_total_packets();
  inline void clear_has_total_packets();
  inline void set_has_current_packet();
  inline void clear_has_current_packet();
  inline void set_has_data_len();
  inline void clear_has_data_len();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* time_;
  ::std::string* file_name_;
  ::google::protobuf::int32 total_packets_;
  ::google::protobuf::int32 current_packet_;
  ::std::string* data_;
  ::google::protobuf::int32 data_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CaptureFileData* default_instance_;
};
// -------------------------------------------------------------------

class MaterialsRequest : public ::google::protobuf::Message {
 public:
  MaterialsRequest();
  virtual ~MaterialsRequest();

  MaterialsRequest(const MaterialsRequest& from);

  inline MaterialsRequest& operator=(const MaterialsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaterialsRequest& default_instance();

  void Swap(MaterialsRequest* other);

  // implements Message ----------------------------------------------

  MaterialsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaterialsRequest& from);
  void MergeFrom(const MaterialsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.MaterialsRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static MaterialsRequest* default_instance_;
};
// -------------------------------------------------------------------

class Material : public ::google::protobuf::Message {
 public:
  Material();
  virtual ~Material();

  Material(const Material& from);

  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Material& default_instance();

  void Swap(Material* other);

  // implements Message ----------------------------------------------

  Material* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 material_id = 1;
  inline bool has_material_id() const;
  inline void clear_material_id();
  static const int kMaterialIdFieldNumber = 1;
  inline ::google::protobuf::int32 material_id() const;
  inline void set_material_id(::google::protobuf::int32 value);

  // optional string english_name = 2;
  inline bool has_english_name() const;
  inline void clear_english_name();
  static const int kEnglishNameFieldNumber = 2;
  inline const ::std::string& english_name() const;
  inline void set_english_name(const ::std::string& value);
  inline void set_english_name(const char* value);
  inline void set_english_name(const char* value, size_t size);
  inline ::std::string* mutable_english_name();
  inline ::std::string* release_english_name();
  inline void set_allocated_english_name(::std::string* english_name);

  // optional string chinese_name = 3;
  inline bool has_chinese_name() const;
  inline void clear_chinese_name();
  static const int kChineseNameFieldNumber = 3;
  inline const ::std::string& chinese_name() const;
  inline void set_chinese_name(const ::std::string& value);
  inline void set_chinese_name(const char* value);
  inline void set_chinese_name(const char* value, size_t size);
  inline ::std::string* mutable_chinese_name();
  inline ::std::string* release_chinese_name();
  inline void set_allocated_chinese_name(::std::string* chinese_name);

  // @@protoc_insertion_point(class_scope:zaoxun.Material)
 private:
  inline void set_has_material_id();
  inline void clear_has_material_id();
  inline void set_has_english_name();
  inline void clear_has_english_name();
  inline void set_has_chinese_name();
  inline void clear_has_chinese_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* english_name_;
  ::std::string* chinese_name_;
  ::google::protobuf::int32 material_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Material* default_instance_;
};
// -------------------------------------------------------------------

class MaterialsResponse : public ::google::protobuf::Message {
 public:
  MaterialsResponse();
  virtual ~MaterialsResponse();

  MaterialsResponse(const MaterialsResponse& from);

  inline MaterialsResponse& operator=(const MaterialsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaterialsResponse& default_instance();

  void Swap(MaterialsResponse* other);

  // implements Message ----------------------------------------------

  MaterialsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaterialsResponse& from);
  void MergeFrom(const MaterialsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zaoxun.Material material = 1;
  inline int material_size() const;
  inline void clear_material();
  static const int kMaterialFieldNumber = 1;
  inline const ::zaoxun::Material& material(int index) const;
  inline ::zaoxun::Material* mutable_material(int index);
  inline ::zaoxun::Material* add_material();
  inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >&
      material() const;
  inline ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >*
      mutable_material();

  // @@protoc_insertion_point(class_scope:zaoxun.MaterialsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::zaoxun::Material > material_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static MaterialsResponse* default_instance_;
};
// -------------------------------------------------------------------

class MaterialsNotification : public ::google::protobuf::Message {
 public:
  MaterialsNotification();
  virtual ~MaterialsNotification();

  MaterialsNotification(const MaterialsNotification& from);

  inline MaterialsNotification& operator=(const MaterialsNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaterialsNotification& default_instance();

  void Swap(MaterialsNotification* other);

  // implements Message ----------------------------------------------

  MaterialsNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaterialsNotification& from);
  void MergeFrom(const MaterialsNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zaoxun.Material material = 1;
  inline int material_size() const;
  inline void clear_material();
  static const int kMaterialFieldNumber = 1;
  inline const ::zaoxun::Material& material(int index) const;
  inline ::zaoxun::Material* mutable_material(int index);
  inline ::zaoxun::Material* add_material();
  inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >&
      material() const;
  inline ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >*
      mutable_material();

  // @@protoc_insertion_point(class_scope:zaoxun.MaterialsNotification)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::zaoxun::Material > material_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static MaterialsNotification* default_instance_;
};
// -------------------------------------------------------------------

class CollisionCarInfo : public ::google::protobuf::Message {
 public:
  CollisionCarInfo();
  virtual ~CollisionCarInfo();

  CollisionCarInfo(const CollisionCarInfo& from);

  inline CollisionCarInfo& operator=(const CollisionCarInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionCarInfo& default_instance();

  void Swap(CollisionCarInfo* other);

  // implements Message ----------------------------------------------

  CollisionCarInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionCarInfo& from);
  void MergeFrom(const CollisionCarInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional .zaoxun.CarType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::zaoxun::CarType type() const;
  inline void set_type(::zaoxun::CarType value);

  // optional string car_no = 3;
  inline bool has_car_no() const;
  inline void clear_car_no();
  static const int kCarNoFieldNumber = 3;
  inline const ::std::string& car_no() const;
  inline void set_car_no(const ::std::string& value);
  inline void set_car_no(const char* value);
  inline void set_car_no(const char* value, size_t size);
  inline ::std::string* mutable_car_no();
  inline ::std::string* release_car_no();
  inline void set_allocated_car_no(::std::string* car_no);

  // optional int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional double distance = 5;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 5;
  inline double distance() const;
  inline void set_distance(double value);

  // optional double longitude = 6;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 6;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional double latitude = 7;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 7;
  inline double latitude() const;
  inline void set_latitude(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.CollisionCarInfo)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_car_no();
  inline void clear_has_car_no();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* car_no_;
  int type_;
  ::google::protobuf::int32 level_;
  double distance_;
  double longitude_;
  double latitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CollisionCarInfo* default_instance_;
};
// -------------------------------------------------------------------

class AntiCollisionNotification : public ::google::protobuf::Message {
 public:
  AntiCollisionNotification();
  virtual ~AntiCollisionNotification();

  AntiCollisionNotification(const AntiCollisionNotification& from);

  inline AntiCollisionNotification& operator=(const AntiCollisionNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntiCollisionNotification& default_instance();

  void Swap(AntiCollisionNotification* other);

  // implements Message ----------------------------------------------

  AntiCollisionNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AntiCollisionNotification& from);
  void MergeFrom(const AntiCollisionNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double angle = 1;
  inline int angle_size() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 1;
  inline double angle(int index) const;
  inline void set_angle(int index, double value);
  inline void add_angle(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      angle() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_angle();

  // @@protoc_insertion_point(class_scope:zaoxun.AntiCollisionNotification)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< double > angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static AntiCollisionNotification* default_instance_;
};
// -------------------------------------------------------------------

class EDipperInfo : public ::google::protobuf::Message {
 public:
  EDipperInfo();
  virtual ~EDipperInfo();

  EDipperInfo(const EDipperInfo& from);

  inline EDipperInfo& operator=(const EDipperInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EDipperInfo& default_instance();

  void Swap(EDipperInfo* other);

  // implements Message ----------------------------------------------

  EDipperInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EDipperInfo& from);
  void MergeFrom(const EDipperInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string device_no = 2;
  inline bool has_device_no() const;
  inline void clear_device_no();
  static const int kDeviceNoFieldNumber = 2;
  inline const ::std::string& device_no() const;
  inline void set_device_no(const ::std::string& value);
  inline void set_device_no(const char* value);
  inline void set_device_no(const char* value, size_t size);
  inline ::std::string* mutable_device_no();
  inline ::std::string* release_device_no();
  inline void set_allocated_device_no(::std::string* device_no);

  // optional double longitude = 3;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 3;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional double latitude = 4;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  inline double latitude() const;
  inline void set_latitude(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.EDipperInfo)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_device_no();
  inline void clear_has_device_no();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* device_no_;
  double longitude_;
  double latitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static EDipperInfo* default_instance_;
};
// -------------------------------------------------------------------

class EDipperInfoNotification : public ::google::protobuf::Message {
 public:
  EDipperInfoNotification();
  virtual ~EDipperInfoNotification();

  EDipperInfoNotification(const EDipperInfoNotification& from);

  inline EDipperInfoNotification& operator=(const EDipperInfoNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EDipperInfoNotification& default_instance();

  void Swap(EDipperInfoNotification* other);

  // implements Message ----------------------------------------------

  EDipperInfoNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EDipperInfoNotification& from);
  void MergeFrom(const EDipperInfoNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zaoxun.EDipperInfo infos = 1;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 1;
  inline const ::zaoxun::EDipperInfo& infos(int index) const;
  inline ::zaoxun::EDipperInfo* mutable_infos(int index);
  inline ::zaoxun::EDipperInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:zaoxun.EDipperInfoNotification)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo > infos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static EDipperInfoNotification* default_instance_;
};
// -------------------------------------------------------------------

class GetEDippersRequest : public ::google::protobuf::Message {
 public:
  GetEDippersRequest();
  virtual ~GetEDippersRequest();

  GetEDippersRequest(const GetEDippersRequest& from);

  inline GetEDippersRequest& operator=(const GetEDippersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEDippersRequest& default_instance();

  void Swap(GetEDippersRequest* other);

  // implements Message ----------------------------------------------

  GetEDippersRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEDippersRequest& from);
  void MergeFrom(const GetEDippersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.GetEDippersRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static GetEDippersRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetEDippersResponse : public ::google::protobuf::Message {
 public:
  GetEDippersResponse();
  virtual ~GetEDippersResponse();

  GetEDippersResponse(const GetEDippersResponse& from);

  inline GetEDippersResponse& operator=(const GetEDippersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEDippersResponse& default_instance();

  void Swap(GetEDippersResponse* other);

  // implements Message ----------------------------------------------

  GetEDippersResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEDippersResponse& from);
  void MergeFrom(const GetEDippersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // repeated .zaoxun.EDipperInfo edippers = 2;
  inline int edippers_size() const;
  inline void clear_edippers();
  static const int kEdippersFieldNumber = 2;
  inline const ::zaoxun::EDipperInfo& edippers(int index) const;
  inline ::zaoxun::EDipperInfo* mutable_edippers(int index);
  inline ::zaoxun::EDipperInfo* add_edippers();
  inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >&
      edippers() const;
  inline ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >*
      mutable_edippers();

  // @@protoc_insertion_point(class_scope:zaoxun.GetEDippersResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo > edippers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static GetEDippersResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoadCompleteRequest : public ::google::protobuf::Message {
 public:
  LoadCompleteRequest();
  virtual ~LoadCompleteRequest();

  LoadCompleteRequest(const LoadCompleteRequest& from);

  inline LoadCompleteRequest& operator=(const LoadCompleteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadCompleteRequest& default_instance();

  void Swap(LoadCompleteRequest* other);

  // implements Message ----------------------------------------------

  LoadCompleteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadCompleteRequest& from);
  void MergeFrom(const LoadCompleteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string edipper_device_id = 1;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 1;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional string car_device_id = 2;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 2;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // optional int32 load_result = 3;
  inline bool has_load_result() const;
  inline void clear_load_result();
  static const int kLoadResultFieldNumber = 3;
  inline ::google::protobuf::int32 load_result() const;
  inline void set_load_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.LoadCompleteRequest)
 private:
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();
  inline void set_has_load_result();
  inline void clear_has_load_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* edipper_device_id_;
  ::std::string* car_device_id_;
  ::google::protobuf::int32 load_result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static LoadCompleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoadCompleteResponse : public ::google::protobuf::Message {
 public:
  LoadCompleteResponse();
  virtual ~LoadCompleteResponse();

  LoadCompleteResponse(const LoadCompleteResponse& from);

  inline LoadCompleteResponse& operator=(const LoadCompleteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadCompleteResponse& default_instance();

  void Swap(LoadCompleteResponse* other);

  // implements Message ----------------------------------------------

  LoadCompleteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadCompleteResponse& from);
  void MergeFrom(const LoadCompleteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string edipper_device_id = 1;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 1;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional string car_device_id = 2;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 2;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // optional int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.LoadCompleteResponse)
 private:
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* edipper_device_id_;
  ::std::string* car_device_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static LoadCompleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class ManualLoadCompleteRequest : public ::google::protobuf::Message {
 public:
  ManualLoadCompleteRequest();
  virtual ~ManualLoadCompleteRequest();

  ManualLoadCompleteRequest(const ManualLoadCompleteRequest& from);

  inline ManualLoadCompleteRequest& operator=(const ManualLoadCompleteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManualLoadCompleteRequest& default_instance();

  void Swap(ManualLoadCompleteRequest* other);

  // implements Message ----------------------------------------------

  ManualLoadCompleteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManualLoadCompleteRequest& from);
  void MergeFrom(const ManualLoadCompleteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string edipper_device_id = 1;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 1;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional string car_device_id = 2;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 2;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // optional int32 material_id = 3;
  inline bool has_material_id() const;
  inline void clear_material_id();
  static const int kMaterialIdFieldNumber = 3;
  inline ::google::protobuf::int32 material_id() const;
  inline void set_material_id(::google::protobuf::int32 value);

  // optional int32 load_result = 4;
  inline bool has_load_result() const;
  inline void clear_load_result();
  static const int kLoadResultFieldNumber = 4;
  inline ::google::protobuf::int32 load_result() const;
  inline void set_load_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.ManualLoadCompleteRequest)
 private:
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();
  inline void set_has_material_id();
  inline void clear_has_material_id();
  inline void set_has_load_result();
  inline void clear_has_load_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* edipper_device_id_;
  ::std::string* car_device_id_;
  ::google::protobuf::int32 material_id_;
  ::google::protobuf::int32 load_result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ManualLoadCompleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class ManualLoadCompleteResponse : public ::google::protobuf::Message {
 public:
  ManualLoadCompleteResponse();
  virtual ~ManualLoadCompleteResponse();

  ManualLoadCompleteResponse(const ManualLoadCompleteResponse& from);

  inline ManualLoadCompleteResponse& operator=(const ManualLoadCompleteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManualLoadCompleteResponse& default_instance();

  void Swap(ManualLoadCompleteResponse* other);

  // implements Message ----------------------------------------------

  ManualLoadCompleteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManualLoadCompleteResponse& from);
  void MergeFrom(const ManualLoadCompleteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string edipper_device_id = 1;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 1;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional string car_device_id = 2;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 2;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // optional int32 material_id = 3;
  inline bool has_material_id() const;
  inline void clear_material_id();
  static const int kMaterialIdFieldNumber = 3;
  inline ::google::protobuf::int32 material_id() const;
  inline void set_material_id(::google::protobuf::int32 value);

  // optional int32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.ManualLoadCompleteResponse)
 private:
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();
  inline void set_has_material_id();
  inline void clear_has_material_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* edipper_device_id_;
  ::std::string* car_device_id_;
  ::google::protobuf::int32 material_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ManualLoadCompleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class CancelLoadRequest : public ::google::protobuf::Message {
 public:
  CancelLoadRequest();
  virtual ~CancelLoadRequest();

  CancelLoadRequest(const CancelLoadRequest& from);

  inline CancelLoadRequest& operator=(const CancelLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelLoadRequest& default_instance();

  void Swap(CancelLoadRequest* other);

  // implements Message ----------------------------------------------

  CancelLoadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelLoadRequest& from);
  void MergeFrom(const CancelLoadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string car_device_id = 1;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 1;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.CancelLoadRequest)
 private:
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* car_device_id_;
  ::std::string* edipper_device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CancelLoadRequest* default_instance_;
};
// -------------------------------------------------------------------

class CancelLoadResponse : public ::google::protobuf::Message {
 public:
  CancelLoadResponse();
  virtual ~CancelLoadResponse();

  CancelLoadResponse(const CancelLoadResponse& from);

  inline CancelLoadResponse& operator=(const CancelLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelLoadResponse& default_instance();

  void Swap(CancelLoadResponse* other);

  // implements Message ----------------------------------------------

  CancelLoadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelLoadResponse& from);
  void MergeFrom(const CancelLoadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string car_device_id = 1;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 1;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // optional string edipper_device_id = 2;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 2;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.CancelLoadResponse)
 private:
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* car_device_id_;
  ::std::string* edipper_device_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CancelLoadResponse* default_instance_;
};
// -------------------------------------------------------------------

class RejectLoadRequest : public ::google::protobuf::Message {
 public:
  RejectLoadRequest();
  virtual ~RejectLoadRequest();

  RejectLoadRequest(const RejectLoadRequest& from);

  inline RejectLoadRequest& operator=(const RejectLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RejectLoadRequest& default_instance();

  void Swap(RejectLoadRequest* other);

  // implements Message ----------------------------------------------

  RejectLoadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RejectLoadRequest& from);
  void MergeFrom(const RejectLoadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string edipper_device_id = 1;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 1;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional string car_device_id = 2;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 2;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.RejectLoadRequest)
 private:
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* edipper_device_id_;
  ::std::string* car_device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static RejectLoadRequest* default_instance_;
};
// -------------------------------------------------------------------

class RejectLoadResponse : public ::google::protobuf::Message {
 public:
  RejectLoadResponse();
  virtual ~RejectLoadResponse();

  RejectLoadResponse(const RejectLoadResponse& from);

  inline RejectLoadResponse& operator=(const RejectLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RejectLoadResponse& default_instance();

  void Swap(RejectLoadResponse* other);

  // implements Message ----------------------------------------------

  RejectLoadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RejectLoadResponse& from);
  void MergeFrom(const RejectLoadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string edipper_device_id = 1;
  inline bool has_edipper_device_id() const;
  inline void clear_edipper_device_id();
  static const int kEdipperDeviceIdFieldNumber = 1;
  inline const ::std::string& edipper_device_id() const;
  inline void set_edipper_device_id(const ::std::string& value);
  inline void set_edipper_device_id(const char* value);
  inline void set_edipper_device_id(const char* value, size_t size);
  inline ::std::string* mutable_edipper_device_id();
  inline ::std::string* release_edipper_device_id();
  inline void set_allocated_edipper_device_id(::std::string* edipper_device_id);

  // optional string car_device_id = 2;
  inline bool has_car_device_id() const;
  inline void clear_car_device_id();
  static const int kCarDeviceIdFieldNumber = 2;
  inline const ::std::string& car_device_id() const;
  inline void set_car_device_id(const ::std::string& value);
  inline void set_car_device_id(const char* value);
  inline void set_car_device_id(const char* value, size_t size);
  inline ::std::string* mutable_car_device_id();
  inline ::std::string* release_car_device_id();
  inline void set_allocated_car_device_id(::std::string* car_device_id);

  // optional int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.RejectLoadResponse)
 private:
  inline void set_has_edipper_device_id();
  inline void clear_has_edipper_device_id();
  inline void set_has_car_device_id();
  inline void clear_has_car_device_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* edipper_device_id_;
  ::std::string* car_device_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static RejectLoadResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExitNotification : public ::google::protobuf::Message {
 public:
  ExitNotification();
  virtual ~ExitNotification();

  ExitNotification(const ExitNotification& from);

  inline ExitNotification& operator=(const ExitNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExitNotification& default_instance();

  void Swap(ExitNotification* other);

  // implements Message ----------------------------------------------

  ExitNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExitNotification& from);
  void MergeFrom(const ExitNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 exit_type = 2;
  inline bool has_exit_type() const;
  inline void clear_exit_type();
  static const int kExitTypeFieldNumber = 2;
  inline ::google::protobuf::int32 exit_type() const;
  inline void set_exit_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.ExitNotification)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_exit_type();
  inline void clear_has_exit_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 exit_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ExitNotification* default_instance_;
};
// -------------------------------------------------------------------

class DeviceStatusRequest : public ::google::protobuf::Message {
 public:
  DeviceStatusRequest();
  virtual ~DeviceStatusRequest();

  DeviceStatusRequest(const DeviceStatusRequest& from);

  inline DeviceStatusRequest& operator=(const DeviceStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceStatusRequest& default_instance();

  void Swap(DeviceStatusRequest* other);

  // implements Message ----------------------------------------------

  DeviceStatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceStatusRequest& from);
  void MergeFrom(const DeviceStatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional .zaoxun.RunningStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::zaoxun::RunningStatus status() const;
  inline void set_status(::zaoxun::RunningStatus value);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 update_time = 4;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 4;
  inline ::google::protobuf::int32 update_time() const;
  inline void set_update_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.DeviceStatusRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  int status_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 update_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static DeviceStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeviceStatusResponse : public ::google::protobuf::Message {
 public:
  DeviceStatusResponse();
  virtual ~DeviceStatusResponse();

  DeviceStatusResponse(const DeviceStatusResponse& from);

  inline DeviceStatusResponse& operator=(const DeviceStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceStatusResponse& default_instance();

  void Swap(DeviceStatusResponse* other);

  // implements Message ----------------------------------------------

  DeviceStatusResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceStatusResponse& from);
  void MergeFrom(const DeviceStatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 update_time = 3;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 3;
  inline ::google::protobuf::int32 update_time() const;
  inline void set_update_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.DeviceStatusResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 update_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static DeviceStatusResponse* default_instance_;
};
// -------------------------------------------------------------------

class CommandRequest : public ::google::protobuf::Message {
 public:
  CommandRequest();
  virtual ~CommandRequest();

  CommandRequest(const CommandRequest& from);

  inline CommandRequest& operator=(const CommandRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRequest& default_instance();

  void Swap(CommandRequest* other);

  // implements Message ----------------------------------------------

  CommandRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRequest& from);
  void MergeFrom(const CommandRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 cmd_id = 2;
  inline bool has_cmd_id() const;
  inline void clear_cmd_id();
  static const int kCmdIdFieldNumber = 2;
  inline ::google::protobuf::int32 cmd_id() const;
  inline void set_cmd_id(::google::protobuf::int32 value);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:zaoxun.CommandRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_cmd_id();
  inline void clear_has_cmd_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 cmd_id_;
  ::google::protobuf::int32 type_;
  ::std::string* time_;
  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class CommandResponse : public ::google::protobuf::Message {
 public:
  CommandResponse();
  virtual ~CommandResponse();

  CommandResponse(const CommandResponse& from);

  inline CommandResponse& operator=(const CommandResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandResponse& default_instance();

  void Swap(CommandResponse* other);

  // implements Message ----------------------------------------------

  CommandResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandResponse& from);
  void MergeFrom(const CommandResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 cmd_id = 2;
  inline bool has_cmd_id() const;
  inline void clear_cmd_id();
  static const int kCmdIdFieldNumber = 2;
  inline ::google::protobuf::int32 cmd_id() const;
  inline void set_cmd_id(::google::protobuf::int32 value);

  // optional int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.CommandResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_cmd_id();
  inline void clear_has_cmd_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int32 cmd_id_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CommandResponse* default_instance_;
};
// -------------------------------------------------------------------

class ProductionInfoRequest : public ::google::protobuf::Message {
 public:
  ProductionInfoRequest();
  virtual ~ProductionInfoRequest();

  ProductionInfoRequest(const ProductionInfoRequest& from);

  inline ProductionInfoRequest& operator=(const ProductionInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductionInfoRequest& default_instance();

  void Swap(ProductionInfoRequest* other);

  // implements Message ----------------------------------------------

  ProductionInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductionInfoRequest& from);
  void MergeFrom(const ProductionInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:zaoxun.ProductionInfoRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ProductionInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class ProductionInfoResponse : public ::google::protobuf::Message {
 public:
  ProductionInfoResponse();
  virtual ~ProductionInfoResponse();

  ProductionInfoResponse(const ProductionInfoResponse& from);

  inline ProductionInfoResponse& operator=(const ProductionInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductionInfoResponse& default_instance();

  void Swap(ProductionInfoResponse* other);

  // implements Message ----------------------------------------------

  ProductionInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductionInfoResponse& from);
  void MergeFrom(const ProductionInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int32 times = 2;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 2;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // optional double distance = 3;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 3;
  inline double distance() const;
  inline void set_distance(double value);

  // optional double ton = 4;
  inline bool has_ton() const;
  inline void clear_ton();
  static const int kTonFieldNumber = 4;
  inline double ton() const;
  inline void set_ton(double value);

  // optional double fill = 5;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 5;
  inline double fill() const;
  inline void set_fill(double value);

  // optional double temp = 6;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 6;
  inline double temp() const;
  inline void set_temp(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.ProductionInfoResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_ton();
  inline void clear_has_ton();
  inline void set_has_fill();
  inline void clear_has_fill();
  inline void set_has_temp();
  inline void clear_has_temp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  double distance_;
  double ton_;
  double fill_;
  double temp_;
  ::google::protobuf::int32 times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static ProductionInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class FuelRequest : public ::google::protobuf::Message {
 public:
  FuelRequest();
  virtual ~FuelRequest();

  FuelRequest(const FuelRequest& from);

  inline FuelRequest& operator=(const FuelRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FuelRequest& default_instance();

  void Swap(FuelRequest* other);

  // implements Message ----------------------------------------------

  FuelRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FuelRequest& from);
  void MergeFrom(const FuelRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string target_device_name = 2;
  inline bool has_target_device_name() const;
  inline void clear_target_device_name();
  static const int kTargetDeviceNameFieldNumber = 2;
  inline const ::std::string& target_device_name() const;
  inline void set_target_device_name(const ::std::string& value);
  inline void set_target_device_name(const char* value);
  inline void set_target_device_name(const char* value, size_t size);
  inline ::std::string* mutable_target_device_name();
  inline ::std::string* release_target_device_name();
  inline void set_allocated_target_device_name(::std::string* target_device_name);

  // optional double volume = 3;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 3;
  inline double volume() const;
  inline void set_volume(double value);

  // optional int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 mode = 5;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 5;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.FuelRequest)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_target_device_name();
  inline void clear_has_target_device_name();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* target_device_name_;
  double volume_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static FuelRequest* default_instance_;
};
// -------------------------------------------------------------------

class FuelResponse : public ::google::protobuf::Message {
 public:
  FuelResponse();
  virtual ~FuelResponse();

  FuelResponse(const FuelResponse& from);

  inline FuelResponse& operator=(const FuelResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FuelResponse& default_instance();

  void Swap(FuelResponse* other);

  // implements Message ----------------------------------------------

  FuelResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FuelResponse& from);
  void MergeFrom(const FuelResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string target_device_name = 2;
  inline bool has_target_device_name() const;
  inline void clear_target_device_name();
  static const int kTargetDeviceNameFieldNumber = 2;
  inline const ::std::string& target_device_name() const;
  inline void set_target_device_name(const ::std::string& value);
  inline void set_target_device_name(const char* value);
  inline void set_target_device_name(const char* value, size_t size);
  inline ::std::string* mutable_target_device_name();
  inline ::std::string* release_target_device_name();
  inline void set_allocated_target_device_name(::std::string* target_device_name);

  // optional double volume = 3;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 3;
  inline double volume() const;
  inline void set_volume(double value);

  // optional int32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.FuelResponse)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_target_device_name();
  inline void clear_has_target_device_name();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::std::string* target_device_name_;
  double volume_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static FuelResponse* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeat : public ::google::protobuf::Message {
 public:
  HeartBeat();
  virtual ~HeartBeat();

  HeartBeat(const HeartBeat& from);

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeat& default_instance();

  void Swap(HeartBeat* other);

  // implements Message ----------------------------------------------

  HeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeat& from);
  void MergeFrom(const HeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:zaoxun.HeartBeat)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static HeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class TargetNotification : public ::google::protobuf::Message {
 public:
  TargetNotification();
  virtual ~TargetNotification();

  TargetNotification(const TargetNotification& from);

  inline TargetNotification& operator=(const TargetNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetNotification& default_instance();

  void Swap(TargetNotification* other);

  // implements Message ----------------------------------------------

  TargetNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetNotification& from);
  void MergeFrom(const TargetNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional double latitude = 3;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 3;
  inline double latitude() const;
  inline void set_latitude(double value);

  // @@protoc_insertion_point(class_scope:zaoxun.TargetNotification)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  double longitude_;
  double latitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static TargetNotification* default_instance_;
};
// -------------------------------------------------------------------

class CommonMessage : public ::google::protobuf::Message {
 public:
  CommonMessage();
  virtual ~CommonMessage();

  CommonMessage(const CommonMessage& from);

  inline CommonMessage& operator=(const CommonMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonMessage& default_instance();

  void Swap(CommonMessage* other);

  // implements Message ----------------------------------------------

  CommonMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonMessage& from);
  void MergeFrom(const CommonMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zaoxun.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::zaoxun::MessageType type() const;
  inline void set_type(::zaoxun::MessageType value);

  // optional .zaoxun.LoginRequest login_request = 2;
  inline bool has_login_request() const;
  inline void clear_login_request();
  static const int kLoginRequestFieldNumber = 2;
  inline const ::zaoxun::LoginRequest& login_request() const;
  inline ::zaoxun::LoginRequest* mutable_login_request();
  inline ::zaoxun::LoginRequest* release_login_request();
  inline void set_allocated_login_request(::zaoxun::LoginRequest* login_request);

  // optional .zaoxun.LoginResponse login_response = 3;
  inline bool has_login_response() const;
  inline void clear_login_response();
  static const int kLoginResponseFieldNumber = 3;
  inline const ::zaoxun::LoginResponse& login_response() const;
  inline ::zaoxun::LoginResponse* mutable_login_response();
  inline ::zaoxun::LoginResponse* release_login_response();
  inline void set_allocated_login_response(::zaoxun::LoginResponse* login_response);

  // optional .zaoxun.CheckRequest check_request = 4;
  inline bool has_check_request() const;
  inline void clear_check_request();
  static const int kCheckRequestFieldNumber = 4;
  inline const ::zaoxun::CheckRequest& check_request() const;
  inline ::zaoxun::CheckRequest* mutable_check_request();
  inline ::zaoxun::CheckRequest* release_check_request();
  inline void set_allocated_check_request(::zaoxun::CheckRequest* check_request);

  // optional .zaoxun.CheckResponse check_response = 5;
  inline bool has_check_response() const;
  inline void clear_check_response();
  static const int kCheckResponseFieldNumber = 5;
  inline const ::zaoxun::CheckResponse& check_response() const;
  inline ::zaoxun::CheckResponse* mutable_check_response();
  inline ::zaoxun::CheckResponse* release_check_response();
  inline void set_allocated_check_response(::zaoxun::CheckResponse* check_response);

  // optional .zaoxun.OilQuantityRequest oil_quantity_request = 6;
  inline bool has_oil_quantity_request() const;
  inline void clear_oil_quantity_request();
  static const int kOilQuantityRequestFieldNumber = 6;
  inline const ::zaoxun::OilQuantityRequest& oil_quantity_request() const;
  inline ::zaoxun::OilQuantityRequest* mutable_oil_quantity_request();
  inline ::zaoxun::OilQuantityRequest* release_oil_quantity_request();
  inline void set_allocated_oil_quantity_request(::zaoxun::OilQuantityRequest* oil_quantity_request);

  // optional .zaoxun.OilQuantityResponse oil_quantity_response = 7;
  inline bool has_oil_quantity_response() const;
  inline void clear_oil_quantity_response();
  static const int kOilQuantityResponseFieldNumber = 7;
  inline const ::zaoxun::OilQuantityResponse& oil_quantity_response() const;
  inline ::zaoxun::OilQuantityResponse* mutable_oil_quantity_response();
  inline ::zaoxun::OilQuantityResponse* release_oil_quantity_response();
  inline void set_allocated_oil_quantity_response(::zaoxun::OilQuantityResponse* oil_quantity_response);

  // optional .zaoxun.ProductionRequest production_request = 8;
  inline bool has_production_request() const;
  inline void clear_production_request();
  static const int kProductionRequestFieldNumber = 8;
  inline const ::zaoxun::ProductionRequest& production_request() const;
  inline ::zaoxun::ProductionRequest* mutable_production_request();
  inline ::zaoxun::ProductionRequest* release_production_request();
  inline void set_allocated_production_request(::zaoxun::ProductionRequest* production_request);

  // optional .zaoxun.ProductionResponse production_response = 9;
  inline bool has_production_response() const;
  inline void clear_production_response();
  static const int kProductionResponseFieldNumber = 9;
  inline const ::zaoxun::ProductionResponse& production_response() const;
  inline ::zaoxun::ProductionResponse* mutable_production_response();
  inline ::zaoxun::ProductionResponse* release_production_response();
  inline void set_allocated_production_response(::zaoxun::ProductionResponse* production_response);

  // optional .zaoxun.DistanceRequest distance_request = 10;
  inline bool has_distance_request() const;
  inline void clear_distance_request();
  static const int kDistanceRequestFieldNumber = 10;
  inline const ::zaoxun::DistanceRequest& distance_request() const;
  inline ::zaoxun::DistanceRequest* mutable_distance_request();
  inline ::zaoxun::DistanceRequest* release_distance_request();
  inline void set_allocated_distance_request(::zaoxun::DistanceRequest* distance_request);

  // optional .zaoxun.DistanceResponse distance_response = 11;
  inline bool has_distance_response() const;
  inline void clear_distance_response();
  static const int kDistanceResponseFieldNumber = 11;
  inline const ::zaoxun::DistanceResponse& distance_response() const;
  inline ::zaoxun::DistanceResponse* mutable_distance_response();
  inline ::zaoxun::DistanceResponse* release_distance_response();
  inline void set_allocated_distance_response(::zaoxun::DistanceResponse* distance_response);

  // optional .zaoxun.TimesRequest times_request = 12;
  inline bool has_times_request() const;
  inline void clear_times_request();
  static const int kTimesRequestFieldNumber = 12;
  inline const ::zaoxun::TimesRequest& times_request() const;
  inline ::zaoxun::TimesRequest* mutable_times_request();
  inline ::zaoxun::TimesRequest* release_times_request();
  inline void set_allocated_times_request(::zaoxun::TimesRequest* times_request);

  // optional .zaoxun.TimesResponse times_response = 13;
  inline bool has_times_response() const;
  inline void clear_times_response();
  static const int kTimesResponseFieldNumber = 13;
  inline const ::zaoxun::TimesResponse& times_response() const;
  inline ::zaoxun::TimesResponse* mutable_times_response();
  inline ::zaoxun::TimesResponse* release_times_response();
  inline void set_allocated_times_response(::zaoxun::TimesResponse* times_response);

  // optional .zaoxun.OilingRequest oiling_request = 14;
  inline bool has_oiling_request() const;
  inline void clear_oiling_request();
  static const int kOilingRequestFieldNumber = 14;
  inline const ::zaoxun::OilingRequest& oiling_request() const;
  inline ::zaoxun::OilingRequest* mutable_oiling_request();
  inline ::zaoxun::OilingRequest* release_oiling_request();
  inline void set_allocated_oiling_request(::zaoxun::OilingRequest* oiling_request);

  // optional .zaoxun.OilingResponse oiling_response = 15;
  inline bool has_oiling_response() const;
  inline void clear_oiling_response();
  static const int kOilingResponseFieldNumber = 15;
  inline const ::zaoxun::OilingResponse& oiling_response() const;
  inline ::zaoxun::OilingResponse* mutable_oiling_response();
  inline ::zaoxun::OilingResponse* release_oiling_response();
  inline void set_allocated_oiling_response(::zaoxun::OilingResponse* oiling_response);

  // optional .zaoxun.LoadRequest load_request = 16;
  inline bool has_load_request() const;
  inline void clear_load_request();
  static const int kLoadRequestFieldNumber = 16;
  inline const ::zaoxun::LoadRequest& load_request() const;
  inline ::zaoxun::LoadRequest* mutable_load_request();
  inline ::zaoxun::LoadRequest* release_load_request();
  inline void set_allocated_load_request(::zaoxun::LoadRequest* load_request);

  // optional .zaoxun.LoadResponse load_response = 17;
  inline bool has_load_response() const;
  inline void clear_load_response();
  static const int kLoadResponseFieldNumber = 17;
  inline const ::zaoxun::LoadResponse& load_response() const;
  inline ::zaoxun::LoadResponse* mutable_load_response();
  inline ::zaoxun::LoadResponse* release_load_response();
  inline void set_allocated_load_response(::zaoxun::LoadResponse* load_response);

  // optional .zaoxun.UnloadRequest unload_request = 18;
  inline bool has_unload_request() const;
  inline void clear_unload_request();
  static const int kUnloadRequestFieldNumber = 18;
  inline const ::zaoxun::UnloadRequest& unload_request() const;
  inline ::zaoxun::UnloadRequest* mutable_unload_request();
  inline ::zaoxun::UnloadRequest* release_unload_request();
  inline void set_allocated_unload_request(::zaoxun::UnloadRequest* unload_request);

  // optional .zaoxun.UnloadResponse unload_response = 19;
  inline bool has_unload_response() const;
  inline void clear_unload_response();
  static const int kUnloadResponseFieldNumber = 19;
  inline const ::zaoxun::UnloadResponse& unload_response() const;
  inline ::zaoxun::UnloadResponse* mutable_unload_response();
  inline ::zaoxun::UnloadResponse* release_unload_response();
  inline void set_allocated_unload_response(::zaoxun::UnloadResponse* unload_response);

  // optional .zaoxun.SpeedLimitMessage speed_limit = 20;
  inline bool has_speed_limit() const;
  inline void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 20;
  inline const ::zaoxun::SpeedLimitMessage& speed_limit() const;
  inline ::zaoxun::SpeedLimitMessage* mutable_speed_limit();
  inline ::zaoxun::SpeedLimitMessage* release_speed_limit();
  inline void set_allocated_speed_limit(::zaoxun::SpeedLimitMessage* speed_limit);

  // optional .zaoxun.ShortMessage short_message = 21;
  inline bool has_short_message() const;
  inline void clear_short_message();
  static const int kShortMessageFieldNumber = 21;
  inline const ::zaoxun::ShortMessage& short_message() const;
  inline ::zaoxun::ShortMessage* mutable_short_message();
  inline ::zaoxun::ShortMessage* release_short_message();
  inline void set_allocated_short_message(::zaoxun::ShortMessage* short_message);

  // optional .zaoxun.GPSData gps_data = 22;
  inline bool has_gps_data() const;
  inline void clear_gps_data();
  static const int kGpsDataFieldNumber = 22;
  inline const ::zaoxun::GPSData& gps_data() const;
  inline ::zaoxun::GPSData* mutable_gps_data();
  inline ::zaoxun::GPSData* release_gps_data();
  inline void set_allocated_gps_data(::zaoxun::GPSData* gps_data);

  // optional .zaoxun.AudioFileData audio_file_data = 23;
  inline bool has_audio_file_data() const;
  inline void clear_audio_file_data();
  static const int kAudioFileDataFieldNumber = 23;
  inline const ::zaoxun::AudioFileData& audio_file_data() const;
  inline ::zaoxun::AudioFileData* mutable_audio_file_data();
  inline ::zaoxun::AudioFileData* release_audio_file_data();
  inline void set_allocated_audio_file_data(::zaoxun::AudioFileData* audio_file_data);

  // optional .zaoxun.CaptureFileData capture_file_data = 24;
  inline bool has_capture_file_data() const;
  inline void clear_capture_file_data();
  static const int kCaptureFileDataFieldNumber = 24;
  inline const ::zaoxun::CaptureFileData& capture_file_data() const;
  inline ::zaoxun::CaptureFileData* mutable_capture_file_data();
  inline ::zaoxun::CaptureFileData* release_capture_file_data();
  inline void set_allocated_capture_file_data(::zaoxun::CaptureFileData* capture_file_data);

  // optional .zaoxun.MaterialsNotification materials_notification = 25;
  inline bool has_materials_notification() const;
  inline void clear_materials_notification();
  static const int kMaterialsNotificationFieldNumber = 25;
  inline const ::zaoxun::MaterialsNotification& materials_notification() const;
  inline ::zaoxun::MaterialsNotification* mutable_materials_notification();
  inline ::zaoxun::MaterialsNotification* release_materials_notification();
  inline void set_allocated_materials_notification(::zaoxun::MaterialsNotification* materials_notification);

  // optional .zaoxun.AntiCollisionNotification anticollision_notification = 26;
  inline bool has_anticollision_notification() const;
  inline void clear_anticollision_notification();
  static const int kAnticollisionNotificationFieldNumber = 26;
  inline const ::zaoxun::AntiCollisionNotification& anticollision_notification() const;
  inline ::zaoxun::AntiCollisionNotification* mutable_anticollision_notification();
  inline ::zaoxun::AntiCollisionNotification* release_anticollision_notification();
  inline void set_allocated_anticollision_notification(::zaoxun::AntiCollisionNotification* anticollision_notification);

  // optional .zaoxun.EDipperInfoNotification edipperinfo_notification = 27;
  inline bool has_edipperinfo_notification() const;
  inline void clear_edipperinfo_notification();
  static const int kEdipperinfoNotificationFieldNumber = 27;
  inline const ::zaoxun::EDipperInfoNotification& edipperinfo_notification() const;
  inline ::zaoxun::EDipperInfoNotification* mutable_edipperinfo_notification();
  inline ::zaoxun::EDipperInfoNotification* release_edipperinfo_notification();
  inline void set_allocated_edipperinfo_notification(::zaoxun::EDipperInfoNotification* edipperinfo_notification);

  // optional .zaoxun.GetEDippersRequest get_edippers_request = 28;
  inline bool has_get_edippers_request() const;
  inline void clear_get_edippers_request();
  static const int kGetEdippersRequestFieldNumber = 28;
  inline const ::zaoxun::GetEDippersRequest& get_edippers_request() const;
  inline ::zaoxun::GetEDippersRequest* mutable_get_edippers_request();
  inline ::zaoxun::GetEDippersRequest* release_get_edippers_request();
  inline void set_allocated_get_edippers_request(::zaoxun::GetEDippersRequest* get_edippers_request);

  // optional .zaoxun.GetEDippersResponse get_edippers_response = 29;
  inline bool has_get_edippers_response() const;
  inline void clear_get_edippers_response();
  static const int kGetEdippersResponseFieldNumber = 29;
  inline const ::zaoxun::GetEDippersResponse& get_edippers_response() const;
  inline ::zaoxun::GetEDippersResponse* mutable_get_edippers_response();
  inline ::zaoxun::GetEDippersResponse* release_get_edippers_response();
  inline void set_allocated_get_edippers_response(::zaoxun::GetEDippersResponse* get_edippers_response);

  // optional .zaoxun.LoadCompleteRequest load_complete_request = 30;
  inline bool has_load_complete_request() const;
  inline void clear_load_complete_request();
  static const int kLoadCompleteRequestFieldNumber = 30;
  inline const ::zaoxun::LoadCompleteRequest& load_complete_request() const;
  inline ::zaoxun::LoadCompleteRequest* mutable_load_complete_request();
  inline ::zaoxun::LoadCompleteRequest* release_load_complete_request();
  inline void set_allocated_load_complete_request(::zaoxun::LoadCompleteRequest* load_complete_request);

  // optional .zaoxun.LoadCompleteResponse load_complete_response = 31;
  inline bool has_load_complete_response() const;
  inline void clear_load_complete_response();
  static const int kLoadCompleteResponseFieldNumber = 31;
  inline const ::zaoxun::LoadCompleteResponse& load_complete_response() const;
  inline ::zaoxun::LoadCompleteResponse* mutable_load_complete_response();
  inline ::zaoxun::LoadCompleteResponse* release_load_complete_response();
  inline void set_allocated_load_complete_response(::zaoxun::LoadCompleteResponse* load_complete_response);

  // optional .zaoxun.CancelLoadRequest cancel_load_request = 32;
  inline bool has_cancel_load_request() const;
  inline void clear_cancel_load_request();
  static const int kCancelLoadRequestFieldNumber = 32;
  inline const ::zaoxun::CancelLoadRequest& cancel_load_request() const;
  inline ::zaoxun::CancelLoadRequest* mutable_cancel_load_request();
  inline ::zaoxun::CancelLoadRequest* release_cancel_load_request();
  inline void set_allocated_cancel_load_request(::zaoxun::CancelLoadRequest* cancel_load_request);

  // optional .zaoxun.CancelLoadResponse cancel_load_response = 33;
  inline bool has_cancel_load_response() const;
  inline void clear_cancel_load_response();
  static const int kCancelLoadResponseFieldNumber = 33;
  inline const ::zaoxun::CancelLoadResponse& cancel_load_response() const;
  inline ::zaoxun::CancelLoadResponse* mutable_cancel_load_response();
  inline ::zaoxun::CancelLoadResponse* release_cancel_load_response();
  inline void set_allocated_cancel_load_response(::zaoxun::CancelLoadResponse* cancel_load_response);

  // optional .zaoxun.RejectLoadRequest reject_load_request = 34;
  inline bool has_reject_load_request() const;
  inline void clear_reject_load_request();
  static const int kRejectLoadRequestFieldNumber = 34;
  inline const ::zaoxun::RejectLoadRequest& reject_load_request() const;
  inline ::zaoxun::RejectLoadRequest* mutable_reject_load_request();
  inline ::zaoxun::RejectLoadRequest* release_reject_load_request();
  inline void set_allocated_reject_load_request(::zaoxun::RejectLoadRequest* reject_load_request);

  // optional .zaoxun.RejectLoadResponse reject_load_response = 35;
  inline bool has_reject_load_response() const;
  inline void clear_reject_load_response();
  static const int kRejectLoadResponseFieldNumber = 35;
  inline const ::zaoxun::RejectLoadResponse& reject_load_response() const;
  inline ::zaoxun::RejectLoadResponse* mutable_reject_load_response();
  inline ::zaoxun::RejectLoadResponse* release_reject_load_response();
  inline void set_allocated_reject_load_response(::zaoxun::RejectLoadResponse* reject_load_response);

  // optional .zaoxun.ExitNotification exit_notification = 36;
  inline bool has_exit_notification() const;
  inline void clear_exit_notification();
  static const int kExitNotificationFieldNumber = 36;
  inline const ::zaoxun::ExitNotification& exit_notification() const;
  inline ::zaoxun::ExitNotification* mutable_exit_notification();
  inline ::zaoxun::ExitNotification* release_exit_notification();
  inline void set_allocated_exit_notification(::zaoxun::ExitNotification* exit_notification);

  // optional .zaoxun.DeviceStatusRequest device_status_request = 37;
  inline bool has_device_status_request() const;
  inline void clear_device_status_request();
  static const int kDeviceStatusRequestFieldNumber = 37;
  inline const ::zaoxun::DeviceStatusRequest& device_status_request() const;
  inline ::zaoxun::DeviceStatusRequest* mutable_device_status_request();
  inline ::zaoxun::DeviceStatusRequest* release_device_status_request();
  inline void set_allocated_device_status_request(::zaoxun::DeviceStatusRequest* device_status_request);

  // optional .zaoxun.MaterialsRequest materials_request = 38;
  inline bool has_materials_request() const;
  inline void clear_materials_request();
  static const int kMaterialsRequestFieldNumber = 38;
  inline const ::zaoxun::MaterialsRequest& materials_request() const;
  inline ::zaoxun::MaterialsRequest* mutable_materials_request();
  inline ::zaoxun::MaterialsRequest* release_materials_request();
  inline void set_allocated_materials_request(::zaoxun::MaterialsRequest* materials_request);

  // optional .zaoxun.MaterialsResponse materials_response = 39;
  inline bool has_materials_response() const;
  inline void clear_materials_response();
  static const int kMaterialsResponseFieldNumber = 39;
  inline const ::zaoxun::MaterialsResponse& materials_response() const;
  inline ::zaoxun::MaterialsResponse* mutable_materials_response();
  inline ::zaoxun::MaterialsResponse* release_materials_response();
  inline void set_allocated_materials_response(::zaoxun::MaterialsResponse* materials_response);

  // optional .zaoxun.CommandRequest command_request = 40;
  inline bool has_command_request() const;
  inline void clear_command_request();
  static const int kCommandRequestFieldNumber = 40;
  inline const ::zaoxun::CommandRequest& command_request() const;
  inline ::zaoxun::CommandRequest* mutable_command_request();
  inline ::zaoxun::CommandRequest* release_command_request();
  inline void set_allocated_command_request(::zaoxun::CommandRequest* command_request);

  // optional .zaoxun.ProductionInfoRequest production_info_request = 41;
  inline bool has_production_info_request() const;
  inline void clear_production_info_request();
  static const int kProductionInfoRequestFieldNumber = 41;
  inline const ::zaoxun::ProductionInfoRequest& production_info_request() const;
  inline ::zaoxun::ProductionInfoRequest* mutable_production_info_request();
  inline ::zaoxun::ProductionInfoRequest* release_production_info_request();
  inline void set_allocated_production_info_request(::zaoxun::ProductionInfoRequest* production_info_request);

  // optional .zaoxun.ProductionInfoResponse production_info_response = 42;
  inline bool has_production_info_response() const;
  inline void clear_production_info_response();
  static const int kProductionInfoResponseFieldNumber = 42;
  inline const ::zaoxun::ProductionInfoResponse& production_info_response() const;
  inline ::zaoxun::ProductionInfoResponse* mutable_production_info_response();
  inline ::zaoxun::ProductionInfoResponse* release_production_info_response();
  inline void set_allocated_production_info_response(::zaoxun::ProductionInfoResponse* production_info_response);

  // optional .zaoxun.FuelRequest fuel_request = 43;
  inline bool has_fuel_request() const;
  inline void clear_fuel_request();
  static const int kFuelRequestFieldNumber = 43;
  inline const ::zaoxun::FuelRequest& fuel_request() const;
  inline ::zaoxun::FuelRequest* mutable_fuel_request();
  inline ::zaoxun::FuelRequest* release_fuel_request();
  inline void set_allocated_fuel_request(::zaoxun::FuelRequest* fuel_request);

  // optional .zaoxun.FuelResponse fuel_response = 44;
  inline bool has_fuel_response() const;
  inline void clear_fuel_response();
  static const int kFuelResponseFieldNumber = 44;
  inline const ::zaoxun::FuelResponse& fuel_response() const;
  inline ::zaoxun::FuelResponse* mutable_fuel_response();
  inline ::zaoxun::FuelResponse* release_fuel_response();
  inline void set_allocated_fuel_response(::zaoxun::FuelResponse* fuel_response);

  // optional .zaoxun.HeartBeat heart_beat = 45;
  inline bool has_heart_beat() const;
  inline void clear_heart_beat();
  static const int kHeartBeatFieldNumber = 45;
  inline const ::zaoxun::HeartBeat& heart_beat() const;
  inline ::zaoxun::HeartBeat* mutable_heart_beat();
  inline ::zaoxun::HeartBeat* release_heart_beat();
  inline void set_allocated_heart_beat(::zaoxun::HeartBeat* heart_beat);

  // optional .zaoxun.TargetNotification target_notification = 46;
  inline bool has_target_notification() const;
  inline void clear_target_notification();
  static const int kTargetNotificationFieldNumber = 46;
  inline const ::zaoxun::TargetNotification& target_notification() const;
  inline ::zaoxun::TargetNotification* mutable_target_notification();
  inline ::zaoxun::TargetNotification* release_target_notification();
  inline void set_allocated_target_notification(::zaoxun::TargetNotification* target_notification);

  // optional .zaoxun.DeviceStatusResponse device_status_response = 47;
  inline bool has_device_status_response() const;
  inline void clear_device_status_response();
  static const int kDeviceStatusResponseFieldNumber = 47;
  inline const ::zaoxun::DeviceStatusResponse& device_status_response() const;
  inline ::zaoxun::DeviceStatusResponse* mutable_device_status_response();
  inline ::zaoxun::DeviceStatusResponse* release_device_status_response();
  inline void set_allocated_device_status_response(::zaoxun::DeviceStatusResponse* device_status_response);

  // optional .zaoxun.CommandResponse command_response = 48;
  inline bool has_command_response() const;
  inline void clear_command_response();
  static const int kCommandResponseFieldNumber = 48;
  inline const ::zaoxun::CommandResponse& command_response() const;
  inline ::zaoxun::CommandResponse* mutable_command_response();
  inline ::zaoxun::CommandResponse* release_command_response();
  inline void set_allocated_command_response(::zaoxun::CommandResponse* command_response);

  // optional .zaoxun.ManualLoadCompleteRequest manual_load_complete_request = 49;
  inline bool has_manual_load_complete_request() const;
  inline void clear_manual_load_complete_request();
  static const int kManualLoadCompleteRequestFieldNumber = 49;
  inline const ::zaoxun::ManualLoadCompleteRequest& manual_load_complete_request() const;
  inline ::zaoxun::ManualLoadCompleteRequest* mutable_manual_load_complete_request();
  inline ::zaoxun::ManualLoadCompleteRequest* release_manual_load_complete_request();
  inline void set_allocated_manual_load_complete_request(::zaoxun::ManualLoadCompleteRequest* manual_load_complete_request);

  // optional .zaoxun.ManualLoadCompleteResponse manual_load_complete_response = 50;
  inline bool has_manual_load_complete_response() const;
  inline void clear_manual_load_complete_response();
  static const int kManualLoadCompleteResponseFieldNumber = 50;
  inline const ::zaoxun::ManualLoadCompleteResponse& manual_load_complete_response() const;
  inline ::zaoxun::ManualLoadCompleteResponse* mutable_manual_load_complete_response();
  inline ::zaoxun::ManualLoadCompleteResponse* release_manual_load_complete_response();
  inline void set_allocated_manual_load_complete_response(::zaoxun::ManualLoadCompleteResponse* manual_load_complete_response);

  // optional .zaoxun.ManualUnloadRequest manual_unload_request = 51;
  inline bool has_manual_unload_request() const;
  inline void clear_manual_unload_request();
  static const int kManualUnloadRequestFieldNumber = 51;
  inline const ::zaoxun::ManualUnloadRequest& manual_unload_request() const;
  inline ::zaoxun::ManualUnloadRequest* mutable_manual_unload_request();
  inline ::zaoxun::ManualUnloadRequest* release_manual_unload_request();
  inline void set_allocated_manual_unload_request(::zaoxun::ManualUnloadRequest* manual_unload_request);

  // optional .zaoxun.ManualUnloadResponse manual_unload_response = 52;
  inline bool has_manual_unload_response() const;
  inline void clear_manual_unload_response();
  static const int kManualUnloadResponseFieldNumber = 52;
  inline const ::zaoxun::ManualUnloadResponse& manual_unload_response() const;
  inline ::zaoxun::ManualUnloadResponse* mutable_manual_unload_response();
  inline ::zaoxun::ManualUnloadResponse* release_manual_unload_response();
  inline void set_allocated_manual_unload_response(::zaoxun::ManualUnloadResponse* manual_unload_response);

  // @@protoc_insertion_point(class_scope:zaoxun.CommonMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_login_request();
  inline void clear_has_login_request();
  inline void set_has_login_response();
  inline void clear_has_login_response();
  inline void set_has_check_request();
  inline void clear_has_check_request();
  inline void set_has_check_response();
  inline void clear_has_check_response();
  inline void set_has_oil_quantity_request();
  inline void clear_has_oil_quantity_request();
  inline void set_has_oil_quantity_response();
  inline void clear_has_oil_quantity_response();
  inline void set_has_production_request();
  inline void clear_has_production_request();
  inline void set_has_production_response();
  inline void clear_has_production_response();
  inline void set_has_distance_request();
  inline void clear_has_distance_request();
  inline void set_has_distance_response();
  inline void clear_has_distance_response();
  inline void set_has_times_request();
  inline void clear_has_times_request();
  inline void set_has_times_response();
  inline void clear_has_times_response();
  inline void set_has_oiling_request();
  inline void clear_has_oiling_request();
  inline void set_has_oiling_response();
  inline void clear_has_oiling_response();
  inline void set_has_load_request();
  inline void clear_has_load_request();
  inline void set_has_load_response();
  inline void clear_has_load_response();
  inline void set_has_unload_request();
  inline void clear_has_unload_request();
  inline void set_has_unload_response();
  inline void clear_has_unload_response();
  inline void set_has_speed_limit();
  inline void clear_has_speed_limit();
  inline void set_has_short_message();
  inline void clear_has_short_message();
  inline void set_has_gps_data();
  inline void clear_has_gps_data();
  inline void set_has_audio_file_data();
  inline void clear_has_audio_file_data();
  inline void set_has_capture_file_data();
  inline void clear_has_capture_file_data();
  inline void set_has_materials_notification();
  inline void clear_has_materials_notification();
  inline void set_has_anticollision_notification();
  inline void clear_has_anticollision_notification();
  inline void set_has_edipperinfo_notification();
  inline void clear_has_edipperinfo_notification();
  inline void set_has_get_edippers_request();
  inline void clear_has_get_edippers_request();
  inline void set_has_get_edippers_response();
  inline void clear_has_get_edippers_response();
  inline void set_has_load_complete_request();
  inline void clear_has_load_complete_request();
  inline void set_has_load_complete_response();
  inline void clear_has_load_complete_response();
  inline void set_has_cancel_load_request();
  inline void clear_has_cancel_load_request();
  inline void set_has_cancel_load_response();
  inline void clear_has_cancel_load_response();
  inline void set_has_reject_load_request();
  inline void clear_has_reject_load_request();
  inline void set_has_reject_load_response();
  inline void clear_has_reject_load_response();
  inline void set_has_exit_notification();
  inline void clear_has_exit_notification();
  inline void set_has_device_status_request();
  inline void clear_has_device_status_request();
  inline void set_has_materials_request();
  inline void clear_has_materials_request();
  inline void set_has_materials_response();
  inline void clear_has_materials_response();
  inline void set_has_command_request();
  inline void clear_has_command_request();
  inline void set_has_production_info_request();
  inline void clear_has_production_info_request();
  inline void set_has_production_info_response();
  inline void clear_has_production_info_response();
  inline void set_has_fuel_request();
  inline void clear_has_fuel_request();
  inline void set_has_fuel_response();
  inline void clear_has_fuel_response();
  inline void set_has_heart_beat();
  inline void clear_has_heart_beat();
  inline void set_has_target_notification();
  inline void clear_has_target_notification();
  inline void set_has_device_status_response();
  inline void clear_has_device_status_response();
  inline void set_has_command_response();
  inline void clear_has_command_response();
  inline void set_has_manual_load_complete_request();
  inline void clear_has_manual_load_complete_request();
  inline void set_has_manual_load_complete_response();
  inline void clear_has_manual_load_complete_response();
  inline void set_has_manual_unload_request();
  inline void clear_has_manual_unload_request();
  inline void set_has_manual_unload_response();
  inline void clear_has_manual_unload_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::zaoxun::LoginRequest* login_request_;
  ::zaoxun::LoginResponse* login_response_;
  ::zaoxun::CheckRequest* check_request_;
  ::zaoxun::CheckResponse* check_response_;
  ::zaoxun::OilQuantityRequest* oil_quantity_request_;
  ::zaoxun::OilQuantityResponse* oil_quantity_response_;
  ::zaoxun::ProductionRequest* production_request_;
  ::zaoxun::ProductionResponse* production_response_;
  ::zaoxun::DistanceRequest* distance_request_;
  ::zaoxun::DistanceResponse* distance_response_;
  ::zaoxun::TimesRequest* times_request_;
  ::zaoxun::TimesResponse* times_response_;
  ::zaoxun::OilingRequest* oiling_request_;
  ::zaoxun::OilingResponse* oiling_response_;
  ::zaoxun::LoadRequest* load_request_;
  ::zaoxun::LoadResponse* load_response_;
  ::zaoxun::UnloadRequest* unload_request_;
  ::zaoxun::UnloadResponse* unload_response_;
  ::zaoxun::SpeedLimitMessage* speed_limit_;
  ::zaoxun::ShortMessage* short_message_;
  ::zaoxun::GPSData* gps_data_;
  ::zaoxun::AudioFileData* audio_file_data_;
  ::zaoxun::CaptureFileData* capture_file_data_;
  ::zaoxun::MaterialsNotification* materials_notification_;
  ::zaoxun::AntiCollisionNotification* anticollision_notification_;
  ::zaoxun::EDipperInfoNotification* edipperinfo_notification_;
  ::zaoxun::GetEDippersRequest* get_edippers_request_;
  ::zaoxun::GetEDippersResponse* get_edippers_response_;
  ::zaoxun::LoadCompleteRequest* load_complete_request_;
  ::zaoxun::LoadCompleteResponse* load_complete_response_;
  ::zaoxun::CancelLoadRequest* cancel_load_request_;
  ::zaoxun::CancelLoadResponse* cancel_load_response_;
  ::zaoxun::RejectLoadRequest* reject_load_request_;
  ::zaoxun::RejectLoadResponse* reject_load_response_;
  ::zaoxun::ExitNotification* exit_notification_;
  ::zaoxun::DeviceStatusRequest* device_status_request_;
  ::zaoxun::MaterialsRequest* materials_request_;
  ::zaoxun::MaterialsResponse* materials_response_;
  ::zaoxun::CommandRequest* command_request_;
  ::zaoxun::ProductionInfoRequest* production_info_request_;
  ::zaoxun::ProductionInfoResponse* production_info_response_;
  ::zaoxun::FuelRequest* fuel_request_;
  ::zaoxun::FuelResponse* fuel_response_;
  ::zaoxun::HeartBeat* heart_beat_;
  ::zaoxun::TargetNotification* target_notification_;
  ::zaoxun::DeviceStatusResponse* device_status_response_;
  ::zaoxun::CommandResponse* command_response_;
  ::zaoxun::ManualLoadCompleteRequest* manual_load_complete_request_;
  ::zaoxun::ManualLoadCompleteResponse* manual_load_complete_response_;
  ::zaoxun::ManualUnloadRequest* manual_unload_request_;
  ::zaoxun::ManualUnloadResponse* manual_unload_response_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(52 + 31) / 32];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static CommonMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// optional string device_id = 1;
inline bool LoginRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& LoginRequest::device_id() const {
  return *device_id_;
}
inline void LoginRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoginRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoginRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* LoginRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginResponse

// optional string device_id = 1;
inline bool LoginResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& LoginResponse::device_id() const {
  return *device_id_;
}
inline void LoginResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoginResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoginResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* LoginResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 2;
inline bool LoginResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoginResponse::result() const {
  return result_;
}
inline void LoginResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .zaoxun.CarType type = 3;
inline bool LoginResponse::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::zaoxun::CarType LoginResponse::type() const {
  return static_cast< ::zaoxun::CarType >(type_);
}
inline void LoginResponse::set_type(::zaoxun::CarType value) {
  assert(::zaoxun::CarType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string car_no = 4;
inline bool LoginResponse::has_car_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponse::set_has_car_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResponse::clear_has_car_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResponse::clear_car_no() {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    car_no_->clear();
  }
  clear_has_car_no();
}
inline const ::std::string& LoginResponse::car_no() const {
  return *car_no_;
}
inline void LoginResponse::set_car_no(const ::std::string& value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void LoginResponse::set_car_no(const char* value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void LoginResponse::set_car_no(const char* value, size_t size) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_car_no() {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  return car_no_;
}
inline ::std::string* LoginResponse::release_car_no() {
  clear_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_no_;
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_car_no(::std::string* car_no) {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    delete car_no_;
  }
  if (car_no) {
    set_has_car_no();
    car_no_ = car_no;
  } else {
    clear_has_car_no();
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .zaoxun.RunningStatus run_status = 5;
inline bool LoginResponse::has_run_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResponse::set_has_run_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResponse::clear_has_run_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResponse::clear_run_status() {
  run_status_ = 1;
  clear_has_run_status();
}
inline ::zaoxun::RunningStatus LoginResponse::run_status() const {
  return static_cast< ::zaoxun::RunningStatus >(run_status_);
}
inline void LoginResponse::set_run_status(::zaoxun::RunningStatus value) {
  assert(::zaoxun::RunningStatus_IsValid(value));
  set_has_run_status();
  run_status_ = value;
}

// optional int32 material_id = 6;
inline bool LoginResponse::has_material_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginResponse::set_has_material_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginResponse::clear_has_material_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginResponse::clear_material_id() {
  material_id_ = 0;
  clear_has_material_id();
}
inline ::google::protobuf::int32 LoginResponse::material_id() const {
  return material_id_;
}
inline void LoginResponse::set_material_id(::google::protobuf::int32 value) {
  set_has_material_id();
  material_id_ = value;
}

// optional string material_name = 7;
inline bool LoginResponse::has_material_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginResponse::set_has_material_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginResponse::clear_has_material_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginResponse::clear_material_name() {
  if (material_name_ != &::google::protobuf::internal::kEmptyString) {
    material_name_->clear();
  }
  clear_has_material_name();
}
inline const ::std::string& LoginResponse::material_name() const {
  return *material_name_;
}
inline void LoginResponse::set_material_name(const ::std::string& value) {
  set_has_material_name();
  if (material_name_ == &::google::protobuf::internal::kEmptyString) {
    material_name_ = new ::std::string;
  }
  material_name_->assign(value);
}
inline void LoginResponse::set_material_name(const char* value) {
  set_has_material_name();
  if (material_name_ == &::google::protobuf::internal::kEmptyString) {
    material_name_ = new ::std::string;
  }
  material_name_->assign(value);
}
inline void LoginResponse::set_material_name(const char* value, size_t size) {
  set_has_material_name();
  if (material_name_ == &::google::protobuf::internal::kEmptyString) {
    material_name_ = new ::std::string;
  }
  material_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_material_name() {
  set_has_material_name();
  if (material_name_ == &::google::protobuf::internal::kEmptyString) {
    material_name_ = new ::std::string;
  }
  return material_name_;
}
inline ::std::string* LoginResponse::release_material_name() {
  clear_has_material_name();
  if (material_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = material_name_;
    material_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_material_name(::std::string* material_name) {
  if (material_name_ != &::google::protobuf::internal::kEmptyString) {
    delete material_name_;
  }
  if (material_name) {
    set_has_material_name();
    material_name_ = material_name;
  } else {
    clear_has_material_name();
    material_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CheckRequest

// optional string device_id = 1;
inline bool CheckRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CheckRequest::device_id() const {
  return *device_id_;
}
inline void CheckRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CheckRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CheckRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CheckRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CheckResponse

// optional string device_id = 1;
inline bool CheckResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CheckResponse::device_id() const {
  return *device_id_;
}
inline void CheckResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CheckResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CheckResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CheckResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 driver_id = 2;
inline bool CheckResponse::has_driver_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckResponse::set_has_driver_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckResponse::clear_has_driver_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckResponse::clear_driver_id() {
  driver_id_ = 0;
  clear_has_driver_id();
}
inline ::google::protobuf::int32 CheckResponse::driver_id() const {
  return driver_id_;
}
inline void CheckResponse::set_driver_id(::google::protobuf::int32 value) {
  set_has_driver_id();
  driver_id_ = value;
}

// optional string driver_name = 3;
inline bool CheckResponse::has_driver_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckResponse::set_has_driver_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckResponse::clear_has_driver_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckResponse::clear_driver_name() {
  if (driver_name_ != &::google::protobuf::internal::kEmptyString) {
    driver_name_->clear();
  }
  clear_has_driver_name();
}
inline const ::std::string& CheckResponse::driver_name() const {
  return *driver_name_;
}
inline void CheckResponse::set_driver_name(const ::std::string& value) {
  set_has_driver_name();
  if (driver_name_ == &::google::protobuf::internal::kEmptyString) {
    driver_name_ = new ::std::string;
  }
  driver_name_->assign(value);
}
inline void CheckResponse::set_driver_name(const char* value) {
  set_has_driver_name();
  if (driver_name_ == &::google::protobuf::internal::kEmptyString) {
    driver_name_ = new ::std::string;
  }
  driver_name_->assign(value);
}
inline void CheckResponse::set_driver_name(const char* value, size_t size) {
  set_has_driver_name();
  if (driver_name_ == &::google::protobuf::internal::kEmptyString) {
    driver_name_ = new ::std::string;
  }
  driver_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckResponse::mutable_driver_name() {
  set_has_driver_name();
  if (driver_name_ == &::google::protobuf::internal::kEmptyString) {
    driver_name_ = new ::std::string;
  }
  return driver_name_;
}
inline ::std::string* CheckResponse::release_driver_name() {
  clear_has_driver_name();
  if (driver_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = driver_name_;
    driver_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckResponse::set_allocated_driver_name(::std::string* driver_name) {
  if (driver_name_ != &::google::protobuf::internal::kEmptyString) {
    delete driver_name_;
  }
  if (driver_name) {
    set_has_driver_name();
    driver_name_ = driver_name;
  } else {
    clear_has_driver_name();
    driver_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double speed_limit = 4;
inline bool CheckResponse::has_speed_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckResponse::set_has_speed_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckResponse::clear_has_speed_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckResponse::clear_speed_limit() {
  speed_limit_ = 0;
  clear_has_speed_limit();
}
inline double CheckResponse::speed_limit() const {
  return speed_limit_;
}
inline void CheckResponse::set_speed_limit(double value) {
  set_has_speed_limit();
  speed_limit_ = value;
}

// optional int32 status = 5;
inline bool CheckResponse::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckResponse::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 CheckResponse::status() const {
  return status_;
}
inline void CheckResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// OilQuantityRequest

// optional string device_id = 1;
inline bool OilQuantityRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OilQuantityRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OilQuantityRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OilQuantityRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& OilQuantityRequest::device_id() const {
  return *device_id_;
}
inline void OilQuantityRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilQuantityRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilQuantityRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilQuantityRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* OilQuantityRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilQuantityRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OilQuantityResponse

// optional string device_id = 1;
inline bool OilQuantityResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OilQuantityResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OilQuantityResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OilQuantityResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& OilQuantityResponse::device_id() const {
  return *device_id_;
}
inline void OilQuantityResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilQuantityResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilQuantityResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilQuantityResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* OilQuantityResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilQuantityResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double quantity = 3;
inline bool OilQuantityResponse::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OilQuantityResponse::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OilQuantityResponse::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OilQuantityResponse::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double OilQuantityResponse::quantity() const {
  return quantity_;
}
inline void OilQuantityResponse::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
}

// -------------------------------------------------------------------

// ProductionRequest

// optional string device_id = 1;
inline bool ProductionRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductionRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductionRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductionRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ProductionRequest::device_id() const {
  return *device_id_;
}
inline void ProductionRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductionRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ProductionRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProductionRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool ProductionRequest::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductionRequest::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductionRequest::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductionRequest::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 ProductionRequest::period() const {
  return period_;
}
inline void ProductionRequest::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// -------------------------------------------------------------------

// ProductionResponse

// optional string device_id = 1;
inline bool ProductionResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductionResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductionResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductionResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ProductionResponse::device_id() const {
  return *device_id_;
}
inline void ProductionResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductionResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ProductionResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProductionResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool ProductionResponse::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductionResponse::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductionResponse::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductionResponse::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 ProductionResponse::period() const {
  return period_;
}
inline void ProductionResponse::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// optional double quantity = 3;
inline bool ProductionResponse::has_quantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProductionResponse::set_has_quantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProductionResponse::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProductionResponse::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double ProductionResponse::quantity() const {
  return quantity_;
}
inline void ProductionResponse::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
}

// -------------------------------------------------------------------

// DistanceRequest

// optional string device_id = 1;
inline bool DistanceRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DistanceRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DistanceRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DistanceRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& DistanceRequest::device_id() const {
  return *device_id_;
}
inline void DistanceRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DistanceRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DistanceRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DistanceRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* DistanceRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DistanceRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool DistanceRequest::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DistanceRequest::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DistanceRequest::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DistanceRequest::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 DistanceRequest::period() const {
  return period_;
}
inline void DistanceRequest::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// -------------------------------------------------------------------

// DistanceResponse

// optional string device_id = 1;
inline bool DistanceResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DistanceResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DistanceResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DistanceResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& DistanceResponse::device_id() const {
  return *device_id_;
}
inline void DistanceResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DistanceResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DistanceResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DistanceResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* DistanceResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DistanceResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool DistanceResponse::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DistanceResponse::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DistanceResponse::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DistanceResponse::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 DistanceResponse::period() const {
  return period_;
}
inline void DistanceResponse::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// optional double distance = 3;
inline bool DistanceResponse::has_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DistanceResponse::set_has_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DistanceResponse::clear_has_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DistanceResponse::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline double DistanceResponse::distance() const {
  return distance_;
}
inline void DistanceResponse::set_distance(double value) {
  set_has_distance();
  distance_ = value;
}

// -------------------------------------------------------------------

// TimesRequest

// optional string device_id = 1;
inline bool TimesRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimesRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimesRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimesRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& TimesRequest::device_id() const {
  return *device_id_;
}
inline void TimesRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void TimesRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void TimesRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimesRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* TimesRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimesRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool TimesRequest::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimesRequest::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimesRequest::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimesRequest::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 TimesRequest::period() const {
  return period_;
}
inline void TimesRequest::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// -------------------------------------------------------------------

// TimesResponse

// optional string device_id = 1;
inline bool TimesResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimesResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimesResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimesResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& TimesResponse::device_id() const {
  return *device_id_;
}
inline void TimesResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void TimesResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void TimesResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimesResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* TimesResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimesResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 period = 2;
inline bool TimesResponse::has_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimesResponse::set_has_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimesResponse::clear_has_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimesResponse::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 TimesResponse::period() const {
  return period_;
}
inline void TimesResponse::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// optional int32 times = 3;
inline bool TimesResponse::has_times() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimesResponse::set_has_times() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimesResponse::clear_has_times() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimesResponse::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 TimesResponse::times() const {
  return times_;
}
inline void TimesResponse::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// -------------------------------------------------------------------

// OilingRequest

// optional string device_id = 1;
inline bool OilingRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OilingRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OilingRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OilingRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& OilingRequest::device_id() const {
  return *device_id_;
}
inline void OilingRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilingRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilingRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilingRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* OilingRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilingRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target = 2;
inline bool OilingRequest::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OilingRequest::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OilingRequest::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OilingRequest::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& OilingRequest::target() const {
  return *target_;
}
inline void OilingRequest::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void OilingRequest::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void OilingRequest::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilingRequest::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* OilingRequest::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilingRequest::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double volume = 3;
inline bool OilingRequest::has_volume() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OilingRequest::set_has_volume() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OilingRequest::clear_has_volume() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OilingRequest::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double OilingRequest::volume() const {
  return volume_;
}
inline void OilingRequest::set_volume(double value) {
  set_has_volume();
  volume_ = value;
}

// -------------------------------------------------------------------

// OilingResponse

// optional string device_id = 1;
inline bool OilingResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OilingResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OilingResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OilingResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& OilingResponse::device_id() const {
  return *device_id_;
}
inline void OilingResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilingResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void OilingResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilingResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* OilingResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilingResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target = 2;
inline bool OilingResponse::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OilingResponse::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OilingResponse::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OilingResponse::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& OilingResponse::target() const {
  return *target_;
}
inline void OilingResponse::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void OilingResponse::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void OilingResponse::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OilingResponse::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* OilingResponse::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OilingResponse::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double volume = 3;
inline bool OilingResponse::has_volume() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OilingResponse::set_has_volume() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OilingResponse::clear_has_volume() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OilingResponse::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double OilingResponse::volume() const {
  return volume_;
}
inline void OilingResponse::set_volume(double value) {
  set_has_volume();
  volume_ = value;
}

// optional int32 result = 4;
inline bool OilingResponse::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OilingResponse::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OilingResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OilingResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 OilingResponse::result() const {
  return result_;
}
inline void OilingResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// LoadRequest

// optional string device_id = 1;
inline bool LoadRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& LoadRequest::device_id() const {
  return *device_id_;
}
inline void LoadRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoadRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoadRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* LoadRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool LoadRequest::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadRequest::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadRequest::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadRequest::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& LoadRequest::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void LoadRequest::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadRequest::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadRequest::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadRequest::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* LoadRequest::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadRequest::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_no = 3;
inline bool LoadRequest::has_car_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadRequest::set_has_car_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadRequest::clear_has_car_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadRequest::clear_car_no() {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    car_no_->clear();
  }
  clear_has_car_no();
}
inline const ::std::string& LoadRequest::car_no() const {
  return *car_no_;
}
inline void LoadRequest::set_car_no(const ::std::string& value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void LoadRequest::set_car_no(const char* value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void LoadRequest::set_car_no(const char* value, size_t size) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadRequest::mutable_car_no() {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  return car_no_;
}
inline ::std::string* LoadRequest::release_car_no() {
  clear_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_no_;
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadRequest::set_allocated_car_no(::std::string* car_no) {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    delete car_no_;
  }
  if (car_no) {
    set_has_car_no();
    car_no_ = car_no;
  } else {
    clear_has_car_no();
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoadResponse

// optional string device_id = 1;
inline bool LoadResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& LoadResponse::device_id() const {
  return *device_id_;
}
inline void LoadResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoadResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoadResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* LoadResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool LoadResponse::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadResponse::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadResponse::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadResponse::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& LoadResponse::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void LoadResponse::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadResponse::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadResponse::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadResponse::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* LoadResponse::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadResponse::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 material_id = 3;
inline bool LoadResponse::has_material_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadResponse::set_has_material_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadResponse::clear_has_material_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadResponse::clear_material_id() {
  material_id_ = 0;
  clear_has_material_id();
}
inline ::google::protobuf::int32 LoadResponse::material_id() const {
  return material_id_;
}
inline void LoadResponse::set_material_id(::google::protobuf::int32 value) {
  set_has_material_id();
  material_id_ = value;
}

// optional string material_name = 4;
inline bool LoadResponse::has_material_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoadResponse::set_has_material_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoadResponse::clear_has_material_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoadResponse::clear_material_name() {
  if (material_name_ != &::google::protobuf::internal::kEmptyString) {
    material_name_->clear();
  }
  clear_has_material_name();
}
inline const ::std::string& LoadResponse::material_name() const {
  return *material_name_;
}
inline void LoadResponse::set_material_name(const ::std::string& value) {
  set_has_material_name();
  if (material_name_ == &::google::protobuf::internal::kEmptyString) {
    material_name_ = new ::std::string;
  }
  material_name_->assign(value);
}
inline void LoadResponse::set_material_name(const char* value) {
  set_has_material_name();
  if (material_name_ == &::google::protobuf::internal::kEmptyString) {
    material_name_ = new ::std::string;
  }
  material_name_->assign(value);
}
inline void LoadResponse::set_material_name(const char* value, size_t size) {
  set_has_material_name();
  if (material_name_ == &::google::protobuf::internal::kEmptyString) {
    material_name_ = new ::std::string;
  }
  material_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadResponse::mutable_material_name() {
  set_has_material_name();
  if (material_name_ == &::google::protobuf::internal::kEmptyString) {
    material_name_ = new ::std::string;
  }
  return material_name_;
}
inline ::std::string* LoadResponse::release_material_name() {
  clear_has_material_name();
  if (material_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = material_name_;
    material_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadResponse::set_allocated_material_name(::std::string* material_name) {
  if (material_name_ != &::google::protobuf::internal::kEmptyString) {
    delete material_name_;
  }
  if (material_name) {
    set_has_material_name();
    material_name_ = material_name;
  } else {
    clear_has_material_name();
    material_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 5;
inline bool LoadResponse::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoadResponse::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoadResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoadResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoadResponse::result() const {
  return result_;
}
inline void LoadResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// UnloadRequest

// optional string device_id = 1;
inline bool UnloadRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnloadRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnloadRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnloadRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& UnloadRequest::device_id() const {
  return *device_id_;
}
inline void UnloadRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void UnloadRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void UnloadRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnloadRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* UnloadRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnloadRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool UnloadRequest::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnloadRequest::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnloadRequest::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnloadRequest::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& UnloadRequest::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void UnloadRequest::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void UnloadRequest::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void UnloadRequest::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnloadRequest::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* UnloadRequest::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnloadRequest::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UnloadResponse

// optional string device_id = 1;
inline bool UnloadResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnloadResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnloadResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnloadResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& UnloadResponse::device_id() const {
  return *device_id_;
}
inline void UnloadResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void UnloadResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void UnloadResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnloadResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* UnloadResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnloadResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 2;
inline bool UnloadResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnloadResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnloadResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnloadResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UnloadResponse::result() const {
  return result_;
}
inline void UnloadResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ManualUnloadRequest

// optional string device_id = 1;
inline bool ManualUnloadRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManualUnloadRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManualUnloadRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManualUnloadRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ManualUnloadRequest::device_id() const {
  return *device_id_;
}
inline void ManualUnloadRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ManualUnloadRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ManualUnloadRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManualUnloadRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ManualUnloadRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ManualUnloadRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool ManualUnloadRequest::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManualUnloadRequest::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManualUnloadRequest::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManualUnloadRequest::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& ManualUnloadRequest::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void ManualUnloadRequest::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void ManualUnloadRequest::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void ManualUnloadRequest::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManualUnloadRequest::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* ManualUnloadRequest::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ManualUnloadRequest::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 material_id = 3;
inline bool ManualUnloadRequest::has_material_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManualUnloadRequest::set_has_material_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManualUnloadRequest::clear_has_material_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManualUnloadRequest::clear_material_id() {
  material_id_ = 0;
  clear_has_material_id();
}
inline ::google::protobuf::int32 ManualUnloadRequest::material_id() const {
  return material_id_;
}
inline void ManualUnloadRequest::set_material_id(::google::protobuf::int32 value) {
  set_has_material_id();
  material_id_ = value;
}

// -------------------------------------------------------------------

// ManualUnloadResponse

// optional string device_id = 1;
inline bool ManualUnloadResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManualUnloadResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManualUnloadResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManualUnloadResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ManualUnloadResponse::device_id() const {
  return *device_id_;
}
inline void ManualUnloadResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ManualUnloadResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ManualUnloadResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManualUnloadResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ManualUnloadResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ManualUnloadResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool ManualUnloadResponse::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManualUnloadResponse::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManualUnloadResponse::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManualUnloadResponse::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& ManualUnloadResponse::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void ManualUnloadResponse::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void ManualUnloadResponse::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void ManualUnloadResponse::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManualUnloadResponse::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* ManualUnloadResponse::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ManualUnloadResponse::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 material_id = 3;
inline bool ManualUnloadResponse::has_material_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManualUnloadResponse::set_has_material_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManualUnloadResponse::clear_has_material_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManualUnloadResponse::clear_material_id() {
  material_id_ = 0;
  clear_has_material_id();
}
inline ::google::protobuf::int32 ManualUnloadResponse::material_id() const {
  return material_id_;
}
inline void ManualUnloadResponse::set_material_id(::google::protobuf::int32 value) {
  set_has_material_id();
  material_id_ = value;
}

// optional int32 result = 4;
inline bool ManualUnloadResponse::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManualUnloadResponse::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManualUnloadResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManualUnloadResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ManualUnloadResponse::result() const {
  return result_;
}
inline void ManualUnloadResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SpeedLimitMessage

// optional string device_id = 1;
inline bool SpeedLimitMessage::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeedLimitMessage::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeedLimitMessage::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeedLimitMessage::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& SpeedLimitMessage::device_id() const {
  return *device_id_;
}
inline void SpeedLimitMessage::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void SpeedLimitMessage::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void SpeedLimitMessage::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpeedLimitMessage::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* SpeedLimitMessage::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpeedLimitMessage::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double speed = 2;
inline bool SpeedLimitMessage::has_speed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeedLimitMessage::set_has_speed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeedLimitMessage::clear_has_speed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeedLimitMessage::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double SpeedLimitMessage::speed() const {
  return speed_;
}
inline void SpeedLimitMessage::set_speed(double value) {
  set_has_speed();
  speed_ = value;
}

// -------------------------------------------------------------------

// ShortMessage

// optional string device_id = 1;
inline bool ShortMessage::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShortMessage::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShortMessage::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShortMessage::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ShortMessage::device_id() const {
  return *device_id_;
}
inline void ShortMessage::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ShortMessage::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ShortMessage::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShortMessage::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ShortMessage::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ShortMessage::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dest_device = 2;
inline bool ShortMessage::has_dest_device() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShortMessage::set_has_dest_device() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShortMessage::clear_has_dest_device() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShortMessage::clear_dest_device() {
  if (dest_device_ != &::google::protobuf::internal::kEmptyString) {
    dest_device_->clear();
  }
  clear_has_dest_device();
}
inline const ::std::string& ShortMessage::dest_device() const {
  return *dest_device_;
}
inline void ShortMessage::set_dest_device(const ::std::string& value) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(value);
}
inline void ShortMessage::set_dest_device(const char* value) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(value);
}
inline void ShortMessage::set_dest_device(const char* value, size_t size) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShortMessage::mutable_dest_device() {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  return dest_device_;
}
inline ::std::string* ShortMessage::release_dest_device() {
  clear_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dest_device_;
    dest_device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ShortMessage::set_allocated_dest_device(::std::string* dest_device) {
  if (dest_device_ != &::google::protobuf::internal::kEmptyString) {
    delete dest_device_;
  }
  if (dest_device) {
    set_has_dest_device();
    dest_device_ = dest_device;
  } else {
    clear_has_dest_device();
    dest_device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 3;
inline bool ShortMessage::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShortMessage::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShortMessage::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShortMessage::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& ShortMessage::content() const {
  return *content_;
}
inline void ShortMessage::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ShortMessage::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ShortMessage::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShortMessage::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* ShortMessage::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ShortMessage::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GPSData

// optional string device_id = 1;
inline bool GPSData::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSData::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSData::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSData::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& GPSData::device_id() const {
  return *device_id_;
}
inline void GPSData::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GPSData::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GPSData::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* GPSData::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 2;
inline bool GPSData::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPSData::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPSData::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPSData::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& GPSData::time() const {
  return *time_;
}
inline void GPSData::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void GPSData::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void GPSData::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* GPSData::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string latitude = 3;
inline bool GPSData::has_latitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPSData::set_has_latitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPSData::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPSData::clear_latitude() {
  if (latitude_ != &::google::protobuf::internal::kEmptyString) {
    latitude_->clear();
  }
  clear_has_latitude();
}
inline const ::std::string& GPSData::latitude() const {
  return *latitude_;
}
inline void GPSData::set_latitude(const ::std::string& value) {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::kEmptyString) {
    latitude_ = new ::std::string;
  }
  latitude_->assign(value);
}
inline void GPSData::set_latitude(const char* value) {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::kEmptyString) {
    latitude_ = new ::std::string;
  }
  latitude_->assign(value);
}
inline void GPSData::set_latitude(const char* value, size_t size) {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::kEmptyString) {
    latitude_ = new ::std::string;
  }
  latitude_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_latitude() {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::kEmptyString) {
    latitude_ = new ::std::string;
  }
  return latitude_;
}
inline ::std::string* GPSData::release_latitude() {
  clear_has_latitude();
  if (latitude_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = latitude_;
    latitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_latitude(::std::string* latitude) {
  if (latitude_ != &::google::protobuf::internal::kEmptyString) {
    delete latitude_;
  }
  if (latitude) {
    set_has_latitude();
    latitude_ = latitude;
  } else {
    clear_has_latitude();
    latitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string longitude = 4;
inline bool GPSData::has_longitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPSData::set_has_longitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPSData::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPSData::clear_longitude() {
  if (longitude_ != &::google::protobuf::internal::kEmptyString) {
    longitude_->clear();
  }
  clear_has_longitude();
}
inline const ::std::string& GPSData::longitude() const {
  return *longitude_;
}
inline void GPSData::set_longitude(const ::std::string& value) {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::kEmptyString) {
    longitude_ = new ::std::string;
  }
  longitude_->assign(value);
}
inline void GPSData::set_longitude(const char* value) {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::kEmptyString) {
    longitude_ = new ::std::string;
  }
  longitude_->assign(value);
}
inline void GPSData::set_longitude(const char* value, size_t size) {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::kEmptyString) {
    longitude_ = new ::std::string;
  }
  longitude_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_longitude() {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::kEmptyString) {
    longitude_ = new ::std::string;
  }
  return longitude_;
}
inline ::std::string* GPSData::release_longitude() {
  clear_has_longitude();
  if (longitude_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = longitude_;
    longitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_longitude(::std::string* longitude) {
  if (longitude_ != &::google::protobuf::internal::kEmptyString) {
    delete longitude_;
  }
  if (longitude) {
    set_has_longitude();
    longitude_ = longitude;
  } else {
    clear_has_longitude();
    longitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string speed = 5;
inline bool GPSData::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPSData::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPSData::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPSData::clear_speed() {
  if (speed_ != &::google::protobuf::internal::kEmptyString) {
    speed_->clear();
  }
  clear_has_speed();
}
inline const ::std::string& GPSData::speed() const {
  return *speed_;
}
inline void GPSData::set_speed(const ::std::string& value) {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::kEmptyString) {
    speed_ = new ::std::string;
  }
  speed_->assign(value);
}
inline void GPSData::set_speed(const char* value) {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::kEmptyString) {
    speed_ = new ::std::string;
  }
  speed_->assign(value);
}
inline void GPSData::set_speed(const char* value, size_t size) {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::kEmptyString) {
    speed_ = new ::std::string;
  }
  speed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_speed() {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::kEmptyString) {
    speed_ = new ::std::string;
  }
  return speed_;
}
inline ::std::string* GPSData::release_speed() {
  clear_has_speed();
  if (speed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = speed_;
    speed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_speed(::std::string* speed) {
  if (speed_ != &::google::protobuf::internal::kEmptyString) {
    delete speed_;
  }
  if (speed) {
    set_has_speed();
    speed_ = speed;
  } else {
    clear_has_speed();
    speed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string elevation = 6;
inline bool GPSData::has_elevation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GPSData::set_has_elevation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GPSData::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GPSData::clear_elevation() {
  if (elevation_ != &::google::protobuf::internal::kEmptyString) {
    elevation_->clear();
  }
  clear_has_elevation();
}
inline const ::std::string& GPSData::elevation() const {
  return *elevation_;
}
inline void GPSData::set_elevation(const ::std::string& value) {
  set_has_elevation();
  if (elevation_ == &::google::protobuf::internal::kEmptyString) {
    elevation_ = new ::std::string;
  }
  elevation_->assign(value);
}
inline void GPSData::set_elevation(const char* value) {
  set_has_elevation();
  if (elevation_ == &::google::protobuf::internal::kEmptyString) {
    elevation_ = new ::std::string;
  }
  elevation_->assign(value);
}
inline void GPSData::set_elevation(const char* value, size_t size) {
  set_has_elevation();
  if (elevation_ == &::google::protobuf::internal::kEmptyString) {
    elevation_ = new ::std::string;
  }
  elevation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_elevation() {
  set_has_elevation();
  if (elevation_ == &::google::protobuf::internal::kEmptyString) {
    elevation_ = new ::std::string;
  }
  return elevation_;
}
inline ::std::string* GPSData::release_elevation() {
  clear_has_elevation();
  if (elevation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = elevation_;
    elevation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_elevation(::std::string* elevation) {
  if (elevation_ != &::google::protobuf::internal::kEmptyString) {
    delete elevation_;
  }
  if (elevation) {
    set_has_elevation();
    elevation_ = elevation;
  } else {
    clear_has_elevation();
    elevation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string direction = 7;
inline bool GPSData::has_direction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GPSData::set_has_direction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GPSData::clear_has_direction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GPSData::clear_direction() {
  if (direction_ != &::google::protobuf::internal::kEmptyString) {
    direction_->clear();
  }
  clear_has_direction();
}
inline const ::std::string& GPSData::direction() const {
  return *direction_;
}
inline void GPSData::set_direction(const ::std::string& value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void GPSData::set_direction(const char* value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void GPSData::set_direction(const char* value, size_t size) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_direction() {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  return direction_;
}
inline ::std::string* GPSData::release_direction() {
  clear_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = direction_;
    direction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_direction(::std::string* direction) {
  if (direction_ != &::google::protobuf::internal::kEmptyString) {
    delete direction_;
  }
  if (direction) {
    set_has_direction();
    direction_ = direction;
  } else {
    clear_has_direction();
    direction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string radius = 8;
inline bool GPSData::has_radius() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GPSData::set_has_radius() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GPSData::clear_has_radius() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GPSData::clear_radius() {
  if (radius_ != &::google::protobuf::internal::kEmptyString) {
    radius_->clear();
  }
  clear_has_radius();
}
inline const ::std::string& GPSData::radius() const {
  return *radius_;
}
inline void GPSData::set_radius(const ::std::string& value) {
  set_has_radius();
  if (radius_ == &::google::protobuf::internal::kEmptyString) {
    radius_ = new ::std::string;
  }
  radius_->assign(value);
}
inline void GPSData::set_radius(const char* value) {
  set_has_radius();
  if (radius_ == &::google::protobuf::internal::kEmptyString) {
    radius_ = new ::std::string;
  }
  radius_->assign(value);
}
inline void GPSData::set_radius(const char* value, size_t size) {
  set_has_radius();
  if (radius_ == &::google::protobuf::internal::kEmptyString) {
    radius_ = new ::std::string;
  }
  radius_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_radius() {
  set_has_radius();
  if (radius_ == &::google::protobuf::internal::kEmptyString) {
    radius_ = new ::std::string;
  }
  return radius_;
}
inline ::std::string* GPSData::release_radius() {
  clear_has_radius();
  if (radius_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = radius_;
    radius_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_radius(::std::string* radius) {
  if (radius_ != &::google::protobuf::internal::kEmptyString) {
    delete radius_;
  }
  if (radius) {
    set_has_radius();
    radius_ = radius;
  } else {
    clear_has_radius();
    radius_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string loctype = 9;
inline bool GPSData::has_loctype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GPSData::set_has_loctype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GPSData::clear_has_loctype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GPSData::clear_loctype() {
  if (loctype_ != &::google::protobuf::internal::kEmptyString) {
    loctype_->clear();
  }
  clear_has_loctype();
}
inline const ::std::string& GPSData::loctype() const {
  return *loctype_;
}
inline void GPSData::set_loctype(const ::std::string& value) {
  set_has_loctype();
  if (loctype_ == &::google::protobuf::internal::kEmptyString) {
    loctype_ = new ::std::string;
  }
  loctype_->assign(value);
}
inline void GPSData::set_loctype(const char* value) {
  set_has_loctype();
  if (loctype_ == &::google::protobuf::internal::kEmptyString) {
    loctype_ = new ::std::string;
  }
  loctype_->assign(value);
}
inline void GPSData::set_loctype(const char* value, size_t size) {
  set_has_loctype();
  if (loctype_ == &::google::protobuf::internal::kEmptyString) {
    loctype_ = new ::std::string;
  }
  loctype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_loctype() {
  set_has_loctype();
  if (loctype_ == &::google::protobuf::internal::kEmptyString) {
    loctype_ = new ::std::string;
  }
  return loctype_;
}
inline ::std::string* GPSData::release_loctype() {
  clear_has_loctype();
  if (loctype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loctype_;
    loctype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_loctype(::std::string* loctype) {
  if (loctype_ != &::google::protobuf::internal::kEmptyString) {
    delete loctype_;
  }
  if (loctype) {
    set_has_loctype();
    loctype_ = loctype;
  } else {
    clear_has_loctype();
    loctype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string addrstr = 10;
inline bool GPSData::has_addrstr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GPSData::set_has_addrstr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GPSData::clear_has_addrstr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GPSData::clear_addrstr() {
  if (addrstr_ != &::google::protobuf::internal::kEmptyString) {
    addrstr_->clear();
  }
  clear_has_addrstr();
}
inline const ::std::string& GPSData::addrstr() const {
  return *addrstr_;
}
inline void GPSData::set_addrstr(const ::std::string& value) {
  set_has_addrstr();
  if (addrstr_ == &::google::protobuf::internal::kEmptyString) {
    addrstr_ = new ::std::string;
  }
  addrstr_->assign(value);
}
inline void GPSData::set_addrstr(const char* value) {
  set_has_addrstr();
  if (addrstr_ == &::google::protobuf::internal::kEmptyString) {
    addrstr_ = new ::std::string;
  }
  addrstr_->assign(value);
}
inline void GPSData::set_addrstr(const char* value, size_t size) {
  set_has_addrstr();
  if (addrstr_ == &::google::protobuf::internal::kEmptyString) {
    addrstr_ = new ::std::string;
  }
  addrstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_addrstr() {
  set_has_addrstr();
  if (addrstr_ == &::google::protobuf::internal::kEmptyString) {
    addrstr_ = new ::std::string;
  }
  return addrstr_;
}
inline ::std::string* GPSData::release_addrstr() {
  clear_has_addrstr();
  if (addrstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addrstr_;
    addrstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_addrstr(::std::string* addrstr) {
  if (addrstr_ != &::google::protobuf::internal::kEmptyString) {
    delete addrstr_;
  }
  if (addrstr) {
    set_has_addrstr();
    addrstr_ = addrstr;
  } else {
    clear_has_addrstr();
    addrstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string province = 11;
inline bool GPSData::has_province() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GPSData::set_has_province() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GPSData::clear_has_province() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GPSData::clear_province() {
  if (province_ != &::google::protobuf::internal::kEmptyString) {
    province_->clear();
  }
  clear_has_province();
}
inline const ::std::string& GPSData::province() const {
  return *province_;
}
inline void GPSData::set_province(const ::std::string& value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(value);
}
inline void GPSData::set_province(const char* value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(value);
}
inline void GPSData::set_province(const char* value, size_t size) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_province() {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  return province_;
}
inline ::std::string* GPSData::release_province() {
  clear_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = province_;
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_province(::std::string* province) {
  if (province_ != &::google::protobuf::internal::kEmptyString) {
    delete province_;
  }
  if (province) {
    set_has_province();
    province_ = province;
  } else {
    clear_has_province();
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city = 12;
inline bool GPSData::has_city() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GPSData::set_has_city() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GPSData::clear_has_city() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GPSData::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& GPSData::city() const {
  return *city_;
}
inline void GPSData::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void GPSData::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void GPSData::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* GPSData::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string district = 13;
inline bool GPSData::has_district() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GPSData::set_has_district() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GPSData::clear_has_district() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GPSData::clear_district() {
  if (district_ != &::google::protobuf::internal::kEmptyString) {
    district_->clear();
  }
  clear_has_district();
}
inline const ::std::string& GPSData::district() const {
  return *district_;
}
inline void GPSData::set_district(const ::std::string& value) {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  district_->assign(value);
}
inline void GPSData::set_district(const char* value) {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  district_->assign(value);
}
inline void GPSData::set_district(const char* value, size_t size) {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  district_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_district() {
  set_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    district_ = new ::std::string;
  }
  return district_;
}
inline ::std::string* GPSData::release_district() {
  clear_has_district();
  if (district_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = district_;
    district_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_district(::std::string* district) {
  if (district_ != &::google::protobuf::internal::kEmptyString) {
    delete district_;
  }
  if (district) {
    set_has_district();
    district_ = district;
  } else {
    clear_has_district();
    district_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string poi = 14;
inline bool GPSData::has_poi() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GPSData::set_has_poi() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GPSData::clear_has_poi() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GPSData::clear_poi() {
  if (poi_ != &::google::protobuf::internal::kEmptyString) {
    poi_->clear();
  }
  clear_has_poi();
}
inline const ::std::string& GPSData::poi() const {
  return *poi_;
}
inline void GPSData::set_poi(const ::std::string& value) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(value);
}
inline void GPSData::set_poi(const char* value) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(value);
}
inline void GPSData::set_poi(const char* value, size_t size) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSData::mutable_poi() {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  return poi_;
}
inline ::std::string* GPSData::release_poi() {
  clear_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = poi_;
    poi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSData::set_allocated_poi(::std::string* poi) {
  if (poi_ != &::google::protobuf::internal::kEmptyString) {
    delete poi_;
  }
  if (poi) {
    set_has_poi();
    poi_ = poi;
  } else {
    clear_has_poi();
    poi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AudioFileData

// optional string device_id = 1;
inline bool AudioFileData::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioFileData::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioFileData::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioFileData::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& AudioFileData::device_id() const {
  return *device_id_;
}
inline void AudioFileData::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void AudioFileData::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void AudioFileData::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioFileData::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* AudioFileData::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioFileData::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 2;
inline bool AudioFileData::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioFileData::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioFileData::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioFileData::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& AudioFileData::time() const {
  return *time_;
}
inline void AudioFileData::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void AudioFileData::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void AudioFileData::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioFileData::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* AudioFileData::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioFileData::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string file_name = 3;
inline bool AudioFileData::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioFileData::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioFileData::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioFileData::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& AudioFileData::file_name() const {
  return *file_name_;
}
inline void AudioFileData::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void AudioFileData::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void AudioFileData::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioFileData::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* AudioFileData::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioFileData::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dest_device = 4;
inline bool AudioFileData::has_dest_device() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioFileData::set_has_dest_device() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioFileData::clear_has_dest_device() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioFileData::clear_dest_device() {
  if (dest_device_ != &::google::protobuf::internal::kEmptyString) {
    dest_device_->clear();
  }
  clear_has_dest_device();
}
inline const ::std::string& AudioFileData::dest_device() const {
  return *dest_device_;
}
inline void AudioFileData::set_dest_device(const ::std::string& value) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(value);
}
inline void AudioFileData::set_dest_device(const char* value) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(value);
}
inline void AudioFileData::set_dest_device(const char* value, size_t size) {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  dest_device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioFileData::mutable_dest_device() {
  set_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    dest_device_ = new ::std::string;
  }
  return dest_device_;
}
inline ::std::string* AudioFileData::release_dest_device() {
  clear_has_dest_device();
  if (dest_device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dest_device_;
    dest_device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioFileData::set_allocated_dest_device(::std::string* dest_device) {
  if (dest_device_ != &::google::protobuf::internal::kEmptyString) {
    delete dest_device_;
  }
  if (dest_device) {
    set_has_dest_device();
    dest_device_ = dest_device;
  } else {
    clear_has_dest_device();
    dest_device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 total_packets = 5;
inline bool AudioFileData::has_total_packets() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AudioFileData::set_has_total_packets() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AudioFileData::clear_has_total_packets() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AudioFileData::clear_total_packets() {
  total_packets_ = 0;
  clear_has_total_packets();
}
inline ::google::protobuf::int32 AudioFileData::total_packets() const {
  return total_packets_;
}
inline void AudioFileData::set_total_packets(::google::protobuf::int32 value) {
  set_has_total_packets();
  total_packets_ = value;
}

// optional int32 current_packet = 6;
inline bool AudioFileData::has_current_packet() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AudioFileData::set_has_current_packet() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AudioFileData::clear_has_current_packet() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AudioFileData::clear_current_packet() {
  current_packet_ = 0;
  clear_has_current_packet();
}
inline ::google::protobuf::int32 AudioFileData::current_packet() const {
  return current_packet_;
}
inline void AudioFileData::set_current_packet(::google::protobuf::int32 value) {
  set_has_current_packet();
  current_packet_ = value;
}

// optional int32 data_len = 7;
inline bool AudioFileData::has_data_len() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AudioFileData::set_has_data_len() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AudioFileData::clear_has_data_len() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AudioFileData::clear_data_len() {
  data_len_ = 0;
  clear_has_data_len();
}
inline ::google::protobuf::int32 AudioFileData::data_len() const {
  return data_len_;
}
inline void AudioFileData::set_data_len(::google::protobuf::int32 value) {
  set_has_data_len();
  data_len_ = value;
}

// optional bytes data = 8;
inline bool AudioFileData::has_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AudioFileData::set_has_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AudioFileData::clear_has_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AudioFileData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& AudioFileData::data() const {
  return *data_;
}
inline void AudioFileData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AudioFileData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AudioFileData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioFileData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* AudioFileData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioFileData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CaptureFileData

// optional string device_id = 1;
inline bool CaptureFileData::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaptureFileData::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaptureFileData::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaptureFileData::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CaptureFileData::device_id() const {
  return *device_id_;
}
inline void CaptureFileData::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CaptureFileData::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CaptureFileData::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaptureFileData::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CaptureFileData::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaptureFileData::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 2;
inline bool CaptureFileData::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaptureFileData::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaptureFileData::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaptureFileData::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& CaptureFileData::time() const {
  return *time_;
}
inline void CaptureFileData::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void CaptureFileData::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void CaptureFileData::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaptureFileData::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* CaptureFileData::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaptureFileData::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string file_name = 3;
inline bool CaptureFileData::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaptureFileData::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaptureFileData::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaptureFileData::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CaptureFileData::file_name() const {
  return *file_name_;
}
inline void CaptureFileData::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CaptureFileData::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CaptureFileData::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaptureFileData::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CaptureFileData::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaptureFileData::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 total_packets = 4;
inline bool CaptureFileData::has_total_packets() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CaptureFileData::set_has_total_packets() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CaptureFileData::clear_has_total_packets() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CaptureFileData::clear_total_packets() {
  total_packets_ = 0;
  clear_has_total_packets();
}
inline ::google::protobuf::int32 CaptureFileData::total_packets() const {
  return total_packets_;
}
inline void CaptureFileData::set_total_packets(::google::protobuf::int32 value) {
  set_has_total_packets();
  total_packets_ = value;
}

// optional int32 current_packet = 5;
inline bool CaptureFileData::has_current_packet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CaptureFileData::set_has_current_packet() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CaptureFileData::clear_has_current_packet() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CaptureFileData::clear_current_packet() {
  current_packet_ = 0;
  clear_has_current_packet();
}
inline ::google::protobuf::int32 CaptureFileData::current_packet() const {
  return current_packet_;
}
inline void CaptureFileData::set_current_packet(::google::protobuf::int32 value) {
  set_has_current_packet();
  current_packet_ = value;
}

// optional int32 data_len = 6;
inline bool CaptureFileData::has_data_len() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CaptureFileData::set_has_data_len() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CaptureFileData::clear_has_data_len() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CaptureFileData::clear_data_len() {
  data_len_ = 0;
  clear_has_data_len();
}
inline ::google::protobuf::int32 CaptureFileData::data_len() const {
  return data_len_;
}
inline void CaptureFileData::set_data_len(::google::protobuf::int32 value) {
  set_has_data_len();
  data_len_ = value;
}

// optional bytes data = 7;
inline bool CaptureFileData::has_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CaptureFileData::set_has_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CaptureFileData::clear_has_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CaptureFileData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CaptureFileData::data() const {
  return *data_;
}
inline void CaptureFileData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CaptureFileData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CaptureFileData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CaptureFileData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CaptureFileData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CaptureFileData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MaterialsRequest

// optional string device_id = 1;
inline bool MaterialsRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MaterialsRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MaterialsRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MaterialsRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& MaterialsRequest::device_id() const {
  return *device_id_;
}
inline void MaterialsRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void MaterialsRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void MaterialsRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MaterialsRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* MaterialsRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MaterialsRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Material

// optional int32 material_id = 1;
inline bool Material::has_material_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Material::set_has_material_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Material::clear_has_material_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Material::clear_material_id() {
  material_id_ = 0;
  clear_has_material_id();
}
inline ::google::protobuf::int32 Material::material_id() const {
  return material_id_;
}
inline void Material::set_material_id(::google::protobuf::int32 value) {
  set_has_material_id();
  material_id_ = value;
}

// optional string english_name = 2;
inline bool Material::has_english_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Material::set_has_english_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Material::clear_has_english_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Material::clear_english_name() {
  if (english_name_ != &::google::protobuf::internal::kEmptyString) {
    english_name_->clear();
  }
  clear_has_english_name();
}
inline const ::std::string& Material::english_name() const {
  return *english_name_;
}
inline void Material::set_english_name(const ::std::string& value) {
  set_has_english_name();
  if (english_name_ == &::google::protobuf::internal::kEmptyString) {
    english_name_ = new ::std::string;
  }
  english_name_->assign(value);
}
inline void Material::set_english_name(const char* value) {
  set_has_english_name();
  if (english_name_ == &::google::protobuf::internal::kEmptyString) {
    english_name_ = new ::std::string;
  }
  english_name_->assign(value);
}
inline void Material::set_english_name(const char* value, size_t size) {
  set_has_english_name();
  if (english_name_ == &::google::protobuf::internal::kEmptyString) {
    english_name_ = new ::std::string;
  }
  english_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Material::mutable_english_name() {
  set_has_english_name();
  if (english_name_ == &::google::protobuf::internal::kEmptyString) {
    english_name_ = new ::std::string;
  }
  return english_name_;
}
inline ::std::string* Material::release_english_name() {
  clear_has_english_name();
  if (english_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = english_name_;
    english_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Material::set_allocated_english_name(::std::string* english_name) {
  if (english_name_ != &::google::protobuf::internal::kEmptyString) {
    delete english_name_;
  }
  if (english_name) {
    set_has_english_name();
    english_name_ = english_name;
  } else {
    clear_has_english_name();
    english_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string chinese_name = 3;
inline bool Material::has_chinese_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Material::set_has_chinese_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Material::clear_has_chinese_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Material::clear_chinese_name() {
  if (chinese_name_ != &::google::protobuf::internal::kEmptyString) {
    chinese_name_->clear();
  }
  clear_has_chinese_name();
}
inline const ::std::string& Material::chinese_name() const {
  return *chinese_name_;
}
inline void Material::set_chinese_name(const ::std::string& value) {
  set_has_chinese_name();
  if (chinese_name_ == &::google::protobuf::internal::kEmptyString) {
    chinese_name_ = new ::std::string;
  }
  chinese_name_->assign(value);
}
inline void Material::set_chinese_name(const char* value) {
  set_has_chinese_name();
  if (chinese_name_ == &::google::protobuf::internal::kEmptyString) {
    chinese_name_ = new ::std::string;
  }
  chinese_name_->assign(value);
}
inline void Material::set_chinese_name(const char* value, size_t size) {
  set_has_chinese_name();
  if (chinese_name_ == &::google::protobuf::internal::kEmptyString) {
    chinese_name_ = new ::std::string;
  }
  chinese_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Material::mutable_chinese_name() {
  set_has_chinese_name();
  if (chinese_name_ == &::google::protobuf::internal::kEmptyString) {
    chinese_name_ = new ::std::string;
  }
  return chinese_name_;
}
inline ::std::string* Material::release_chinese_name() {
  clear_has_chinese_name();
  if (chinese_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chinese_name_;
    chinese_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Material::set_allocated_chinese_name(::std::string* chinese_name) {
  if (chinese_name_ != &::google::protobuf::internal::kEmptyString) {
    delete chinese_name_;
  }
  if (chinese_name) {
    set_has_chinese_name();
    chinese_name_ = chinese_name;
  } else {
    clear_has_chinese_name();
    chinese_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MaterialsResponse

// repeated .zaoxun.Material material = 1;
inline int MaterialsResponse::material_size() const {
  return material_.size();
}
inline void MaterialsResponse::clear_material() {
  material_.Clear();
}
inline const ::zaoxun::Material& MaterialsResponse::material(int index) const {
  return material_.Get(index);
}
inline ::zaoxun::Material* MaterialsResponse::mutable_material(int index) {
  return material_.Mutable(index);
}
inline ::zaoxun::Material* MaterialsResponse::add_material() {
  return material_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >&
MaterialsResponse::material() const {
  return material_;
}
inline ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >*
MaterialsResponse::mutable_material() {
  return &material_;
}

// -------------------------------------------------------------------

// MaterialsNotification

// repeated .zaoxun.Material material = 1;
inline int MaterialsNotification::material_size() const {
  return material_.size();
}
inline void MaterialsNotification::clear_material() {
  material_.Clear();
}
inline const ::zaoxun::Material& MaterialsNotification::material(int index) const {
  return material_.Get(index);
}
inline ::zaoxun::Material* MaterialsNotification::mutable_material(int index) {
  return material_.Mutable(index);
}
inline ::zaoxun::Material* MaterialsNotification::add_material() {
  return material_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >&
MaterialsNotification::material() const {
  return material_;
}
inline ::google::protobuf::RepeatedPtrField< ::zaoxun::Material >*
MaterialsNotification::mutable_material() {
  return &material_;
}

// -------------------------------------------------------------------

// CollisionCarInfo

// optional string device_id = 1;
inline bool CollisionCarInfo::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionCarInfo::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionCarInfo::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionCarInfo::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CollisionCarInfo::device_id() const {
  return *device_id_;
}
inline void CollisionCarInfo::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CollisionCarInfo::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CollisionCarInfo::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollisionCarInfo::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CollisionCarInfo::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CollisionCarInfo::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .zaoxun.CarType type = 2;
inline bool CollisionCarInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollisionCarInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollisionCarInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollisionCarInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::zaoxun::CarType CollisionCarInfo::type() const {
  return static_cast< ::zaoxun::CarType >(type_);
}
inline void CollisionCarInfo::set_type(::zaoxun::CarType value) {
  assert(::zaoxun::CarType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string car_no = 3;
inline bool CollisionCarInfo::has_car_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollisionCarInfo::set_has_car_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollisionCarInfo::clear_has_car_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollisionCarInfo::clear_car_no() {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    car_no_->clear();
  }
  clear_has_car_no();
}
inline const ::std::string& CollisionCarInfo::car_no() const {
  return *car_no_;
}
inline void CollisionCarInfo::set_car_no(const ::std::string& value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void CollisionCarInfo::set_car_no(const char* value) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(value);
}
inline void CollisionCarInfo::set_car_no(const char* value, size_t size) {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  car_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollisionCarInfo::mutable_car_no() {
  set_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    car_no_ = new ::std::string;
  }
  return car_no_;
}
inline ::std::string* CollisionCarInfo::release_car_no() {
  clear_has_car_no();
  if (car_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_no_;
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CollisionCarInfo::set_allocated_car_no(::std::string* car_no) {
  if (car_no_ != &::google::protobuf::internal::kEmptyString) {
    delete car_no_;
  }
  if (car_no) {
    set_has_car_no();
    car_no_ = car_no;
  } else {
    clear_has_car_no();
    car_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 4;
inline bool CollisionCarInfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CollisionCarInfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CollisionCarInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CollisionCarInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 CollisionCarInfo::level() const {
  return level_;
}
inline void CollisionCarInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional double distance = 5;
inline bool CollisionCarInfo::has_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CollisionCarInfo::set_has_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CollisionCarInfo::clear_has_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CollisionCarInfo::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline double CollisionCarInfo::distance() const {
  return distance_;
}
inline void CollisionCarInfo::set_distance(double value) {
  set_has_distance();
  distance_ = value;
}

// optional double longitude = 6;
inline bool CollisionCarInfo::has_longitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CollisionCarInfo::set_has_longitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CollisionCarInfo::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CollisionCarInfo::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double CollisionCarInfo::longitude() const {
  return longitude_;
}
inline void CollisionCarInfo::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double latitude = 7;
inline bool CollisionCarInfo::has_latitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CollisionCarInfo::set_has_latitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CollisionCarInfo::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CollisionCarInfo::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double CollisionCarInfo::latitude() const {
  return latitude_;
}
inline void CollisionCarInfo::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// -------------------------------------------------------------------

// AntiCollisionNotification

// repeated double angle = 1;
inline int AntiCollisionNotification::angle_size() const {
  return angle_.size();
}
inline void AntiCollisionNotification::clear_angle() {
  angle_.Clear();
}
inline double AntiCollisionNotification::angle(int index) const {
  return angle_.Get(index);
}
inline void AntiCollisionNotification::set_angle(int index, double value) {
  angle_.Set(index, value);
}
inline void AntiCollisionNotification::add_angle(double value) {
  angle_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
AntiCollisionNotification::angle() const {
  return angle_;
}
inline ::google::protobuf::RepeatedField< double >*
AntiCollisionNotification::mutable_angle() {
  return &angle_;
}

// -------------------------------------------------------------------

// EDipperInfo

// optional string device_id = 1;
inline bool EDipperInfo::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EDipperInfo::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EDipperInfo::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EDipperInfo::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& EDipperInfo::device_id() const {
  return *device_id_;
}
inline void EDipperInfo::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void EDipperInfo::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void EDipperInfo::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EDipperInfo::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* EDipperInfo::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EDipperInfo::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_no = 2;
inline bool EDipperInfo::has_device_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EDipperInfo::set_has_device_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EDipperInfo::clear_has_device_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EDipperInfo::clear_device_no() {
  if (device_no_ != &::google::protobuf::internal::kEmptyString) {
    device_no_->clear();
  }
  clear_has_device_no();
}
inline const ::std::string& EDipperInfo::device_no() const {
  return *device_no_;
}
inline void EDipperInfo::set_device_no(const ::std::string& value) {
  set_has_device_no();
  if (device_no_ == &::google::protobuf::internal::kEmptyString) {
    device_no_ = new ::std::string;
  }
  device_no_->assign(value);
}
inline void EDipperInfo::set_device_no(const char* value) {
  set_has_device_no();
  if (device_no_ == &::google::protobuf::internal::kEmptyString) {
    device_no_ = new ::std::string;
  }
  device_no_->assign(value);
}
inline void EDipperInfo::set_device_no(const char* value, size_t size) {
  set_has_device_no();
  if (device_no_ == &::google::protobuf::internal::kEmptyString) {
    device_no_ = new ::std::string;
  }
  device_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EDipperInfo::mutable_device_no() {
  set_has_device_no();
  if (device_no_ == &::google::protobuf::internal::kEmptyString) {
    device_no_ = new ::std::string;
  }
  return device_no_;
}
inline ::std::string* EDipperInfo::release_device_no() {
  clear_has_device_no();
  if (device_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_no_;
    device_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EDipperInfo::set_allocated_device_no(::std::string* device_no) {
  if (device_no_ != &::google::protobuf::internal::kEmptyString) {
    delete device_no_;
  }
  if (device_no) {
    set_has_device_no();
    device_no_ = device_no;
  } else {
    clear_has_device_no();
    device_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double longitude = 3;
inline bool EDipperInfo::has_longitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EDipperInfo::set_has_longitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EDipperInfo::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EDipperInfo::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double EDipperInfo::longitude() const {
  return longitude_;
}
inline void EDipperInfo::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double latitude = 4;
inline bool EDipperInfo::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EDipperInfo::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EDipperInfo::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EDipperInfo::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double EDipperInfo::latitude() const {
  return latitude_;
}
inline void EDipperInfo::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// -------------------------------------------------------------------

// EDipperInfoNotification

// repeated .zaoxun.EDipperInfo infos = 1;
inline int EDipperInfoNotification::infos_size() const {
  return infos_.size();
}
inline void EDipperInfoNotification::clear_infos() {
  infos_.Clear();
}
inline const ::zaoxun::EDipperInfo& EDipperInfoNotification::infos(int index) const {
  return infos_.Get(index);
}
inline ::zaoxun::EDipperInfo* EDipperInfoNotification::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::zaoxun::EDipperInfo* EDipperInfoNotification::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >&
EDipperInfoNotification::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >*
EDipperInfoNotification::mutable_infos() {
  return &infos_;
}

// -------------------------------------------------------------------

// GetEDippersRequest

// optional string device_id = 1;
inline bool GetEDippersRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEDippersRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEDippersRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEDippersRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& GetEDippersRequest::device_id() const {
  return *device_id_;
}
inline void GetEDippersRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GetEDippersRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GetEDippersRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetEDippersRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* GetEDippersRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetEDippersRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetEDippersResponse

// optional string device_id = 1;
inline bool GetEDippersResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEDippersResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEDippersResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEDippersResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& GetEDippersResponse::device_id() const {
  return *device_id_;
}
inline void GetEDippersResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GetEDippersResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void GetEDippersResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetEDippersResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* GetEDippersResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetEDippersResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .zaoxun.EDipperInfo edippers = 2;
inline int GetEDippersResponse::edippers_size() const {
  return edippers_.size();
}
inline void GetEDippersResponse::clear_edippers() {
  edippers_.Clear();
}
inline const ::zaoxun::EDipperInfo& GetEDippersResponse::edippers(int index) const {
  return edippers_.Get(index);
}
inline ::zaoxun::EDipperInfo* GetEDippersResponse::mutable_edippers(int index) {
  return edippers_.Mutable(index);
}
inline ::zaoxun::EDipperInfo* GetEDippersResponse::add_edippers() {
  return edippers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >&
GetEDippersResponse::edippers() const {
  return edippers_;
}
inline ::google::protobuf::RepeatedPtrField< ::zaoxun::EDipperInfo >*
GetEDippersResponse::mutable_edippers() {
  return &edippers_;
}

// -------------------------------------------------------------------

// LoadCompleteRequest

// optional string edipper_device_id = 1;
inline bool LoadCompleteRequest::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadCompleteRequest::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadCompleteRequest::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadCompleteRequest::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& LoadCompleteRequest::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void LoadCompleteRequest::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadCompleteRequest::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadCompleteRequest::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadCompleteRequest::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* LoadCompleteRequest::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadCompleteRequest::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_device_id = 2;
inline bool LoadCompleteRequest::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadCompleteRequest::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadCompleteRequest::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadCompleteRequest::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& LoadCompleteRequest::car_device_id() const {
  return *car_device_id_;
}
inline void LoadCompleteRequest::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void LoadCompleteRequest::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void LoadCompleteRequest::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadCompleteRequest::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* LoadCompleteRequest::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadCompleteRequest::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 load_result = 3;
inline bool LoadCompleteRequest::has_load_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadCompleteRequest::set_has_load_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadCompleteRequest::clear_has_load_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadCompleteRequest::clear_load_result() {
  load_result_ = 0;
  clear_has_load_result();
}
inline ::google::protobuf::int32 LoadCompleteRequest::load_result() const {
  return load_result_;
}
inline void LoadCompleteRequest::set_load_result(::google::protobuf::int32 value) {
  set_has_load_result();
  load_result_ = value;
}

// -------------------------------------------------------------------

// LoadCompleteResponse

// optional string edipper_device_id = 1;
inline bool LoadCompleteResponse::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadCompleteResponse::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadCompleteResponse::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadCompleteResponse::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& LoadCompleteResponse::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void LoadCompleteResponse::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadCompleteResponse::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void LoadCompleteResponse::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadCompleteResponse::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* LoadCompleteResponse::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadCompleteResponse::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_device_id = 2;
inline bool LoadCompleteResponse::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadCompleteResponse::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadCompleteResponse::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadCompleteResponse::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& LoadCompleteResponse::car_device_id() const {
  return *car_device_id_;
}
inline void LoadCompleteResponse::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void LoadCompleteResponse::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void LoadCompleteResponse::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadCompleteResponse::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* LoadCompleteResponse::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadCompleteResponse::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 3;
inline bool LoadCompleteResponse::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadCompleteResponse::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadCompleteResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadCompleteResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoadCompleteResponse::result() const {
  return result_;
}
inline void LoadCompleteResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ManualLoadCompleteRequest

// optional string edipper_device_id = 1;
inline bool ManualLoadCompleteRequest::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManualLoadCompleteRequest::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManualLoadCompleteRequest::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManualLoadCompleteRequest::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& ManualLoadCompleteRequest::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void ManualLoadCompleteRequest::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void ManualLoadCompleteRequest::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void ManualLoadCompleteRequest::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManualLoadCompleteRequest::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* ManualLoadCompleteRequest::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ManualLoadCompleteRequest::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_device_id = 2;
inline bool ManualLoadCompleteRequest::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManualLoadCompleteRequest::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManualLoadCompleteRequest::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManualLoadCompleteRequest::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& ManualLoadCompleteRequest::car_device_id() const {
  return *car_device_id_;
}
inline void ManualLoadCompleteRequest::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void ManualLoadCompleteRequest::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void ManualLoadCompleteRequest::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManualLoadCompleteRequest::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* ManualLoadCompleteRequest::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ManualLoadCompleteRequest::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 material_id = 3;
inline bool ManualLoadCompleteRequest::has_material_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManualLoadCompleteRequest::set_has_material_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManualLoadCompleteRequest::clear_has_material_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManualLoadCompleteRequest::clear_material_id() {
  material_id_ = 0;
  clear_has_material_id();
}
inline ::google::protobuf::int32 ManualLoadCompleteRequest::material_id() const {
  return material_id_;
}
inline void ManualLoadCompleteRequest::set_material_id(::google::protobuf::int32 value) {
  set_has_material_id();
  material_id_ = value;
}

// optional int32 load_result = 4;
inline bool ManualLoadCompleteRequest::has_load_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManualLoadCompleteRequest::set_has_load_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManualLoadCompleteRequest::clear_has_load_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManualLoadCompleteRequest::clear_load_result() {
  load_result_ = 0;
  clear_has_load_result();
}
inline ::google::protobuf::int32 ManualLoadCompleteRequest::load_result() const {
  return load_result_;
}
inline void ManualLoadCompleteRequest::set_load_result(::google::protobuf::int32 value) {
  set_has_load_result();
  load_result_ = value;
}

// -------------------------------------------------------------------

// ManualLoadCompleteResponse

// optional string edipper_device_id = 1;
inline bool ManualLoadCompleteResponse::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManualLoadCompleteResponse::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManualLoadCompleteResponse::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManualLoadCompleteResponse::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& ManualLoadCompleteResponse::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void ManualLoadCompleteResponse::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void ManualLoadCompleteResponse::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void ManualLoadCompleteResponse::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManualLoadCompleteResponse::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* ManualLoadCompleteResponse::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ManualLoadCompleteResponse::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_device_id = 2;
inline bool ManualLoadCompleteResponse::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManualLoadCompleteResponse::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManualLoadCompleteResponse::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManualLoadCompleteResponse::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& ManualLoadCompleteResponse::car_device_id() const {
  return *car_device_id_;
}
inline void ManualLoadCompleteResponse::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void ManualLoadCompleteResponse::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void ManualLoadCompleteResponse::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManualLoadCompleteResponse::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* ManualLoadCompleteResponse::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ManualLoadCompleteResponse::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 material_id = 3;
inline bool ManualLoadCompleteResponse::has_material_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManualLoadCompleteResponse::set_has_material_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManualLoadCompleteResponse::clear_has_material_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManualLoadCompleteResponse::clear_material_id() {
  material_id_ = 0;
  clear_has_material_id();
}
inline ::google::protobuf::int32 ManualLoadCompleteResponse::material_id() const {
  return material_id_;
}
inline void ManualLoadCompleteResponse::set_material_id(::google::protobuf::int32 value) {
  set_has_material_id();
  material_id_ = value;
}

// optional int32 result = 4;
inline bool ManualLoadCompleteResponse::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManualLoadCompleteResponse::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManualLoadCompleteResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManualLoadCompleteResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ManualLoadCompleteResponse::result() const {
  return result_;
}
inline void ManualLoadCompleteResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// CancelLoadRequest

// optional string car_device_id = 1;
inline bool CancelLoadRequest::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelLoadRequest::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelLoadRequest::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelLoadRequest::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& CancelLoadRequest::car_device_id() const {
  return *car_device_id_;
}
inline void CancelLoadRequest::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void CancelLoadRequest::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void CancelLoadRequest::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelLoadRequest::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* CancelLoadRequest::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CancelLoadRequest::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool CancelLoadRequest::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelLoadRequest::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelLoadRequest::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelLoadRequest::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& CancelLoadRequest::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void CancelLoadRequest::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void CancelLoadRequest::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void CancelLoadRequest::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelLoadRequest::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* CancelLoadRequest::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CancelLoadRequest::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CancelLoadResponse

// optional string car_device_id = 1;
inline bool CancelLoadResponse::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelLoadResponse::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelLoadResponse::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelLoadResponse::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& CancelLoadResponse::car_device_id() const {
  return *car_device_id_;
}
inline void CancelLoadResponse::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void CancelLoadResponse::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void CancelLoadResponse::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelLoadResponse::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* CancelLoadResponse::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CancelLoadResponse::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edipper_device_id = 2;
inline bool CancelLoadResponse::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelLoadResponse::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelLoadResponse::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelLoadResponse::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& CancelLoadResponse::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void CancelLoadResponse::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void CancelLoadResponse::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void CancelLoadResponse::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelLoadResponse::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* CancelLoadResponse::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CancelLoadResponse::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 3;
inline bool CancelLoadResponse::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CancelLoadResponse::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CancelLoadResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CancelLoadResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CancelLoadResponse::result() const {
  return result_;
}
inline void CancelLoadResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RejectLoadRequest

// optional string edipper_device_id = 1;
inline bool RejectLoadRequest::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectLoadRequest::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejectLoadRequest::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejectLoadRequest::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& RejectLoadRequest::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void RejectLoadRequest::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void RejectLoadRequest::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void RejectLoadRequest::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RejectLoadRequest::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* RejectLoadRequest::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RejectLoadRequest::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_device_id = 2;
inline bool RejectLoadRequest::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectLoadRequest::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejectLoadRequest::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejectLoadRequest::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& RejectLoadRequest::car_device_id() const {
  return *car_device_id_;
}
inline void RejectLoadRequest::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void RejectLoadRequest::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void RejectLoadRequest::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RejectLoadRequest::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* RejectLoadRequest::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RejectLoadRequest::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RejectLoadResponse

// optional string edipper_device_id = 1;
inline bool RejectLoadResponse::has_edipper_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectLoadResponse::set_has_edipper_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejectLoadResponse::clear_has_edipper_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejectLoadResponse::clear_edipper_device_id() {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_->clear();
  }
  clear_has_edipper_device_id();
}
inline const ::std::string& RejectLoadResponse::edipper_device_id() const {
  return *edipper_device_id_;
}
inline void RejectLoadResponse::set_edipper_device_id(const ::std::string& value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void RejectLoadResponse::set_edipper_device_id(const char* value) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(value);
}
inline void RejectLoadResponse::set_edipper_device_id(const char* value, size_t size) {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  edipper_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RejectLoadResponse::mutable_edipper_device_id() {
  set_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    edipper_device_id_ = new ::std::string;
  }
  return edipper_device_id_;
}
inline ::std::string* RejectLoadResponse::release_edipper_device_id() {
  clear_has_edipper_device_id();
  if (edipper_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edipper_device_id_;
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RejectLoadResponse::set_allocated_edipper_device_id(::std::string* edipper_device_id) {
  if (edipper_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete edipper_device_id_;
  }
  if (edipper_device_id) {
    set_has_edipper_device_id();
    edipper_device_id_ = edipper_device_id;
  } else {
    clear_has_edipper_device_id();
    edipper_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string car_device_id = 2;
inline bool RejectLoadResponse::has_car_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectLoadResponse::set_has_car_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejectLoadResponse::clear_has_car_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejectLoadResponse::clear_car_device_id() {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    car_device_id_->clear();
  }
  clear_has_car_device_id();
}
inline const ::std::string& RejectLoadResponse::car_device_id() const {
  return *car_device_id_;
}
inline void RejectLoadResponse::set_car_device_id(const ::std::string& value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void RejectLoadResponse::set_car_device_id(const char* value) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(value);
}
inline void RejectLoadResponse::set_car_device_id(const char* value, size_t size) {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  car_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RejectLoadResponse::mutable_car_device_id() {
  set_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    car_device_id_ = new ::std::string;
  }
  return car_device_id_;
}
inline ::std::string* RejectLoadResponse::release_car_device_id() {
  clear_has_car_device_id();
  if (car_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = car_device_id_;
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RejectLoadResponse::set_allocated_car_device_id(::std::string* car_device_id) {
  if (car_device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete car_device_id_;
  }
  if (car_device_id) {
    set_has_car_device_id();
    car_device_id_ = car_device_id;
  } else {
    clear_has_car_device_id();
    car_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 3;
inline bool RejectLoadResponse::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RejectLoadResponse::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RejectLoadResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RejectLoadResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RejectLoadResponse::result() const {
  return result_;
}
inline void RejectLoadResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ExitNotification

// optional string device_id = 1;
inline bool ExitNotification::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitNotification::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitNotification::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitNotification::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ExitNotification::device_id() const {
  return *device_id_;
}
inline void ExitNotification::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ExitNotification::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ExitNotification::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExitNotification::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ExitNotification::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExitNotification::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exit_type = 2;
inline bool ExitNotification::has_exit_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExitNotification::set_has_exit_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExitNotification::clear_has_exit_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExitNotification::clear_exit_type() {
  exit_type_ = 0;
  clear_has_exit_type();
}
inline ::google::protobuf::int32 ExitNotification::exit_type() const {
  return exit_type_;
}
inline void ExitNotification::set_exit_type(::google::protobuf::int32 value) {
  set_has_exit_type();
  exit_type_ = value;
}

// -------------------------------------------------------------------

// DeviceStatusRequest

// optional string device_id = 1;
inline bool DeviceStatusRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStatusRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceStatusRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceStatusRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& DeviceStatusRequest::device_id() const {
  return *device_id_;
}
inline void DeviceStatusRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DeviceStatusRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DeviceStatusRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceStatusRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* DeviceStatusRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceStatusRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .zaoxun.RunningStatus status = 2;
inline bool DeviceStatusRequest::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceStatusRequest::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceStatusRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceStatusRequest::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::zaoxun::RunningStatus DeviceStatusRequest::status() const {
  return static_cast< ::zaoxun::RunningStatus >(status_);
}
inline void DeviceStatusRequest::set_status(::zaoxun::RunningStatus value) {
  assert(::zaoxun::RunningStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional int32 type = 3;
inline bool DeviceStatusRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceStatusRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceStatusRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceStatusRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DeviceStatusRequest::type() const {
  return type_;
}
inline void DeviceStatusRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 update_time = 4;
inline bool DeviceStatusRequest::has_update_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceStatusRequest::set_has_update_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceStatusRequest::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceStatusRequest::clear_update_time() {
  update_time_ = 0;
  clear_has_update_time();
}
inline ::google::protobuf::int32 DeviceStatusRequest::update_time() const {
  return update_time_;
}
inline void DeviceStatusRequest::set_update_time(::google::protobuf::int32 value) {
  set_has_update_time();
  update_time_ = value;
}

// -------------------------------------------------------------------

// DeviceStatusResponse

// optional string device_id = 1;
inline bool DeviceStatusResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceStatusResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceStatusResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceStatusResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& DeviceStatusResponse::device_id() const {
  return *device_id_;
}
inline void DeviceStatusResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DeviceStatusResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void DeviceStatusResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceStatusResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* DeviceStatusResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceStatusResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 2;
inline bool DeviceStatusResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceStatusResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceStatusResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceStatusResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 DeviceStatusResponse::result() const {
  return result_;
}
inline void DeviceStatusResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 update_time = 3;
inline bool DeviceStatusResponse::has_update_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceStatusResponse::set_has_update_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceStatusResponse::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceStatusResponse::clear_update_time() {
  update_time_ = 0;
  clear_has_update_time();
}
inline ::google::protobuf::int32 DeviceStatusResponse::update_time() const {
  return update_time_;
}
inline void DeviceStatusResponse::set_update_time(::google::protobuf::int32 value) {
  set_has_update_time();
  update_time_ = value;
}

// -------------------------------------------------------------------

// CommandRequest

// optional string device_id = 1;
inline bool CommandRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CommandRequest::device_id() const {
  return *device_id_;
}
inline void CommandRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CommandRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CommandRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CommandRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 cmd_id = 2;
inline bool CommandRequest::has_cmd_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRequest::set_has_cmd_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRequest::clear_has_cmd_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRequest::clear_cmd_id() {
  cmd_id_ = 0;
  clear_has_cmd_id();
}
inline ::google::protobuf::int32 CommandRequest::cmd_id() const {
  return cmd_id_;
}
inline void CommandRequest::set_cmd_id(::google::protobuf::int32 value) {
  set_has_cmd_id();
  cmd_id_ = value;
}

// optional int32 type = 3;
inline bool CommandRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CommandRequest::type() const {
  return type_;
}
inline void CommandRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string time = 4;
inline bool CommandRequest::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRequest::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRequest::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& CommandRequest::time() const {
  return *time_;
}
inline void CommandRequest::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void CommandRequest::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void CommandRequest::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandRequest::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* CommandRequest::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandRequest::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 5;
inline bool CommandRequest::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandRequest::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandRequest::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandRequest::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& CommandRequest::content() const {
  return *content_;
}
inline void CommandRequest::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void CommandRequest::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void CommandRequest::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandRequest::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* CommandRequest::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandRequest::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CommandResponse

// optional string device_id = 1;
inline bool CommandResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& CommandResponse::device_id() const {
  return *device_id_;
}
inline void CommandResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CommandResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void CommandResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* CommandResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 cmd_id = 2;
inline bool CommandResponse::has_cmd_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandResponse::set_has_cmd_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandResponse::clear_has_cmd_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandResponse::clear_cmd_id() {
  cmd_id_ = 0;
  clear_has_cmd_id();
}
inline ::google::protobuf::int32 CommandResponse::cmd_id() const {
  return cmd_id_;
}
inline void CommandResponse::set_cmd_id(::google::protobuf::int32 value) {
  set_has_cmd_id();
  cmd_id_ = value;
}

// optional int32 result = 3;
inline bool CommandResponse::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandResponse::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CommandResponse::result() const {
  return result_;
}
inline void CommandResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ProductionInfoRequest

// optional string device_id = 1;
inline bool ProductionInfoRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductionInfoRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductionInfoRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductionInfoRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ProductionInfoRequest::device_id() const {
  return *device_id_;
}
inline void ProductionInfoRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionInfoRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionInfoRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductionInfoRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ProductionInfoRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProductionInfoRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProductionInfoResponse

// optional string device_id = 1;
inline bool ProductionInfoResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductionInfoResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductionInfoResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductionInfoResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ProductionInfoResponse::device_id() const {
  return *device_id_;
}
inline void ProductionInfoResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionInfoResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ProductionInfoResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductionInfoResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ProductionInfoResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProductionInfoResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 times = 2;
inline bool ProductionInfoResponse::has_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductionInfoResponse::set_has_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductionInfoResponse::clear_has_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductionInfoResponse::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ProductionInfoResponse::times() const {
  return times_;
}
inline void ProductionInfoResponse::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// optional double distance = 3;
inline bool ProductionInfoResponse::has_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProductionInfoResponse::set_has_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProductionInfoResponse::clear_has_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProductionInfoResponse::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline double ProductionInfoResponse::distance() const {
  return distance_;
}
inline void ProductionInfoResponse::set_distance(double value) {
  set_has_distance();
  distance_ = value;
}

// optional double ton = 4;
inline bool ProductionInfoResponse::has_ton() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProductionInfoResponse::set_has_ton() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProductionInfoResponse::clear_has_ton() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProductionInfoResponse::clear_ton() {
  ton_ = 0;
  clear_has_ton();
}
inline double ProductionInfoResponse::ton() const {
  return ton_;
}
inline void ProductionInfoResponse::set_ton(double value) {
  set_has_ton();
  ton_ = value;
}

// optional double fill = 5;
inline bool ProductionInfoResponse::has_fill() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProductionInfoResponse::set_has_fill() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProductionInfoResponse::clear_has_fill() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProductionInfoResponse::clear_fill() {
  fill_ = 0;
  clear_has_fill();
}
inline double ProductionInfoResponse::fill() const {
  return fill_;
}
inline void ProductionInfoResponse::set_fill(double value) {
  set_has_fill();
  fill_ = value;
}

// optional double temp = 6;
inline bool ProductionInfoResponse::has_temp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProductionInfoResponse::set_has_temp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProductionInfoResponse::clear_has_temp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProductionInfoResponse::clear_temp() {
  temp_ = 0;
  clear_has_temp();
}
inline double ProductionInfoResponse::temp() const {
  return temp_;
}
inline void ProductionInfoResponse::set_temp(double value) {
  set_has_temp();
  temp_ = value;
}

// -------------------------------------------------------------------

// FuelRequest

// optional string device_id = 1;
inline bool FuelRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FuelRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FuelRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FuelRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& FuelRequest::device_id() const {
  return *device_id_;
}
inline void FuelRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void FuelRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void FuelRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FuelRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* FuelRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FuelRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target_device_name = 2;
inline bool FuelRequest::has_target_device_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FuelRequest::set_has_target_device_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FuelRequest::clear_has_target_device_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FuelRequest::clear_target_device_name() {
  if (target_device_name_ != &::google::protobuf::internal::kEmptyString) {
    target_device_name_->clear();
  }
  clear_has_target_device_name();
}
inline const ::std::string& FuelRequest::target_device_name() const {
  return *target_device_name_;
}
inline void FuelRequest::set_target_device_name(const ::std::string& value) {
  set_has_target_device_name();
  if (target_device_name_ == &::google::protobuf::internal::kEmptyString) {
    target_device_name_ = new ::std::string;
  }
  target_device_name_->assign(value);
}
inline void FuelRequest::set_target_device_name(const char* value) {
  set_has_target_device_name();
  if (target_device_name_ == &::google::protobuf::internal::kEmptyString) {
    target_device_name_ = new ::std::string;
  }
  target_device_name_->assign(value);
}
inline void FuelRequest::set_target_device_name(const char* value, size_t size) {
  set_has_target_device_name();
  if (target_device_name_ == &::google::protobuf::internal::kEmptyString) {
    target_device_name_ = new ::std::string;
  }
  target_device_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FuelRequest::mutable_target_device_name() {
  set_has_target_device_name();
  if (target_device_name_ == &::google::protobuf::internal::kEmptyString) {
    target_device_name_ = new ::std::string;
  }
  return target_device_name_;
}
inline ::std::string* FuelRequest::release_target_device_name() {
  clear_has_target_device_name();
  if (target_device_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_device_name_;
    target_device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FuelRequest::set_allocated_target_device_name(::std::string* target_device_name) {
  if (target_device_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_device_name_;
  }
  if (target_device_name) {
    set_has_target_device_name();
    target_device_name_ = target_device_name;
  } else {
    clear_has_target_device_name();
    target_device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double volume = 3;
inline bool FuelRequest::has_volume() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FuelRequest::set_has_volume() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FuelRequest::clear_has_volume() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FuelRequest::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double FuelRequest::volume() const {
  return volume_;
}
inline void FuelRequest::set_volume(double value) {
  set_has_volume();
  volume_ = value;
}

// optional int32 type = 4;
inline bool FuelRequest::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FuelRequest::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FuelRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FuelRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FuelRequest::type() const {
  return type_;
}
inline void FuelRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 mode = 5;
inline bool FuelRequest::has_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FuelRequest::set_has_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FuelRequest::clear_has_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FuelRequest::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 FuelRequest::mode() const {
  return mode_;
}
inline void FuelRequest::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// FuelResponse

// optional string device_id = 1;
inline bool FuelResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FuelResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FuelResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FuelResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& FuelResponse::device_id() const {
  return *device_id_;
}
inline void FuelResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void FuelResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void FuelResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FuelResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* FuelResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FuelResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target_device_name = 2;
inline bool FuelResponse::has_target_device_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FuelResponse::set_has_target_device_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FuelResponse::clear_has_target_device_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FuelResponse::clear_target_device_name() {
  if (target_device_name_ != &::google::protobuf::internal::kEmptyString) {
    target_device_name_->clear();
  }
  clear_has_target_device_name();
}
inline const ::std::string& FuelResponse::target_device_name() const {
  return *target_device_name_;
}
inline void FuelResponse::set_target_device_name(const ::std::string& value) {
  set_has_target_device_name();
  if (target_device_name_ == &::google::protobuf::internal::kEmptyString) {
    target_device_name_ = new ::std::string;
  }
  target_device_name_->assign(value);
}
inline void FuelResponse::set_target_device_name(const char* value) {
  set_has_target_device_name();
  if (target_device_name_ == &::google::protobuf::internal::kEmptyString) {
    target_device_name_ = new ::std::string;
  }
  target_device_name_->assign(value);
}
inline void FuelResponse::set_target_device_name(const char* value, size_t size) {
  set_has_target_device_name();
  if (target_device_name_ == &::google::protobuf::internal::kEmptyString) {
    target_device_name_ = new ::std::string;
  }
  target_device_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FuelResponse::mutable_target_device_name() {
  set_has_target_device_name();
  if (target_device_name_ == &::google::protobuf::internal::kEmptyString) {
    target_device_name_ = new ::std::string;
  }
  return target_device_name_;
}
inline ::std::string* FuelResponse::release_target_device_name() {
  clear_has_target_device_name();
  if (target_device_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_device_name_;
    target_device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FuelResponse::set_allocated_target_device_name(::std::string* target_device_name) {
  if (target_device_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_device_name_;
  }
  if (target_device_name) {
    set_has_target_device_name();
    target_device_name_ = target_device_name;
  } else {
    clear_has_target_device_name();
    target_device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double volume = 3;
inline bool FuelResponse::has_volume() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FuelResponse::set_has_volume() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FuelResponse::clear_has_volume() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FuelResponse::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double FuelResponse::volume() const {
  return volume_;
}
inline void FuelResponse::set_volume(double value) {
  set_has_volume();
  volume_ = value;
}

// optional int32 result = 4;
inline bool FuelResponse::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FuelResponse::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FuelResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FuelResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 FuelResponse::result() const {
  return result_;
}
inline void FuelResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// HeartBeat

// optional int32 value = 1;
inline bool HeartBeat::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartBeat::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartBeat::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartBeat::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 HeartBeat::value() const {
  return value_;
}
inline void HeartBeat::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// TargetNotification

// optional string device_id = 1;
inline bool TargetNotification::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetNotification::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetNotification::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetNotification::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& TargetNotification::device_id() const {
  return *device_id_;
}
inline void TargetNotification::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void TargetNotification::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void TargetNotification::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetNotification::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* TargetNotification::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetNotification::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double longitude = 2;
inline bool TargetNotification::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetNotification::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetNotification::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetNotification::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double TargetNotification::longitude() const {
  return longitude_;
}
inline void TargetNotification::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double latitude = 3;
inline bool TargetNotification::has_latitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TargetNotification::set_has_latitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TargetNotification::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TargetNotification::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double TargetNotification::latitude() const {
  return latitude_;
}
inline void TargetNotification::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// -------------------------------------------------------------------

// CommonMessage

// optional .zaoxun.MessageType type = 1;
inline bool CommonMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::zaoxun::MessageType CommonMessage::type() const {
  return static_cast< ::zaoxun::MessageType >(type_);
}
inline void CommonMessage::set_type(::zaoxun::MessageType value) {
  assert(::zaoxun::MessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .zaoxun.LoginRequest login_request = 2;
inline bool CommonMessage::has_login_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonMessage::set_has_login_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonMessage::clear_has_login_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonMessage::clear_login_request() {
  if (login_request_ != NULL) login_request_->::zaoxun::LoginRequest::Clear();
  clear_has_login_request();
}
inline const ::zaoxun::LoginRequest& CommonMessage::login_request() const {
  return login_request_ != NULL ? *login_request_ : *default_instance_->login_request_;
}
inline ::zaoxun::LoginRequest* CommonMessage::mutable_login_request() {
  set_has_login_request();
  if (login_request_ == NULL) login_request_ = new ::zaoxun::LoginRequest;
  return login_request_;
}
inline ::zaoxun::LoginRequest* CommonMessage::release_login_request() {
  clear_has_login_request();
  ::zaoxun::LoginRequest* temp = login_request_;
  login_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_login_request(::zaoxun::LoginRequest* login_request) {
  delete login_request_;
  login_request_ = login_request;
  if (login_request) {
    set_has_login_request();
  } else {
    clear_has_login_request();
  }
}

// optional .zaoxun.LoginResponse login_response = 3;
inline bool CommonMessage::has_login_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonMessage::set_has_login_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonMessage::clear_has_login_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonMessage::clear_login_response() {
  if (login_response_ != NULL) login_response_->::zaoxun::LoginResponse::Clear();
  clear_has_login_response();
}
inline const ::zaoxun::LoginResponse& CommonMessage::login_response() const {
  return login_response_ != NULL ? *login_response_ : *default_instance_->login_response_;
}
inline ::zaoxun::LoginResponse* CommonMessage::mutable_login_response() {
  set_has_login_response();
  if (login_response_ == NULL) login_response_ = new ::zaoxun::LoginResponse;
  return login_response_;
}
inline ::zaoxun::LoginResponse* CommonMessage::release_login_response() {
  clear_has_login_response();
  ::zaoxun::LoginResponse* temp = login_response_;
  login_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_login_response(::zaoxun::LoginResponse* login_response) {
  delete login_response_;
  login_response_ = login_response;
  if (login_response) {
    set_has_login_response();
  } else {
    clear_has_login_response();
  }
}

// optional .zaoxun.CheckRequest check_request = 4;
inline bool CommonMessage::has_check_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonMessage::set_has_check_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonMessage::clear_has_check_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonMessage::clear_check_request() {
  if (check_request_ != NULL) check_request_->::zaoxun::CheckRequest::Clear();
  clear_has_check_request();
}
inline const ::zaoxun::CheckRequest& CommonMessage::check_request() const {
  return check_request_ != NULL ? *check_request_ : *default_instance_->check_request_;
}
inline ::zaoxun::CheckRequest* CommonMessage::mutable_check_request() {
  set_has_check_request();
  if (check_request_ == NULL) check_request_ = new ::zaoxun::CheckRequest;
  return check_request_;
}
inline ::zaoxun::CheckRequest* CommonMessage::release_check_request() {
  clear_has_check_request();
  ::zaoxun::CheckRequest* temp = check_request_;
  check_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_check_request(::zaoxun::CheckRequest* check_request) {
  delete check_request_;
  check_request_ = check_request;
  if (check_request) {
    set_has_check_request();
  } else {
    clear_has_check_request();
  }
}

// optional .zaoxun.CheckResponse check_response = 5;
inline bool CommonMessage::has_check_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonMessage::set_has_check_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonMessage::clear_has_check_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonMessage::clear_check_response() {
  if (check_response_ != NULL) check_response_->::zaoxun::CheckResponse::Clear();
  clear_has_check_response();
}
inline const ::zaoxun::CheckResponse& CommonMessage::check_response() const {
  return check_response_ != NULL ? *check_response_ : *default_instance_->check_response_;
}
inline ::zaoxun::CheckResponse* CommonMessage::mutable_check_response() {
  set_has_check_response();
  if (check_response_ == NULL) check_response_ = new ::zaoxun::CheckResponse;
  return check_response_;
}
inline ::zaoxun::CheckResponse* CommonMessage::release_check_response() {
  clear_has_check_response();
  ::zaoxun::CheckResponse* temp = check_response_;
  check_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_check_response(::zaoxun::CheckResponse* check_response) {
  delete check_response_;
  check_response_ = check_response;
  if (check_response) {
    set_has_check_response();
  } else {
    clear_has_check_response();
  }
}

// optional .zaoxun.OilQuantityRequest oil_quantity_request = 6;
inline bool CommonMessage::has_oil_quantity_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonMessage::set_has_oil_quantity_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonMessage::clear_has_oil_quantity_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonMessage::clear_oil_quantity_request() {
  if (oil_quantity_request_ != NULL) oil_quantity_request_->::zaoxun::OilQuantityRequest::Clear();
  clear_has_oil_quantity_request();
}
inline const ::zaoxun::OilQuantityRequest& CommonMessage::oil_quantity_request() const {
  return oil_quantity_request_ != NULL ? *oil_quantity_request_ : *default_instance_->oil_quantity_request_;
}
inline ::zaoxun::OilQuantityRequest* CommonMessage::mutable_oil_quantity_request() {
  set_has_oil_quantity_request();
  if (oil_quantity_request_ == NULL) oil_quantity_request_ = new ::zaoxun::OilQuantityRequest;
  return oil_quantity_request_;
}
inline ::zaoxun::OilQuantityRequest* CommonMessage::release_oil_quantity_request() {
  clear_has_oil_quantity_request();
  ::zaoxun::OilQuantityRequest* temp = oil_quantity_request_;
  oil_quantity_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_oil_quantity_request(::zaoxun::OilQuantityRequest* oil_quantity_request) {
  delete oil_quantity_request_;
  oil_quantity_request_ = oil_quantity_request;
  if (oil_quantity_request) {
    set_has_oil_quantity_request();
  } else {
    clear_has_oil_quantity_request();
  }
}

// optional .zaoxun.OilQuantityResponse oil_quantity_response = 7;
inline bool CommonMessage::has_oil_quantity_response() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommonMessage::set_has_oil_quantity_response() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommonMessage::clear_has_oil_quantity_response() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommonMessage::clear_oil_quantity_response() {
  if (oil_quantity_response_ != NULL) oil_quantity_response_->::zaoxun::OilQuantityResponse::Clear();
  clear_has_oil_quantity_response();
}
inline const ::zaoxun::OilQuantityResponse& CommonMessage::oil_quantity_response() const {
  return oil_quantity_response_ != NULL ? *oil_quantity_response_ : *default_instance_->oil_quantity_response_;
}
inline ::zaoxun::OilQuantityResponse* CommonMessage::mutable_oil_quantity_response() {
  set_has_oil_quantity_response();
  if (oil_quantity_response_ == NULL) oil_quantity_response_ = new ::zaoxun::OilQuantityResponse;
  return oil_quantity_response_;
}
inline ::zaoxun::OilQuantityResponse* CommonMessage::release_oil_quantity_response() {
  clear_has_oil_quantity_response();
  ::zaoxun::OilQuantityResponse* temp = oil_quantity_response_;
  oil_quantity_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_oil_quantity_response(::zaoxun::OilQuantityResponse* oil_quantity_response) {
  delete oil_quantity_response_;
  oil_quantity_response_ = oil_quantity_response;
  if (oil_quantity_response) {
    set_has_oil_quantity_response();
  } else {
    clear_has_oil_quantity_response();
  }
}

// optional .zaoxun.ProductionRequest production_request = 8;
inline bool CommonMessage::has_production_request() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommonMessage::set_has_production_request() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommonMessage::clear_has_production_request() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommonMessage::clear_production_request() {
  if (production_request_ != NULL) production_request_->::zaoxun::ProductionRequest::Clear();
  clear_has_production_request();
}
inline const ::zaoxun::ProductionRequest& CommonMessage::production_request() const {
  return production_request_ != NULL ? *production_request_ : *default_instance_->production_request_;
}
inline ::zaoxun::ProductionRequest* CommonMessage::mutable_production_request() {
  set_has_production_request();
  if (production_request_ == NULL) production_request_ = new ::zaoxun::ProductionRequest;
  return production_request_;
}
inline ::zaoxun::ProductionRequest* CommonMessage::release_production_request() {
  clear_has_production_request();
  ::zaoxun::ProductionRequest* temp = production_request_;
  production_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_production_request(::zaoxun::ProductionRequest* production_request) {
  delete production_request_;
  production_request_ = production_request;
  if (production_request) {
    set_has_production_request();
  } else {
    clear_has_production_request();
  }
}

// optional .zaoxun.ProductionResponse production_response = 9;
inline bool CommonMessage::has_production_response() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommonMessage::set_has_production_response() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommonMessage::clear_has_production_response() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommonMessage::clear_production_response() {
  if (production_response_ != NULL) production_response_->::zaoxun::ProductionResponse::Clear();
  clear_has_production_response();
}
inline const ::zaoxun::ProductionResponse& CommonMessage::production_response() const {
  return production_response_ != NULL ? *production_response_ : *default_instance_->production_response_;
}
inline ::zaoxun::ProductionResponse* CommonMessage::mutable_production_response() {
  set_has_production_response();
  if (production_response_ == NULL) production_response_ = new ::zaoxun::ProductionResponse;
  return production_response_;
}
inline ::zaoxun::ProductionResponse* CommonMessage::release_production_response() {
  clear_has_production_response();
  ::zaoxun::ProductionResponse* temp = production_response_;
  production_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_production_response(::zaoxun::ProductionResponse* production_response) {
  delete production_response_;
  production_response_ = production_response;
  if (production_response) {
    set_has_production_response();
  } else {
    clear_has_production_response();
  }
}

// optional .zaoxun.DistanceRequest distance_request = 10;
inline bool CommonMessage::has_distance_request() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommonMessage::set_has_distance_request() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommonMessage::clear_has_distance_request() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommonMessage::clear_distance_request() {
  if (distance_request_ != NULL) distance_request_->::zaoxun::DistanceRequest::Clear();
  clear_has_distance_request();
}
inline const ::zaoxun::DistanceRequest& CommonMessage::distance_request() const {
  return distance_request_ != NULL ? *distance_request_ : *default_instance_->distance_request_;
}
inline ::zaoxun::DistanceRequest* CommonMessage::mutable_distance_request() {
  set_has_distance_request();
  if (distance_request_ == NULL) distance_request_ = new ::zaoxun::DistanceRequest;
  return distance_request_;
}
inline ::zaoxun::DistanceRequest* CommonMessage::release_distance_request() {
  clear_has_distance_request();
  ::zaoxun::DistanceRequest* temp = distance_request_;
  distance_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_distance_request(::zaoxun::DistanceRequest* distance_request) {
  delete distance_request_;
  distance_request_ = distance_request;
  if (distance_request) {
    set_has_distance_request();
  } else {
    clear_has_distance_request();
  }
}

// optional .zaoxun.DistanceResponse distance_response = 11;
inline bool CommonMessage::has_distance_response() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommonMessage::set_has_distance_response() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommonMessage::clear_has_distance_response() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommonMessage::clear_distance_response() {
  if (distance_response_ != NULL) distance_response_->::zaoxun::DistanceResponse::Clear();
  clear_has_distance_response();
}
inline const ::zaoxun::DistanceResponse& CommonMessage::distance_response() const {
  return distance_response_ != NULL ? *distance_response_ : *default_instance_->distance_response_;
}
inline ::zaoxun::DistanceResponse* CommonMessage::mutable_distance_response() {
  set_has_distance_response();
  if (distance_response_ == NULL) distance_response_ = new ::zaoxun::DistanceResponse;
  return distance_response_;
}
inline ::zaoxun::DistanceResponse* CommonMessage::release_distance_response() {
  clear_has_distance_response();
  ::zaoxun::DistanceResponse* temp = distance_response_;
  distance_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_distance_response(::zaoxun::DistanceResponse* distance_response) {
  delete distance_response_;
  distance_response_ = distance_response;
  if (distance_response) {
    set_has_distance_response();
  } else {
    clear_has_distance_response();
  }
}

// optional .zaoxun.TimesRequest times_request = 12;
inline bool CommonMessage::has_times_request() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CommonMessage::set_has_times_request() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CommonMessage::clear_has_times_request() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CommonMessage::clear_times_request() {
  if (times_request_ != NULL) times_request_->::zaoxun::TimesRequest::Clear();
  clear_has_times_request();
}
inline const ::zaoxun::TimesRequest& CommonMessage::times_request() const {
  return times_request_ != NULL ? *times_request_ : *default_instance_->times_request_;
}
inline ::zaoxun::TimesRequest* CommonMessage::mutable_times_request() {
  set_has_times_request();
  if (times_request_ == NULL) times_request_ = new ::zaoxun::TimesRequest;
  return times_request_;
}
inline ::zaoxun::TimesRequest* CommonMessage::release_times_request() {
  clear_has_times_request();
  ::zaoxun::TimesRequest* temp = times_request_;
  times_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_times_request(::zaoxun::TimesRequest* times_request) {
  delete times_request_;
  times_request_ = times_request;
  if (times_request) {
    set_has_times_request();
  } else {
    clear_has_times_request();
  }
}

// optional .zaoxun.TimesResponse times_response = 13;
inline bool CommonMessage::has_times_response() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CommonMessage::set_has_times_response() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CommonMessage::clear_has_times_response() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CommonMessage::clear_times_response() {
  if (times_response_ != NULL) times_response_->::zaoxun::TimesResponse::Clear();
  clear_has_times_response();
}
inline const ::zaoxun::TimesResponse& CommonMessage::times_response() const {
  return times_response_ != NULL ? *times_response_ : *default_instance_->times_response_;
}
inline ::zaoxun::TimesResponse* CommonMessage::mutable_times_response() {
  set_has_times_response();
  if (times_response_ == NULL) times_response_ = new ::zaoxun::TimesResponse;
  return times_response_;
}
inline ::zaoxun::TimesResponse* CommonMessage::release_times_response() {
  clear_has_times_response();
  ::zaoxun::TimesResponse* temp = times_response_;
  times_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_times_response(::zaoxun::TimesResponse* times_response) {
  delete times_response_;
  times_response_ = times_response;
  if (times_response) {
    set_has_times_response();
  } else {
    clear_has_times_response();
  }
}

// optional .zaoxun.OilingRequest oiling_request = 14;
inline bool CommonMessage::has_oiling_request() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CommonMessage::set_has_oiling_request() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CommonMessage::clear_has_oiling_request() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CommonMessage::clear_oiling_request() {
  if (oiling_request_ != NULL) oiling_request_->::zaoxun::OilingRequest::Clear();
  clear_has_oiling_request();
}
inline const ::zaoxun::OilingRequest& CommonMessage::oiling_request() const {
  return oiling_request_ != NULL ? *oiling_request_ : *default_instance_->oiling_request_;
}
inline ::zaoxun::OilingRequest* CommonMessage::mutable_oiling_request() {
  set_has_oiling_request();
  if (oiling_request_ == NULL) oiling_request_ = new ::zaoxun::OilingRequest;
  return oiling_request_;
}
inline ::zaoxun::OilingRequest* CommonMessage::release_oiling_request() {
  clear_has_oiling_request();
  ::zaoxun::OilingRequest* temp = oiling_request_;
  oiling_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_oiling_request(::zaoxun::OilingRequest* oiling_request) {
  delete oiling_request_;
  oiling_request_ = oiling_request;
  if (oiling_request) {
    set_has_oiling_request();
  } else {
    clear_has_oiling_request();
  }
}

// optional .zaoxun.OilingResponse oiling_response = 15;
inline bool CommonMessage::has_oiling_response() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CommonMessage::set_has_oiling_response() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CommonMessage::clear_has_oiling_response() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CommonMessage::clear_oiling_response() {
  if (oiling_response_ != NULL) oiling_response_->::zaoxun::OilingResponse::Clear();
  clear_has_oiling_response();
}
inline const ::zaoxun::OilingResponse& CommonMessage::oiling_response() const {
  return oiling_response_ != NULL ? *oiling_response_ : *default_instance_->oiling_response_;
}
inline ::zaoxun::OilingResponse* CommonMessage::mutable_oiling_response() {
  set_has_oiling_response();
  if (oiling_response_ == NULL) oiling_response_ = new ::zaoxun::OilingResponse;
  return oiling_response_;
}
inline ::zaoxun::OilingResponse* CommonMessage::release_oiling_response() {
  clear_has_oiling_response();
  ::zaoxun::OilingResponse* temp = oiling_response_;
  oiling_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_oiling_response(::zaoxun::OilingResponse* oiling_response) {
  delete oiling_response_;
  oiling_response_ = oiling_response;
  if (oiling_response) {
    set_has_oiling_response();
  } else {
    clear_has_oiling_response();
  }
}

// optional .zaoxun.LoadRequest load_request = 16;
inline bool CommonMessage::has_load_request() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CommonMessage::set_has_load_request() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CommonMessage::clear_has_load_request() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CommonMessage::clear_load_request() {
  if (load_request_ != NULL) load_request_->::zaoxun::LoadRequest::Clear();
  clear_has_load_request();
}
inline const ::zaoxun::LoadRequest& CommonMessage::load_request() const {
  return load_request_ != NULL ? *load_request_ : *default_instance_->load_request_;
}
inline ::zaoxun::LoadRequest* CommonMessage::mutable_load_request() {
  set_has_load_request();
  if (load_request_ == NULL) load_request_ = new ::zaoxun::LoadRequest;
  return load_request_;
}
inline ::zaoxun::LoadRequest* CommonMessage::release_load_request() {
  clear_has_load_request();
  ::zaoxun::LoadRequest* temp = load_request_;
  load_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_load_request(::zaoxun::LoadRequest* load_request) {
  delete load_request_;
  load_request_ = load_request;
  if (load_request) {
    set_has_load_request();
  } else {
    clear_has_load_request();
  }
}

// optional .zaoxun.LoadResponse load_response = 17;
inline bool CommonMessage::has_load_response() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CommonMessage::set_has_load_response() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CommonMessage::clear_has_load_response() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CommonMessage::clear_load_response() {
  if (load_response_ != NULL) load_response_->::zaoxun::LoadResponse::Clear();
  clear_has_load_response();
}
inline const ::zaoxun::LoadResponse& CommonMessage::load_response() const {
  return load_response_ != NULL ? *load_response_ : *default_instance_->load_response_;
}
inline ::zaoxun::LoadResponse* CommonMessage::mutable_load_response() {
  set_has_load_response();
  if (load_response_ == NULL) load_response_ = new ::zaoxun::LoadResponse;
  return load_response_;
}
inline ::zaoxun::LoadResponse* CommonMessage::release_load_response() {
  clear_has_load_response();
  ::zaoxun::LoadResponse* temp = load_response_;
  load_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_load_response(::zaoxun::LoadResponse* load_response) {
  delete load_response_;
  load_response_ = load_response;
  if (load_response) {
    set_has_load_response();
  } else {
    clear_has_load_response();
  }
}

// optional .zaoxun.UnloadRequest unload_request = 18;
inline bool CommonMessage::has_unload_request() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CommonMessage::set_has_unload_request() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CommonMessage::clear_has_unload_request() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CommonMessage::clear_unload_request() {
  if (unload_request_ != NULL) unload_request_->::zaoxun::UnloadRequest::Clear();
  clear_has_unload_request();
}
inline const ::zaoxun::UnloadRequest& CommonMessage::unload_request() const {
  return unload_request_ != NULL ? *unload_request_ : *default_instance_->unload_request_;
}
inline ::zaoxun::UnloadRequest* CommonMessage::mutable_unload_request() {
  set_has_unload_request();
  if (unload_request_ == NULL) unload_request_ = new ::zaoxun::UnloadRequest;
  return unload_request_;
}
inline ::zaoxun::UnloadRequest* CommonMessage::release_unload_request() {
  clear_has_unload_request();
  ::zaoxun::UnloadRequest* temp = unload_request_;
  unload_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_unload_request(::zaoxun::UnloadRequest* unload_request) {
  delete unload_request_;
  unload_request_ = unload_request;
  if (unload_request) {
    set_has_unload_request();
  } else {
    clear_has_unload_request();
  }
}

// optional .zaoxun.UnloadResponse unload_response = 19;
inline bool CommonMessage::has_unload_response() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CommonMessage::set_has_unload_response() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CommonMessage::clear_has_unload_response() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CommonMessage::clear_unload_response() {
  if (unload_response_ != NULL) unload_response_->::zaoxun::UnloadResponse::Clear();
  clear_has_unload_response();
}
inline const ::zaoxun::UnloadResponse& CommonMessage::unload_response() const {
  return unload_response_ != NULL ? *unload_response_ : *default_instance_->unload_response_;
}
inline ::zaoxun::UnloadResponse* CommonMessage::mutable_unload_response() {
  set_has_unload_response();
  if (unload_response_ == NULL) unload_response_ = new ::zaoxun::UnloadResponse;
  return unload_response_;
}
inline ::zaoxun::UnloadResponse* CommonMessage::release_unload_response() {
  clear_has_unload_response();
  ::zaoxun::UnloadResponse* temp = unload_response_;
  unload_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_unload_response(::zaoxun::UnloadResponse* unload_response) {
  delete unload_response_;
  unload_response_ = unload_response;
  if (unload_response) {
    set_has_unload_response();
  } else {
    clear_has_unload_response();
  }
}

// optional .zaoxun.SpeedLimitMessage speed_limit = 20;
inline bool CommonMessage::has_speed_limit() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CommonMessage::set_has_speed_limit() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CommonMessage::clear_has_speed_limit() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CommonMessage::clear_speed_limit() {
  if (speed_limit_ != NULL) speed_limit_->::zaoxun::SpeedLimitMessage::Clear();
  clear_has_speed_limit();
}
inline const ::zaoxun::SpeedLimitMessage& CommonMessage::speed_limit() const {
  return speed_limit_ != NULL ? *speed_limit_ : *default_instance_->speed_limit_;
}
inline ::zaoxun::SpeedLimitMessage* CommonMessage::mutable_speed_limit() {
  set_has_speed_limit();
  if (speed_limit_ == NULL) speed_limit_ = new ::zaoxun::SpeedLimitMessage;
  return speed_limit_;
}
inline ::zaoxun::SpeedLimitMessage* CommonMessage::release_speed_limit() {
  clear_has_speed_limit();
  ::zaoxun::SpeedLimitMessage* temp = speed_limit_;
  speed_limit_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_speed_limit(::zaoxun::SpeedLimitMessage* speed_limit) {
  delete speed_limit_;
  speed_limit_ = speed_limit;
  if (speed_limit) {
    set_has_speed_limit();
  } else {
    clear_has_speed_limit();
  }
}

// optional .zaoxun.ShortMessage short_message = 21;
inline bool CommonMessage::has_short_message() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CommonMessage::set_has_short_message() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CommonMessage::clear_has_short_message() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CommonMessage::clear_short_message() {
  if (short_message_ != NULL) short_message_->::zaoxun::ShortMessage::Clear();
  clear_has_short_message();
}
inline const ::zaoxun::ShortMessage& CommonMessage::short_message() const {
  return short_message_ != NULL ? *short_message_ : *default_instance_->short_message_;
}
inline ::zaoxun::ShortMessage* CommonMessage::mutable_short_message() {
  set_has_short_message();
  if (short_message_ == NULL) short_message_ = new ::zaoxun::ShortMessage;
  return short_message_;
}
inline ::zaoxun::ShortMessage* CommonMessage::release_short_message() {
  clear_has_short_message();
  ::zaoxun::ShortMessage* temp = short_message_;
  short_message_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_short_message(::zaoxun::ShortMessage* short_message) {
  delete short_message_;
  short_message_ = short_message;
  if (short_message) {
    set_has_short_message();
  } else {
    clear_has_short_message();
  }
}

// optional .zaoxun.GPSData gps_data = 22;
inline bool CommonMessage::has_gps_data() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CommonMessage::set_has_gps_data() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CommonMessage::clear_has_gps_data() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CommonMessage::clear_gps_data() {
  if (gps_data_ != NULL) gps_data_->::zaoxun::GPSData::Clear();
  clear_has_gps_data();
}
inline const ::zaoxun::GPSData& CommonMessage::gps_data() const {
  return gps_data_ != NULL ? *gps_data_ : *default_instance_->gps_data_;
}
inline ::zaoxun::GPSData* CommonMessage::mutable_gps_data() {
  set_has_gps_data();
  if (gps_data_ == NULL) gps_data_ = new ::zaoxun::GPSData;
  return gps_data_;
}
inline ::zaoxun::GPSData* CommonMessage::release_gps_data() {
  clear_has_gps_data();
  ::zaoxun::GPSData* temp = gps_data_;
  gps_data_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_gps_data(::zaoxun::GPSData* gps_data) {
  delete gps_data_;
  gps_data_ = gps_data;
  if (gps_data) {
    set_has_gps_data();
  } else {
    clear_has_gps_data();
  }
}

// optional .zaoxun.AudioFileData audio_file_data = 23;
inline bool CommonMessage::has_audio_file_data() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CommonMessage::set_has_audio_file_data() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CommonMessage::clear_has_audio_file_data() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CommonMessage::clear_audio_file_data() {
  if (audio_file_data_ != NULL) audio_file_data_->::zaoxun::AudioFileData::Clear();
  clear_has_audio_file_data();
}
inline const ::zaoxun::AudioFileData& CommonMessage::audio_file_data() const {
  return audio_file_data_ != NULL ? *audio_file_data_ : *default_instance_->audio_file_data_;
}
inline ::zaoxun::AudioFileData* CommonMessage::mutable_audio_file_data() {
  set_has_audio_file_data();
  if (audio_file_data_ == NULL) audio_file_data_ = new ::zaoxun::AudioFileData;
  return audio_file_data_;
}
inline ::zaoxun::AudioFileData* CommonMessage::release_audio_file_data() {
  clear_has_audio_file_data();
  ::zaoxun::AudioFileData* temp = audio_file_data_;
  audio_file_data_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_audio_file_data(::zaoxun::AudioFileData* audio_file_data) {
  delete audio_file_data_;
  audio_file_data_ = audio_file_data;
  if (audio_file_data) {
    set_has_audio_file_data();
  } else {
    clear_has_audio_file_data();
  }
}

// optional .zaoxun.CaptureFileData capture_file_data = 24;
inline bool CommonMessage::has_capture_file_data() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CommonMessage::set_has_capture_file_data() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CommonMessage::clear_has_capture_file_data() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CommonMessage::clear_capture_file_data() {
  if (capture_file_data_ != NULL) capture_file_data_->::zaoxun::CaptureFileData::Clear();
  clear_has_capture_file_data();
}
inline const ::zaoxun::CaptureFileData& CommonMessage::capture_file_data() const {
  return capture_file_data_ != NULL ? *capture_file_data_ : *default_instance_->capture_file_data_;
}
inline ::zaoxun::CaptureFileData* CommonMessage::mutable_capture_file_data() {
  set_has_capture_file_data();
  if (capture_file_data_ == NULL) capture_file_data_ = new ::zaoxun::CaptureFileData;
  return capture_file_data_;
}
inline ::zaoxun::CaptureFileData* CommonMessage::release_capture_file_data() {
  clear_has_capture_file_data();
  ::zaoxun::CaptureFileData* temp = capture_file_data_;
  capture_file_data_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_capture_file_data(::zaoxun::CaptureFileData* capture_file_data) {
  delete capture_file_data_;
  capture_file_data_ = capture_file_data;
  if (capture_file_data) {
    set_has_capture_file_data();
  } else {
    clear_has_capture_file_data();
  }
}

// optional .zaoxun.MaterialsNotification materials_notification = 25;
inline bool CommonMessage::has_materials_notification() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CommonMessage::set_has_materials_notification() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CommonMessage::clear_has_materials_notification() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CommonMessage::clear_materials_notification() {
  if (materials_notification_ != NULL) materials_notification_->::zaoxun::MaterialsNotification::Clear();
  clear_has_materials_notification();
}
inline const ::zaoxun::MaterialsNotification& CommonMessage::materials_notification() const {
  return materials_notification_ != NULL ? *materials_notification_ : *default_instance_->materials_notification_;
}
inline ::zaoxun::MaterialsNotification* CommonMessage::mutable_materials_notification() {
  set_has_materials_notification();
  if (materials_notification_ == NULL) materials_notification_ = new ::zaoxun::MaterialsNotification;
  return materials_notification_;
}
inline ::zaoxun::MaterialsNotification* CommonMessage::release_materials_notification() {
  clear_has_materials_notification();
  ::zaoxun::MaterialsNotification* temp = materials_notification_;
  materials_notification_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_materials_notification(::zaoxun::MaterialsNotification* materials_notification) {
  delete materials_notification_;
  materials_notification_ = materials_notification;
  if (materials_notification) {
    set_has_materials_notification();
  } else {
    clear_has_materials_notification();
  }
}

// optional .zaoxun.AntiCollisionNotification anticollision_notification = 26;
inline bool CommonMessage::has_anticollision_notification() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CommonMessage::set_has_anticollision_notification() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CommonMessage::clear_has_anticollision_notification() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CommonMessage::clear_anticollision_notification() {
  if (anticollision_notification_ != NULL) anticollision_notification_->::zaoxun::AntiCollisionNotification::Clear();
  clear_has_anticollision_notification();
}
inline const ::zaoxun::AntiCollisionNotification& CommonMessage::anticollision_notification() const {
  return anticollision_notification_ != NULL ? *anticollision_notification_ : *default_instance_->anticollision_notification_;
}
inline ::zaoxun::AntiCollisionNotification* CommonMessage::mutable_anticollision_notification() {
  set_has_anticollision_notification();
  if (anticollision_notification_ == NULL) anticollision_notification_ = new ::zaoxun::AntiCollisionNotification;
  return anticollision_notification_;
}
inline ::zaoxun::AntiCollisionNotification* CommonMessage::release_anticollision_notification() {
  clear_has_anticollision_notification();
  ::zaoxun::AntiCollisionNotification* temp = anticollision_notification_;
  anticollision_notification_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_anticollision_notification(::zaoxun::AntiCollisionNotification* anticollision_notification) {
  delete anticollision_notification_;
  anticollision_notification_ = anticollision_notification;
  if (anticollision_notification) {
    set_has_anticollision_notification();
  } else {
    clear_has_anticollision_notification();
  }
}

// optional .zaoxun.EDipperInfoNotification edipperinfo_notification = 27;
inline bool CommonMessage::has_edipperinfo_notification() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CommonMessage::set_has_edipperinfo_notification() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CommonMessage::clear_has_edipperinfo_notification() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CommonMessage::clear_edipperinfo_notification() {
  if (edipperinfo_notification_ != NULL) edipperinfo_notification_->::zaoxun::EDipperInfoNotification::Clear();
  clear_has_edipperinfo_notification();
}
inline const ::zaoxun::EDipperInfoNotification& CommonMessage::edipperinfo_notification() const {
  return edipperinfo_notification_ != NULL ? *edipperinfo_notification_ : *default_instance_->edipperinfo_notification_;
}
inline ::zaoxun::EDipperInfoNotification* CommonMessage::mutable_edipperinfo_notification() {
  set_has_edipperinfo_notification();
  if (edipperinfo_notification_ == NULL) edipperinfo_notification_ = new ::zaoxun::EDipperInfoNotification;
  return edipperinfo_notification_;
}
inline ::zaoxun::EDipperInfoNotification* CommonMessage::release_edipperinfo_notification() {
  clear_has_edipperinfo_notification();
  ::zaoxun::EDipperInfoNotification* temp = edipperinfo_notification_;
  edipperinfo_notification_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_edipperinfo_notification(::zaoxun::EDipperInfoNotification* edipperinfo_notification) {
  delete edipperinfo_notification_;
  edipperinfo_notification_ = edipperinfo_notification;
  if (edipperinfo_notification) {
    set_has_edipperinfo_notification();
  } else {
    clear_has_edipperinfo_notification();
  }
}

// optional .zaoxun.GetEDippersRequest get_edippers_request = 28;
inline bool CommonMessage::has_get_edippers_request() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CommonMessage::set_has_get_edippers_request() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CommonMessage::clear_has_get_edippers_request() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CommonMessage::clear_get_edippers_request() {
  if (get_edippers_request_ != NULL) get_edippers_request_->::zaoxun::GetEDippersRequest::Clear();
  clear_has_get_edippers_request();
}
inline const ::zaoxun::GetEDippersRequest& CommonMessage::get_edippers_request() const {
  return get_edippers_request_ != NULL ? *get_edippers_request_ : *default_instance_->get_edippers_request_;
}
inline ::zaoxun::GetEDippersRequest* CommonMessage::mutable_get_edippers_request() {
  set_has_get_edippers_request();
  if (get_edippers_request_ == NULL) get_edippers_request_ = new ::zaoxun::GetEDippersRequest;
  return get_edippers_request_;
}
inline ::zaoxun::GetEDippersRequest* CommonMessage::release_get_edippers_request() {
  clear_has_get_edippers_request();
  ::zaoxun::GetEDippersRequest* temp = get_edippers_request_;
  get_edippers_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_get_edippers_request(::zaoxun::GetEDippersRequest* get_edippers_request) {
  delete get_edippers_request_;
  get_edippers_request_ = get_edippers_request;
  if (get_edippers_request) {
    set_has_get_edippers_request();
  } else {
    clear_has_get_edippers_request();
  }
}

// optional .zaoxun.GetEDippersResponse get_edippers_response = 29;
inline bool CommonMessage::has_get_edippers_response() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CommonMessage::set_has_get_edippers_response() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CommonMessage::clear_has_get_edippers_response() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CommonMessage::clear_get_edippers_response() {
  if (get_edippers_response_ != NULL) get_edippers_response_->::zaoxun::GetEDippersResponse::Clear();
  clear_has_get_edippers_response();
}
inline const ::zaoxun::GetEDippersResponse& CommonMessage::get_edippers_response() const {
  return get_edippers_response_ != NULL ? *get_edippers_response_ : *default_instance_->get_edippers_response_;
}
inline ::zaoxun::GetEDippersResponse* CommonMessage::mutable_get_edippers_response() {
  set_has_get_edippers_response();
  if (get_edippers_response_ == NULL) get_edippers_response_ = new ::zaoxun::GetEDippersResponse;
  return get_edippers_response_;
}
inline ::zaoxun::GetEDippersResponse* CommonMessage::release_get_edippers_response() {
  clear_has_get_edippers_response();
  ::zaoxun::GetEDippersResponse* temp = get_edippers_response_;
  get_edippers_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_get_edippers_response(::zaoxun::GetEDippersResponse* get_edippers_response) {
  delete get_edippers_response_;
  get_edippers_response_ = get_edippers_response;
  if (get_edippers_response) {
    set_has_get_edippers_response();
  } else {
    clear_has_get_edippers_response();
  }
}

// optional .zaoxun.LoadCompleteRequest load_complete_request = 30;
inline bool CommonMessage::has_load_complete_request() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CommonMessage::set_has_load_complete_request() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CommonMessage::clear_has_load_complete_request() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CommonMessage::clear_load_complete_request() {
  if (load_complete_request_ != NULL) load_complete_request_->::zaoxun::LoadCompleteRequest::Clear();
  clear_has_load_complete_request();
}
inline const ::zaoxun::LoadCompleteRequest& CommonMessage::load_complete_request() const {
  return load_complete_request_ != NULL ? *load_complete_request_ : *default_instance_->load_complete_request_;
}
inline ::zaoxun::LoadCompleteRequest* CommonMessage::mutable_load_complete_request() {
  set_has_load_complete_request();
  if (load_complete_request_ == NULL) load_complete_request_ = new ::zaoxun::LoadCompleteRequest;
  return load_complete_request_;
}
inline ::zaoxun::LoadCompleteRequest* CommonMessage::release_load_complete_request() {
  clear_has_load_complete_request();
  ::zaoxun::LoadCompleteRequest* temp = load_complete_request_;
  load_complete_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_load_complete_request(::zaoxun::LoadCompleteRequest* load_complete_request) {
  delete load_complete_request_;
  load_complete_request_ = load_complete_request;
  if (load_complete_request) {
    set_has_load_complete_request();
  } else {
    clear_has_load_complete_request();
  }
}

// optional .zaoxun.LoadCompleteResponse load_complete_response = 31;
inline bool CommonMessage::has_load_complete_response() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CommonMessage::set_has_load_complete_response() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CommonMessage::clear_has_load_complete_response() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CommonMessage::clear_load_complete_response() {
  if (load_complete_response_ != NULL) load_complete_response_->::zaoxun::LoadCompleteResponse::Clear();
  clear_has_load_complete_response();
}
inline const ::zaoxun::LoadCompleteResponse& CommonMessage::load_complete_response() const {
  return load_complete_response_ != NULL ? *load_complete_response_ : *default_instance_->load_complete_response_;
}
inline ::zaoxun::LoadCompleteResponse* CommonMessage::mutable_load_complete_response() {
  set_has_load_complete_response();
  if (load_complete_response_ == NULL) load_complete_response_ = new ::zaoxun::LoadCompleteResponse;
  return load_complete_response_;
}
inline ::zaoxun::LoadCompleteResponse* CommonMessage::release_load_complete_response() {
  clear_has_load_complete_response();
  ::zaoxun::LoadCompleteResponse* temp = load_complete_response_;
  load_complete_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_load_complete_response(::zaoxun::LoadCompleteResponse* load_complete_response) {
  delete load_complete_response_;
  load_complete_response_ = load_complete_response;
  if (load_complete_response) {
    set_has_load_complete_response();
  } else {
    clear_has_load_complete_response();
  }
}

// optional .zaoxun.CancelLoadRequest cancel_load_request = 32;
inline bool CommonMessage::has_cancel_load_request() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CommonMessage::set_has_cancel_load_request() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CommonMessage::clear_has_cancel_load_request() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CommonMessage::clear_cancel_load_request() {
  if (cancel_load_request_ != NULL) cancel_load_request_->::zaoxun::CancelLoadRequest::Clear();
  clear_has_cancel_load_request();
}
inline const ::zaoxun::CancelLoadRequest& CommonMessage::cancel_load_request() const {
  return cancel_load_request_ != NULL ? *cancel_load_request_ : *default_instance_->cancel_load_request_;
}
inline ::zaoxun::CancelLoadRequest* CommonMessage::mutable_cancel_load_request() {
  set_has_cancel_load_request();
  if (cancel_load_request_ == NULL) cancel_load_request_ = new ::zaoxun::CancelLoadRequest;
  return cancel_load_request_;
}
inline ::zaoxun::CancelLoadRequest* CommonMessage::release_cancel_load_request() {
  clear_has_cancel_load_request();
  ::zaoxun::CancelLoadRequest* temp = cancel_load_request_;
  cancel_load_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_cancel_load_request(::zaoxun::CancelLoadRequest* cancel_load_request) {
  delete cancel_load_request_;
  cancel_load_request_ = cancel_load_request;
  if (cancel_load_request) {
    set_has_cancel_load_request();
  } else {
    clear_has_cancel_load_request();
  }
}

// optional .zaoxun.CancelLoadResponse cancel_load_response = 33;
inline bool CommonMessage::has_cancel_load_response() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CommonMessage::set_has_cancel_load_response() {
  _has_bits_[1] |= 0x00000001u;
}
inline void CommonMessage::clear_has_cancel_load_response() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void CommonMessage::clear_cancel_load_response() {
  if (cancel_load_response_ != NULL) cancel_load_response_->::zaoxun::CancelLoadResponse::Clear();
  clear_has_cancel_load_response();
}
inline const ::zaoxun::CancelLoadResponse& CommonMessage::cancel_load_response() const {
  return cancel_load_response_ != NULL ? *cancel_load_response_ : *default_instance_->cancel_load_response_;
}
inline ::zaoxun::CancelLoadResponse* CommonMessage::mutable_cancel_load_response() {
  set_has_cancel_load_response();
  if (cancel_load_response_ == NULL) cancel_load_response_ = new ::zaoxun::CancelLoadResponse;
  return cancel_load_response_;
}
inline ::zaoxun::CancelLoadResponse* CommonMessage::release_cancel_load_response() {
  clear_has_cancel_load_response();
  ::zaoxun::CancelLoadResponse* temp = cancel_load_response_;
  cancel_load_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_cancel_load_response(::zaoxun::CancelLoadResponse* cancel_load_response) {
  delete cancel_load_response_;
  cancel_load_response_ = cancel_load_response;
  if (cancel_load_response) {
    set_has_cancel_load_response();
  } else {
    clear_has_cancel_load_response();
  }
}

// optional .zaoxun.RejectLoadRequest reject_load_request = 34;
inline bool CommonMessage::has_reject_load_request() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void CommonMessage::set_has_reject_load_request() {
  _has_bits_[1] |= 0x00000002u;
}
inline void CommonMessage::clear_has_reject_load_request() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void CommonMessage::clear_reject_load_request() {
  if (reject_load_request_ != NULL) reject_load_request_->::zaoxun::RejectLoadRequest::Clear();
  clear_has_reject_load_request();
}
inline const ::zaoxun::RejectLoadRequest& CommonMessage::reject_load_request() const {
  return reject_load_request_ != NULL ? *reject_load_request_ : *default_instance_->reject_load_request_;
}
inline ::zaoxun::RejectLoadRequest* CommonMessage::mutable_reject_load_request() {
  set_has_reject_load_request();
  if (reject_load_request_ == NULL) reject_load_request_ = new ::zaoxun::RejectLoadRequest;
  return reject_load_request_;
}
inline ::zaoxun::RejectLoadRequest* CommonMessage::release_reject_load_request() {
  clear_has_reject_load_request();
  ::zaoxun::RejectLoadRequest* temp = reject_load_request_;
  reject_load_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_reject_load_request(::zaoxun::RejectLoadRequest* reject_load_request) {
  delete reject_load_request_;
  reject_load_request_ = reject_load_request;
  if (reject_load_request) {
    set_has_reject_load_request();
  } else {
    clear_has_reject_load_request();
  }
}

// optional .zaoxun.RejectLoadResponse reject_load_response = 35;
inline bool CommonMessage::has_reject_load_response() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void CommonMessage::set_has_reject_load_response() {
  _has_bits_[1] |= 0x00000004u;
}
inline void CommonMessage::clear_has_reject_load_response() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void CommonMessage::clear_reject_load_response() {
  if (reject_load_response_ != NULL) reject_load_response_->::zaoxun::RejectLoadResponse::Clear();
  clear_has_reject_load_response();
}
inline const ::zaoxun::RejectLoadResponse& CommonMessage::reject_load_response() const {
  return reject_load_response_ != NULL ? *reject_load_response_ : *default_instance_->reject_load_response_;
}
inline ::zaoxun::RejectLoadResponse* CommonMessage::mutable_reject_load_response() {
  set_has_reject_load_response();
  if (reject_load_response_ == NULL) reject_load_response_ = new ::zaoxun::RejectLoadResponse;
  return reject_load_response_;
}
inline ::zaoxun::RejectLoadResponse* CommonMessage::release_reject_load_response() {
  clear_has_reject_load_response();
  ::zaoxun::RejectLoadResponse* temp = reject_load_response_;
  reject_load_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_reject_load_response(::zaoxun::RejectLoadResponse* reject_load_response) {
  delete reject_load_response_;
  reject_load_response_ = reject_load_response;
  if (reject_load_response) {
    set_has_reject_load_response();
  } else {
    clear_has_reject_load_response();
  }
}

// optional .zaoxun.ExitNotification exit_notification = 36;
inline bool CommonMessage::has_exit_notification() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void CommonMessage::set_has_exit_notification() {
  _has_bits_[1] |= 0x00000008u;
}
inline void CommonMessage::clear_has_exit_notification() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void CommonMessage::clear_exit_notification() {
  if (exit_notification_ != NULL) exit_notification_->::zaoxun::ExitNotification::Clear();
  clear_has_exit_notification();
}
inline const ::zaoxun::ExitNotification& CommonMessage::exit_notification() const {
  return exit_notification_ != NULL ? *exit_notification_ : *default_instance_->exit_notification_;
}
inline ::zaoxun::ExitNotification* CommonMessage::mutable_exit_notification() {
  set_has_exit_notification();
  if (exit_notification_ == NULL) exit_notification_ = new ::zaoxun::ExitNotification;
  return exit_notification_;
}
inline ::zaoxun::ExitNotification* CommonMessage::release_exit_notification() {
  clear_has_exit_notification();
  ::zaoxun::ExitNotification* temp = exit_notification_;
  exit_notification_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_exit_notification(::zaoxun::ExitNotification* exit_notification) {
  delete exit_notification_;
  exit_notification_ = exit_notification;
  if (exit_notification) {
    set_has_exit_notification();
  } else {
    clear_has_exit_notification();
  }
}

// optional .zaoxun.DeviceStatusRequest device_status_request = 37;
inline bool CommonMessage::has_device_status_request() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void CommonMessage::set_has_device_status_request() {
  _has_bits_[1] |= 0x00000010u;
}
inline void CommonMessage::clear_has_device_status_request() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void CommonMessage::clear_device_status_request() {
  if (device_status_request_ != NULL) device_status_request_->::zaoxun::DeviceStatusRequest::Clear();
  clear_has_device_status_request();
}
inline const ::zaoxun::DeviceStatusRequest& CommonMessage::device_status_request() const {
  return device_status_request_ != NULL ? *device_status_request_ : *default_instance_->device_status_request_;
}
inline ::zaoxun::DeviceStatusRequest* CommonMessage::mutable_device_status_request() {
  set_has_device_status_request();
  if (device_status_request_ == NULL) device_status_request_ = new ::zaoxun::DeviceStatusRequest;
  return device_status_request_;
}
inline ::zaoxun::DeviceStatusRequest* CommonMessage::release_device_status_request() {
  clear_has_device_status_request();
  ::zaoxun::DeviceStatusRequest* temp = device_status_request_;
  device_status_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_device_status_request(::zaoxun::DeviceStatusRequest* device_status_request) {
  delete device_status_request_;
  device_status_request_ = device_status_request;
  if (device_status_request) {
    set_has_device_status_request();
  } else {
    clear_has_device_status_request();
  }
}

// optional .zaoxun.MaterialsRequest materials_request = 38;
inline bool CommonMessage::has_materials_request() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void CommonMessage::set_has_materials_request() {
  _has_bits_[1] |= 0x00000020u;
}
inline void CommonMessage::clear_has_materials_request() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void CommonMessage::clear_materials_request() {
  if (materials_request_ != NULL) materials_request_->::zaoxun::MaterialsRequest::Clear();
  clear_has_materials_request();
}
inline const ::zaoxun::MaterialsRequest& CommonMessage::materials_request() const {
  return materials_request_ != NULL ? *materials_request_ : *default_instance_->materials_request_;
}
inline ::zaoxun::MaterialsRequest* CommonMessage::mutable_materials_request() {
  set_has_materials_request();
  if (materials_request_ == NULL) materials_request_ = new ::zaoxun::MaterialsRequest;
  return materials_request_;
}
inline ::zaoxun::MaterialsRequest* CommonMessage::release_materials_request() {
  clear_has_materials_request();
  ::zaoxun::MaterialsRequest* temp = materials_request_;
  materials_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_materials_request(::zaoxun::MaterialsRequest* materials_request) {
  delete materials_request_;
  materials_request_ = materials_request;
  if (materials_request) {
    set_has_materials_request();
  } else {
    clear_has_materials_request();
  }
}

// optional .zaoxun.MaterialsResponse materials_response = 39;
inline bool CommonMessage::has_materials_response() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void CommonMessage::set_has_materials_response() {
  _has_bits_[1] |= 0x00000040u;
}
inline void CommonMessage::clear_has_materials_response() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void CommonMessage::clear_materials_response() {
  if (materials_response_ != NULL) materials_response_->::zaoxun::MaterialsResponse::Clear();
  clear_has_materials_response();
}
inline const ::zaoxun::MaterialsResponse& CommonMessage::materials_response() const {
  return materials_response_ != NULL ? *materials_response_ : *default_instance_->materials_response_;
}
inline ::zaoxun::MaterialsResponse* CommonMessage::mutable_materials_response() {
  set_has_materials_response();
  if (materials_response_ == NULL) materials_response_ = new ::zaoxun::MaterialsResponse;
  return materials_response_;
}
inline ::zaoxun::MaterialsResponse* CommonMessage::release_materials_response() {
  clear_has_materials_response();
  ::zaoxun::MaterialsResponse* temp = materials_response_;
  materials_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_materials_response(::zaoxun::MaterialsResponse* materials_response) {
  delete materials_response_;
  materials_response_ = materials_response;
  if (materials_response) {
    set_has_materials_response();
  } else {
    clear_has_materials_response();
  }
}

// optional .zaoxun.CommandRequest command_request = 40;
inline bool CommonMessage::has_command_request() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void CommonMessage::set_has_command_request() {
  _has_bits_[1] |= 0x00000080u;
}
inline void CommonMessage::clear_has_command_request() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void CommonMessage::clear_command_request() {
  if (command_request_ != NULL) command_request_->::zaoxun::CommandRequest::Clear();
  clear_has_command_request();
}
inline const ::zaoxun::CommandRequest& CommonMessage::command_request() const {
  return command_request_ != NULL ? *command_request_ : *default_instance_->command_request_;
}
inline ::zaoxun::CommandRequest* CommonMessage::mutable_command_request() {
  set_has_command_request();
  if (command_request_ == NULL) command_request_ = new ::zaoxun::CommandRequest;
  return command_request_;
}
inline ::zaoxun::CommandRequest* CommonMessage::release_command_request() {
  clear_has_command_request();
  ::zaoxun::CommandRequest* temp = command_request_;
  command_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_command_request(::zaoxun::CommandRequest* command_request) {
  delete command_request_;
  command_request_ = command_request;
  if (command_request) {
    set_has_command_request();
  } else {
    clear_has_command_request();
  }
}

// optional .zaoxun.ProductionInfoRequest production_info_request = 41;
inline bool CommonMessage::has_production_info_request() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void CommonMessage::set_has_production_info_request() {
  _has_bits_[1] |= 0x00000100u;
}
inline void CommonMessage::clear_has_production_info_request() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void CommonMessage::clear_production_info_request() {
  if (production_info_request_ != NULL) production_info_request_->::zaoxun::ProductionInfoRequest::Clear();
  clear_has_production_info_request();
}
inline const ::zaoxun::ProductionInfoRequest& CommonMessage::production_info_request() const {
  return production_info_request_ != NULL ? *production_info_request_ : *default_instance_->production_info_request_;
}
inline ::zaoxun::ProductionInfoRequest* CommonMessage::mutable_production_info_request() {
  set_has_production_info_request();
  if (production_info_request_ == NULL) production_info_request_ = new ::zaoxun::ProductionInfoRequest;
  return production_info_request_;
}
inline ::zaoxun::ProductionInfoRequest* CommonMessage::release_production_info_request() {
  clear_has_production_info_request();
  ::zaoxun::ProductionInfoRequest* temp = production_info_request_;
  production_info_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_production_info_request(::zaoxun::ProductionInfoRequest* production_info_request) {
  delete production_info_request_;
  production_info_request_ = production_info_request;
  if (production_info_request) {
    set_has_production_info_request();
  } else {
    clear_has_production_info_request();
  }
}

// optional .zaoxun.ProductionInfoResponse production_info_response = 42;
inline bool CommonMessage::has_production_info_response() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void CommonMessage::set_has_production_info_response() {
  _has_bits_[1] |= 0x00000200u;
}
inline void CommonMessage::clear_has_production_info_response() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void CommonMessage::clear_production_info_response() {
  if (production_info_response_ != NULL) production_info_response_->::zaoxun::ProductionInfoResponse::Clear();
  clear_has_production_info_response();
}
inline const ::zaoxun::ProductionInfoResponse& CommonMessage::production_info_response() const {
  return production_info_response_ != NULL ? *production_info_response_ : *default_instance_->production_info_response_;
}
inline ::zaoxun::ProductionInfoResponse* CommonMessage::mutable_production_info_response() {
  set_has_production_info_response();
  if (production_info_response_ == NULL) production_info_response_ = new ::zaoxun::ProductionInfoResponse;
  return production_info_response_;
}
inline ::zaoxun::ProductionInfoResponse* CommonMessage::release_production_info_response() {
  clear_has_production_info_response();
  ::zaoxun::ProductionInfoResponse* temp = production_info_response_;
  production_info_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_production_info_response(::zaoxun::ProductionInfoResponse* production_info_response) {
  delete production_info_response_;
  production_info_response_ = production_info_response;
  if (production_info_response) {
    set_has_production_info_response();
  } else {
    clear_has_production_info_response();
  }
}

// optional .zaoxun.FuelRequest fuel_request = 43;
inline bool CommonMessage::has_fuel_request() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void CommonMessage::set_has_fuel_request() {
  _has_bits_[1] |= 0x00000400u;
}
inline void CommonMessage::clear_has_fuel_request() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void CommonMessage::clear_fuel_request() {
  if (fuel_request_ != NULL) fuel_request_->::zaoxun::FuelRequest::Clear();
  clear_has_fuel_request();
}
inline const ::zaoxun::FuelRequest& CommonMessage::fuel_request() const {
  return fuel_request_ != NULL ? *fuel_request_ : *default_instance_->fuel_request_;
}
inline ::zaoxun::FuelRequest* CommonMessage::mutable_fuel_request() {
  set_has_fuel_request();
  if (fuel_request_ == NULL) fuel_request_ = new ::zaoxun::FuelRequest;
  return fuel_request_;
}
inline ::zaoxun::FuelRequest* CommonMessage::release_fuel_request() {
  clear_has_fuel_request();
  ::zaoxun::FuelRequest* temp = fuel_request_;
  fuel_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_fuel_request(::zaoxun::FuelRequest* fuel_request) {
  delete fuel_request_;
  fuel_request_ = fuel_request;
  if (fuel_request) {
    set_has_fuel_request();
  } else {
    clear_has_fuel_request();
  }
}

// optional .zaoxun.FuelResponse fuel_response = 44;
inline bool CommonMessage::has_fuel_response() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void CommonMessage::set_has_fuel_response() {
  _has_bits_[1] |= 0x00000800u;
}
inline void CommonMessage::clear_has_fuel_response() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void CommonMessage::clear_fuel_response() {
  if (fuel_response_ != NULL) fuel_response_->::zaoxun::FuelResponse::Clear();
  clear_has_fuel_response();
}
inline const ::zaoxun::FuelResponse& CommonMessage::fuel_response() const {
  return fuel_response_ != NULL ? *fuel_response_ : *default_instance_->fuel_response_;
}
inline ::zaoxun::FuelResponse* CommonMessage::mutable_fuel_response() {
  set_has_fuel_response();
  if (fuel_response_ == NULL) fuel_response_ = new ::zaoxun::FuelResponse;
  return fuel_response_;
}
inline ::zaoxun::FuelResponse* CommonMessage::release_fuel_response() {
  clear_has_fuel_response();
  ::zaoxun::FuelResponse* temp = fuel_response_;
  fuel_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_fuel_response(::zaoxun::FuelResponse* fuel_response) {
  delete fuel_response_;
  fuel_response_ = fuel_response;
  if (fuel_response) {
    set_has_fuel_response();
  } else {
    clear_has_fuel_response();
  }
}

// optional .zaoxun.HeartBeat heart_beat = 45;
inline bool CommonMessage::has_heart_beat() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void CommonMessage::set_has_heart_beat() {
  _has_bits_[1] |= 0x00001000u;
}
inline void CommonMessage::clear_has_heart_beat() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void CommonMessage::clear_heart_beat() {
  if (heart_beat_ != NULL) heart_beat_->::zaoxun::HeartBeat::Clear();
  clear_has_heart_beat();
}
inline const ::zaoxun::HeartBeat& CommonMessage::heart_beat() const {
  return heart_beat_ != NULL ? *heart_beat_ : *default_instance_->heart_beat_;
}
inline ::zaoxun::HeartBeat* CommonMessage::mutable_heart_beat() {
  set_has_heart_beat();
  if (heart_beat_ == NULL) heart_beat_ = new ::zaoxun::HeartBeat;
  return heart_beat_;
}
inline ::zaoxun::HeartBeat* CommonMessage::release_heart_beat() {
  clear_has_heart_beat();
  ::zaoxun::HeartBeat* temp = heart_beat_;
  heart_beat_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_heart_beat(::zaoxun::HeartBeat* heart_beat) {
  delete heart_beat_;
  heart_beat_ = heart_beat;
  if (heart_beat) {
    set_has_heart_beat();
  } else {
    clear_has_heart_beat();
  }
}

// optional .zaoxun.TargetNotification target_notification = 46;
inline bool CommonMessage::has_target_notification() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void CommonMessage::set_has_target_notification() {
  _has_bits_[1] |= 0x00002000u;
}
inline void CommonMessage::clear_has_target_notification() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void CommonMessage::clear_target_notification() {
  if (target_notification_ != NULL) target_notification_->::zaoxun::TargetNotification::Clear();
  clear_has_target_notification();
}
inline const ::zaoxun::TargetNotification& CommonMessage::target_notification() const {
  return target_notification_ != NULL ? *target_notification_ : *default_instance_->target_notification_;
}
inline ::zaoxun::TargetNotification* CommonMessage::mutable_target_notification() {
  set_has_target_notification();
  if (target_notification_ == NULL) target_notification_ = new ::zaoxun::TargetNotification;
  return target_notification_;
}
inline ::zaoxun::TargetNotification* CommonMessage::release_target_notification() {
  clear_has_target_notification();
  ::zaoxun::TargetNotification* temp = target_notification_;
  target_notification_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_target_notification(::zaoxun::TargetNotification* target_notification) {
  delete target_notification_;
  target_notification_ = target_notification;
  if (target_notification) {
    set_has_target_notification();
  } else {
    clear_has_target_notification();
  }
}

// optional .zaoxun.DeviceStatusResponse device_status_response = 47;
inline bool CommonMessage::has_device_status_response() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void CommonMessage::set_has_device_status_response() {
  _has_bits_[1] |= 0x00004000u;
}
inline void CommonMessage::clear_has_device_status_response() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void CommonMessage::clear_device_status_response() {
  if (device_status_response_ != NULL) device_status_response_->::zaoxun::DeviceStatusResponse::Clear();
  clear_has_device_status_response();
}
inline const ::zaoxun::DeviceStatusResponse& CommonMessage::device_status_response() const {
  return device_status_response_ != NULL ? *device_status_response_ : *default_instance_->device_status_response_;
}
inline ::zaoxun::DeviceStatusResponse* CommonMessage::mutable_device_status_response() {
  set_has_device_status_response();
  if (device_status_response_ == NULL) device_status_response_ = new ::zaoxun::DeviceStatusResponse;
  return device_status_response_;
}
inline ::zaoxun::DeviceStatusResponse* CommonMessage::release_device_status_response() {
  clear_has_device_status_response();
  ::zaoxun::DeviceStatusResponse* temp = device_status_response_;
  device_status_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_device_status_response(::zaoxun::DeviceStatusResponse* device_status_response) {
  delete device_status_response_;
  device_status_response_ = device_status_response;
  if (device_status_response) {
    set_has_device_status_response();
  } else {
    clear_has_device_status_response();
  }
}

// optional .zaoxun.CommandResponse command_response = 48;
inline bool CommonMessage::has_command_response() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void CommonMessage::set_has_command_response() {
  _has_bits_[1] |= 0x00008000u;
}
inline void CommonMessage::clear_has_command_response() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void CommonMessage::clear_command_response() {
  if (command_response_ != NULL) command_response_->::zaoxun::CommandResponse::Clear();
  clear_has_command_response();
}
inline const ::zaoxun::CommandResponse& CommonMessage::command_response() const {
  return command_response_ != NULL ? *command_response_ : *default_instance_->command_response_;
}
inline ::zaoxun::CommandResponse* CommonMessage::mutable_command_response() {
  set_has_command_response();
  if (command_response_ == NULL) command_response_ = new ::zaoxun::CommandResponse;
  return command_response_;
}
inline ::zaoxun::CommandResponse* CommonMessage::release_command_response() {
  clear_has_command_response();
  ::zaoxun::CommandResponse* temp = command_response_;
  command_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_command_response(::zaoxun::CommandResponse* command_response) {
  delete command_response_;
  command_response_ = command_response;
  if (command_response) {
    set_has_command_response();
  } else {
    clear_has_command_response();
  }
}

// optional .zaoxun.ManualLoadCompleteRequest manual_load_complete_request = 49;
inline bool CommonMessage::has_manual_load_complete_request() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void CommonMessage::set_has_manual_load_complete_request() {
  _has_bits_[1] |= 0x00010000u;
}
inline void CommonMessage::clear_has_manual_load_complete_request() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void CommonMessage::clear_manual_load_complete_request() {
  if (manual_load_complete_request_ != NULL) manual_load_complete_request_->::zaoxun::ManualLoadCompleteRequest::Clear();
  clear_has_manual_load_complete_request();
}
inline const ::zaoxun::ManualLoadCompleteRequest& CommonMessage::manual_load_complete_request() const {
  return manual_load_complete_request_ != NULL ? *manual_load_complete_request_ : *default_instance_->manual_load_complete_request_;
}
inline ::zaoxun::ManualLoadCompleteRequest* CommonMessage::mutable_manual_load_complete_request() {
  set_has_manual_load_complete_request();
  if (manual_load_complete_request_ == NULL) manual_load_complete_request_ = new ::zaoxun::ManualLoadCompleteRequest;
  return manual_load_complete_request_;
}
inline ::zaoxun::ManualLoadCompleteRequest* CommonMessage::release_manual_load_complete_request() {
  clear_has_manual_load_complete_request();
  ::zaoxun::ManualLoadCompleteRequest* temp = manual_load_complete_request_;
  manual_load_complete_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_manual_load_complete_request(::zaoxun::ManualLoadCompleteRequest* manual_load_complete_request) {
  delete manual_load_complete_request_;
  manual_load_complete_request_ = manual_load_complete_request;
  if (manual_load_complete_request) {
    set_has_manual_load_complete_request();
  } else {
    clear_has_manual_load_complete_request();
  }
}

// optional .zaoxun.ManualLoadCompleteResponse manual_load_complete_response = 50;
inline bool CommonMessage::has_manual_load_complete_response() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void CommonMessage::set_has_manual_load_complete_response() {
  _has_bits_[1] |= 0x00020000u;
}
inline void CommonMessage::clear_has_manual_load_complete_response() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void CommonMessage::clear_manual_load_complete_response() {
  if (manual_load_complete_response_ != NULL) manual_load_complete_response_->::zaoxun::ManualLoadCompleteResponse::Clear();
  clear_has_manual_load_complete_response();
}
inline const ::zaoxun::ManualLoadCompleteResponse& CommonMessage::manual_load_complete_response() const {
  return manual_load_complete_response_ != NULL ? *manual_load_complete_response_ : *default_instance_->manual_load_complete_response_;
}
inline ::zaoxun::ManualLoadCompleteResponse* CommonMessage::mutable_manual_load_complete_response() {
  set_has_manual_load_complete_response();
  if (manual_load_complete_response_ == NULL) manual_load_complete_response_ = new ::zaoxun::ManualLoadCompleteResponse;
  return manual_load_complete_response_;
}
inline ::zaoxun::ManualLoadCompleteResponse* CommonMessage::release_manual_load_complete_response() {
  clear_has_manual_load_complete_response();
  ::zaoxun::ManualLoadCompleteResponse* temp = manual_load_complete_response_;
  manual_load_complete_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_manual_load_complete_response(::zaoxun::ManualLoadCompleteResponse* manual_load_complete_response) {
  delete manual_load_complete_response_;
  manual_load_complete_response_ = manual_load_complete_response;
  if (manual_load_complete_response) {
    set_has_manual_load_complete_response();
  } else {
    clear_has_manual_load_complete_response();
  }
}

// optional .zaoxun.ManualUnloadRequest manual_unload_request = 51;
inline bool CommonMessage::has_manual_unload_request() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void CommonMessage::set_has_manual_unload_request() {
  _has_bits_[1] |= 0x00040000u;
}
inline void CommonMessage::clear_has_manual_unload_request() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void CommonMessage::clear_manual_unload_request() {
  if (manual_unload_request_ != NULL) manual_unload_request_->::zaoxun::ManualUnloadRequest::Clear();
  clear_has_manual_unload_request();
}
inline const ::zaoxun::ManualUnloadRequest& CommonMessage::manual_unload_request() const {
  return manual_unload_request_ != NULL ? *manual_unload_request_ : *default_instance_->manual_unload_request_;
}
inline ::zaoxun::ManualUnloadRequest* CommonMessage::mutable_manual_unload_request() {
  set_has_manual_unload_request();
  if (manual_unload_request_ == NULL) manual_unload_request_ = new ::zaoxun::ManualUnloadRequest;
  return manual_unload_request_;
}
inline ::zaoxun::ManualUnloadRequest* CommonMessage::release_manual_unload_request() {
  clear_has_manual_unload_request();
  ::zaoxun::ManualUnloadRequest* temp = manual_unload_request_;
  manual_unload_request_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_manual_unload_request(::zaoxun::ManualUnloadRequest* manual_unload_request) {
  delete manual_unload_request_;
  manual_unload_request_ = manual_unload_request;
  if (manual_unload_request) {
    set_has_manual_unload_request();
  } else {
    clear_has_manual_unload_request();
  }
}

// optional .zaoxun.ManualUnloadResponse manual_unload_response = 52;
inline bool CommonMessage::has_manual_unload_response() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void CommonMessage::set_has_manual_unload_response() {
  _has_bits_[1] |= 0x00080000u;
}
inline void CommonMessage::clear_has_manual_unload_response() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void CommonMessage::clear_manual_unload_response() {
  if (manual_unload_response_ != NULL) manual_unload_response_->::zaoxun::ManualUnloadResponse::Clear();
  clear_has_manual_unload_response();
}
inline const ::zaoxun::ManualUnloadResponse& CommonMessage::manual_unload_response() const {
  return manual_unload_response_ != NULL ? *manual_unload_response_ : *default_instance_->manual_unload_response_;
}
inline ::zaoxun::ManualUnloadResponse* CommonMessage::mutable_manual_unload_response() {
  set_has_manual_unload_response();
  if (manual_unload_response_ == NULL) manual_unload_response_ = new ::zaoxun::ManualUnloadResponse;
  return manual_unload_response_;
}
inline ::zaoxun::ManualUnloadResponse* CommonMessage::release_manual_unload_response() {
  clear_has_manual_unload_response();
  ::zaoxun::ManualUnloadResponse* temp = manual_unload_response_;
  manual_unload_response_ = NULL;
  return temp;
}
inline void CommonMessage::set_allocated_manual_unload_response(::zaoxun::ManualUnloadResponse* manual_unload_response) {
  delete manual_unload_response_;
  manual_unload_response_ = manual_unload_response;
  if (manual_unload_response) {
    set_has_manual_unload_response();
  } else {
    clear_has_manual_unload_response();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace zaoxun

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zaoxun::MessageType>() {
  return ::zaoxun::MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zaoxun::CarType>() {
  return ::zaoxun::CarType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zaoxun::RunningStatus>() {
  return ::zaoxun::RunningStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_2eproto__INCLUDED
